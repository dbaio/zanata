# $FreeBSD$
# Edson Brandi <ebrandi@FreeBSD.org>, 2019. #zanata
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2018-12-08 14:50-0200\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2019-05-01 07:21+0000\n"
"Last-Translator: Copied by Zanata <copied-by-zanata@zanata.org>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: pt_BR\n"
"X-Generator: Zanata 4.6.2\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr "translator-credits"

#. (itstool) path: info/title
#: book.translate.xml:17
#, fuzzy
msgid "PMake — A Tutorial"
msgstr "PMake - Um tutorial"

#. (itstool) path: info/author
#: book.translate.xml:20
msgid ""
"<personname><firstname>Adam</firstname><surname>de Boor</surname></"
"personname>"
msgstr ""
"<personname><firstname>Adam</firstname><surname>de Boor</surname></"
"personname>"

#. (itstool) path: info/copyright
#: book.translate.xml:22
msgid "<year>1988</year> <year>1989</year> <holder>Adam de Boor</holder>"
msgstr "<year>1988</year> <year>1989</year> <holder>Adam de Boor</holder>"

#. (itstool) path: info/copyright
#: book.translate.xml:28
msgid "<year>1989</year> <holder>Berkeley Softworks</holder>"
msgstr "<year>1989</year> <holder>Berkeley Softworks</holder>"

#. (itstool) path: info/copyright
#: book.translate.xml:33
msgid ""
"<year>1988</year> <year>1989</year> <year>1993</year> <holder>The Regents of "
"the University of California.</holder>"
msgstr ""
"<year>1988</year> <year>1989</year> <year>1993</year> <holder>The Regents of "
"the University of California.</holder>"

#. (itstool) path: legalnotice/para
#: book.translate.xml:45
msgid "All rights reserved."
msgstr "All rights reserved."

#. (itstool) path: legalnotice/para
#: book.translate.xml:47
msgid ""
"This code is derived from software contributed to Berkeley by Adam de Boor."
msgstr ""
"This code is derived from software contributed to Berkeley by Adam de Boor."

#. (itstool) path: legalnotice/para
#: book.translate.xml:50
msgid ""
"Redistribution and use in source and binary forms, with or without "
"modification, are permitted provided that the following conditions are met:"
msgstr ""
"Redistribution and use in source and binary forms, with or without "
"modification, are permitted provided that the following conditions are met:"

#. (itstool) path: listitem/para
#: book.translate.xml:56
msgid ""
"Redistributions of source code must retain the above copyright notice, this "
"list of conditions and the following disclaimer."
msgstr ""
"Redistributions of source code must retain the above copyright notice, this "
"list of conditions and the following disclaimer."

#. (itstool) path: listitem/para
#: book.translate.xml:61
msgid ""
"Redistributions in binary form must reproduce the above copyright notice, "
"this list of conditions and the following disclaimer in the documentation "
"and/or other materials provided with the distribution."
msgstr ""
"Redistributions in binary form must reproduce the above copyright notice, "
"this list of conditions and the following disclaimer in the documentation "
"and/or other materials provided with the distribution."

#. (itstool) path: listitem/para
#: book.translate.xml:68
msgid ""
"Neither the name of the University nor the names of its contributors may be "
"used to endorse or promote products derived from this software without "
"specific prior written permission."
msgstr ""
"Neither the name of the University nor the names of its contributors may be "
"used to endorse or promote products derived from this software without "
"specific prior written permission."

#. (itstool) path: important/para
#: book.translate.xml:76
msgid ""
"THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS \"AS IS\" AND ANY "
"EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED "
"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE "
"DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY "
"DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES "
"(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; "
"LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND "
"ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT "
"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF "
"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS \"AS IS\" AND ANY "
"EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED "
"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE "
"DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY "
"DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES "
"(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; "
"LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND "
"ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT "
"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF "
"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."

#. (itstool) path: info/releaseinfo
#: book.translate.xml:91
msgid ""
"$FreeBSD: head/en_US.ISO8859-1/books/pmake/book.xml 43184 2013-11-13 07:52:"
"45Z hrs $"
msgstr ""
"$FreeBSD: head/en_US.ISO8859-1/books/pmake/book.xml 43184 2013-11-13 07:52:"
"45Z hrs $"

#. (itstool) path: chapter/title
#: book.translate.xml:101
msgid "Introduction"
msgstr "Introdução"

#. (itstool) path: chapter/para
#: book.translate.xml:103
#, fuzzy
msgid ""
"<application>PMake</application> is a program for creating other programs, "
"or anything else you can think of for it to do. The basic idea behind "
"<application>PMake</application> is that, for any given system, be it a "
"program or a document or whatever, there will be some files that depend on "
"the state of other files (on when they were last modified). "
"<application>PMake</application> takes these dependencies, which you must "
"specify, and uses them to build whatever it is you want it to build."
msgstr ""
"<application> PMake </ application> é um programa para criar outros "
"programas, ou qualquer outra coisa que você possa pensar para fazer. A ideia "
"básica por trás <application> PMake </ application> é que, para qualquer "
"sistema, seja um programa ou um documento ou qualquer outra coisa, haverá "
"alguns arquivos que dependem o estado de outros arquivos (quando foram "
"modificados pela última vez). <application> PMake </ application> aceita "
"essas dependências, que você deve especifique e use-os para construir o que "
"quer que você queira construir."

#. (itstool) path: chapter/para
#: book.translate.xml:112
#, fuzzy
msgid ""
"<application>PMake</application> is almost fully-compatible with "
"<application>Make</application>, with which you may already be familiar. "
"<application>PMake</application>'s most important feature is its ability to "
"run several different jobs at once, making the creation of systems "
"considerably faster. It also has a great deal more functionality than "
"<application>Make</application>."
msgstr ""
"<application> PMake </ application> é quase totalmente compatível com "
"<application> Make </ application>, com o qual você já está familiarizado. O "
"recurso mais importante do <application> PMake </ application> é sua "
"capacidade de executar vários trabalhos diferentes ao mesmo tempo, fazendo a "
"criação de sistemas consideravelmente mais rápido. Ele também tem muito mais "
"funcionalidade do que <application> Make </ application>."

#. (itstool) path: chapter/para
#: book.translate.xml:119
#, fuzzy
msgid ""
"This tutorial is divided into three main sections corresponding to basic, "
"intermediate and advanced <application>PMake</application> usage. If you "
"already know <application>Make</application> well, you will only need to "
"skim <xref linkend=\"basics\"/> (there are some aspects of "
"<application>PMake</application> that I consider basic to its use that did "
"not exist in <application>Make</application>). Things in <xref linkend="
"\"shortcuts\"/> make life much easier, while those in <xref linkend=\"gods\"/"
"> are strictly for those who know what they are doing. <xref linkend="
"\"glossary\"/> has definitions for the jargon I use and <xref linkend="
"\"answers\"/> contains possible solutions to the problems presented "
"throughout the tutorial."
msgstr ""
"Este tutorial está dividido em três seções principais que correspondem ao "
"básico, uso intermediário e avançado de <application> PMake </ application>. "
"Se vocês já sabe <application> Make </ application> bem, você só precisa "
"skim <xref linkend = \\ \"basics \\\" /> (existem alguns aspectos de "
"<application> PMake </ application> que considero básico para seu uso que "
"fez não existe em <application> Make </ application>). Coisas em <xref "
"linkend = \\ \"atalhos \\\" /> tornam a vida muito mais fácil, enquanto "
"aqueles em <xref linkend = \\ \"gods \\\" / > são estritamente para aqueles "
"que sabem o que estão fazendo. <xref linkend = \\ \"glossary \\\" /> tem "
"definições para o jargão que eu uso e <xref linkend = \\ \"respostas \\\" /> "
"contém possíveis soluções para os problemas apresentados ao longo do "
"tutorial."

#. (itstool) path: chapter/title
#: book.translate.xml:137
#, fuzzy
msgid "The Basics of PMake"
msgstr "O básico do PMake"

#. (itstool) path: chapter/para
#: book.translate.xml:139
#, fuzzy
msgid ""
"<application>PMake</application> takes as input a file that tells which "
"files depend on which other files to be complete and what to do about files "
"that are <quote>out-of-date</quote>. This file is known as a "
"<quote>makefile</quote> and is usually kept in the top-most directory of the "
"system to be built. While you can call the makefile anything you want, "
"<application>PMake</application> will look for <filename>Makefile</filename> "
"and <filename>makefile</filename> (in that order) in the current directory "
"if you do not tell it otherwise. To specify a different makefile, use the "
"<option>-f</option> flag, e.g."
msgstr ""
"<application> PMake </ application> recebe como entrada um arquivo que "
"informa qual os arquivos dependem de quais outros arquivos ficarem completos "
"e o que fazer com os arquivos que estão <quote> desatualizados </ quote>. "
"Este arquivo é conhecido como <quote> makefile </ quote> e geralmente é "
"mantido no diretório mais alto do sistema a ser construído. Enquanto você "
"pode chamar o makefile como quiser, <application> PMake </ application> irá "
"procurar pelo <filename> Makefile </ filename> e <filename> makefile </ "
"filename> (nessa ordem) no diretório atual se você não disser o contrário. "
"Para especificar um makefile diferente, use o Sinalizador <option> -f </ "
"option>, por ex."

#. (itstool) path: chapter/screen
#: book.translate.xml:151
#, fuzzy, no-wrap
msgid ""
"<prompt>%</prompt> <userinput>pmake -f <replaceable>program.mk</"
"replaceable></userinput>"
msgstr ""
"<prompt>% </ prompt> <userinput> pmake -f <substituível> program.mk </ "
"replaceable> </ userinput>"

#. (itstool) path: chapter/para
#: book.translate.xml:153
#, fuzzy
msgid "A makefile has four different types of lines in it:"
msgstr "Um makefile tem quatro tipos diferentes de linhas:"

#. (itstool) path: listitem/para
#: book.translate.xml:157
#, fuzzy
msgid "File dependency specifications"
msgstr "Especificações de dependência de arquivos"

#. (itstool) path: listitem/para
#: book.translate.xml:161 book.translate.xml:1608
#, fuzzy
msgid "Creation commands"
msgstr "Comandos de criação"

#. (itstool) path: listitem/para
#: book.translate.xml:165 book.translate.xml:1612
#, fuzzy
msgid "Variable assignments"
msgstr "Atribuições variáveis"

#. (itstool) path: listitem/para
#: book.translate.xml:169 book.translate.xml:1616
#, fuzzy
msgid "Comments, include statements and conditional directives"
msgstr "Comentários, incluir declarações e diretivas condicionais"

#. (itstool) path: chapter/para
#: book.translate.xml:173
#, fuzzy
msgid ""
"Any line may be continued over multiple lines by ending it with a backslash. "
"The backslash, following newline and any initial whitespace on the following "
"line are compressed into a single space before the input line is examined by "
"<application>PMake</application>."
msgstr ""
"Qualquer linha pode ser continuada em várias linhas terminando com uma barra "
"invertida. A barra invertida, seguindo a nova linha e qualquer espaço em "
"branco inicial no seguinte linha são compactados em um único espaço antes "
"que a linha de entrada seja examinada por <application> PMake </ "
"application>."

#. (itstool) path: section/title
#: book.translate.xml:180
#, fuzzy
msgid "Dependency Lines"
msgstr "Linhas de Dependência"

#. (itstool) path: section/para
#: book.translate.xml:182
#, fuzzy
msgid ""
"As mentioned in the introduction, in any system, there are dependencies "
"between the files that make up the system. For instance, in a program made "
"up of several C source files and one header file, the C files will need to "
"be re-compiled should the header file be changed. For a document of several "
"chapters and one macro file, the chapters will need to be reprocessed if any "
"of the macros changes. These are dependencies and are specified by means of "
"dependency lines in the makefile."
msgstr ""
"Como mencionado na introdução, em qualquer sistema, existem dependências "
"entre os arquivos que compõem o sistema. Por exemplo, em um programa feito "
"de vários arquivos de origem C e um arquivo de cabeçalho, os arquivos C "
"precisarão ser re-compilado caso o arquivo de cabeçalho seja alterado. Para "
"um documento de vários capítulos e um arquivo de macro, os capítulos "
"precisarão ser reprocessados se das macros muda. Estas são dependências e "
"são especificadas por meio de linhas de dependência no makefile."

#. (itstool) path: section/para
#: book.translate.xml:191
#, fuzzy
msgid ""
"On a dependency line, there are targets and sources, separated by a one- or "
"two-character operator. The targets <quote>depend</quote> on the sources and "
"are usually created from them. Any number of targets and sources may be "
"specified on a dependency line. All the targets in the line are made to "
"depend on all the sources. Targets and sources need not be actual files, but "
"every source must be either an actual file or another target in the makefile."
" If you run out of room, use a backslash at the end of the line to continue "
"onto the next one."
msgstr ""
"Em uma linha de dependência, existem alvos e fontes, separados por um ou "
"operador de dois caracteres. Os alvos <quote> dependem </ quote> das fontes "
"e geralmente são criados a partir deles. Qualquer número de alvos e fontes "
"pode ser especificado em uma linha de dependência. Todos os alvos na linha "
"são feitos para dependem de todas as fontes. Alvos e fontes não precisam ser "
"arquivos reais, mas cada fonte deve ser um arquivo real ou outro alvo no "
"makefile. Se você ficar sem espaço, use uma barra invertida no final da "
"linha para continue para o próximo."

#. (itstool) path: section/para
#: book.translate.xml:202
#, fuzzy
msgid ""
"Any file may be a target and any file may be a source, but the relationship "
"between the two (or however many) is determined by the <quote>operator</"
"quote> that separates them. Three types of operators exist: one specifies "
"that the datedness of a target is determined by the state of its sources, "
"while another specifies other files (the sources) that need to be dealt with "
"before the target can be re-created. The third operator is very similar to "
"the first, with the additional condition that the target is out-of-date if "
"it has no sources. These operations are represented by the colon, the "
"exclamation point and the double-colon, respectively, and are mutually "
"exclusive. Their exact semantics are as follows:"
msgstr ""
"Qualquer arquivo pode ser um alvo e qualquer arquivo pode ser uma fonte, mas "
"o relacionamento entre os dois (ou quantos) é determinado pelo operador "
"<quote> </ Citação> que os separa. Existem três tipos de operadores: um "
"especifica que a data de um alvo é determinada pelo estado de suas fontes, "
"enquanto outro especifica outros arquivos (as fontes) que precisam ser "
"tratados antes que o destino possa ser recriado. O terceiro operador é muito "
"semelhante ao o primeiro, com a condição adicional de que o alvo está "
"desatualizado se não tem fontes. Essas operações são representadas pelos "
"dois pontos, ponto de exclamação e dois pontos duplos, respectivamente, e "
"são mutuamente exclusivo. Sua semântica exata é a seguinte:"

#. (itstool) path: row/entry
#: book.translate.xml:219
#, fuzzy
msgid "<literal>:</literal>"
msgstr "<literal>: </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:221
#, fuzzy
msgid ""
"If a colon is used, a target on the line is considered to be <quote>out-of-"
"date</quote> (and in need of creation) if any of the sources has been "
"modified more recently than the target, or the target does not exist. Under "
"this operation, steps will be taken to re-create the target only if it is "
"found to be out-of-date by using these two rules."
msgstr ""
"Se um cólon for usado, um alvo na linha será considerado <quote> fora de "
"data </ quote> (e precisa de criação) se alguma das fontes tiver sido "
"modificado mais recentemente que o destino ou o destino não existe. Debaixo "
"essa operação, serão executadas etapas para recriar o destino apenas se ele "
"encontrado desatualizado usando essas duas regras."

#. (itstool) path: row/entry
#: book.translate.xml:231
#, fuzzy
msgid "<literal>!</literal>"
msgstr "<literal>! </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:233
#, fuzzy
msgid ""
"If an exclamation point is used, the target will always be re-created, but "
"this will not happen until all of its sources have been examined and re-"
"created, if necessary."
msgstr ""
"Se um ponto de exclamação for usado, o alvo será sempre recriado, mas isso "
"não acontecerá até que todas as suas fontes tenham sido examinadas e criado, "
"se necessário."

#. (itstool) path: row/entry
#: book.translate.xml:240
#, fuzzy
msgid "<literal>::</literal>"
msgstr "<literal> :: </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:242
#, fuzzy
msgid ""
"If a double-colon is used, a target is <quote>out-of-date</quote> if any of "
"the sources has been modified more recently than the target, or the target "
"does not exist, or the target has no sources. If the target is out-of-date "
"according to these rules, it will be re-created. This operator also does "
"something else to the targets, but I will go into that in the next section "
"(see <xref linkend=\"shellcmds\"/>)."
msgstr ""
"Se um duplo-cólon for usado, um alvo é <quote> desatualizado </ quote> se "
"algum dos as fontes foram modificadas mais recentemente do que o alvo, ou o "
"alvo não existe, ou o alvo não tem fontes. Se o alvo estiver desatualizado "
"de acordo com essas regras, ele será recriado. Este operador também outra "
"coisa para os alvos, mas eu vou entrar nisso na próxima seção (veja <xref "
"linkend = \\ \"shellcmds \\\" />)."

#. (itstool) path: section/para
#: book.translate.xml:256
#, fuzzy
msgid ""
"Enough words, now for an example. Take that C program I mentioned earlier. "
"Say there are three C files (<filename>a.c</filename>, <filename>b.c</"
"filename> and <filename>c.c</filename>) each of which includes the file "
"<filename>defs.h</filename>. The dependencies between the files could then "
"be expressed as follows:"
msgstr ""
"Bastante palavras, agora para um exemplo. Tome esse programa C que mencionei "
"anteriormente. Digamos que há três arquivos C (<filename> a.c </ filename>, "
"<filename> b.c </ filename> e <filename> c.c </ filename>), cada um dos "
"quais inclui o arquivo <filename> defs.h </ filename>. As dependências entre "
"os arquivos poderiam então ser expressa da seguinte forma:"

#. (itstool) path: section/programlisting
#: book.translate.xml:263
#, fuzzy, no-wrap
msgid ""
"program         : a.o b.o c.o\n"
"\n"
"a.o b.o c.o     : defs.h\n"
"\n"
"a.o             : a.c\n"
"\n"
"b.o             : b.c\n"
"\n"
"c.o             : c.c"
msgstr ""
"programa: a.o b.o c.o \\ n \\ n a.o b.o c.o: defs.h \\ n \\ n a.o: a.c \\ n "
"\\ n b.o: b.c \\ n \\ n c.o: c.c"

#. (itstool) path: para/buildtarget
#: book.translate.xml:277
#, fuzzy
msgid "program"
msgstr "programa"

#. (itstool) path: section/para
#: book.translate.xml:273
#, fuzzy
msgid ""
"You may be wondering at this point, where <filename>a.o</filename>, "
"<filename>b.o</filename> and <filename>c.o</filename> came in and why they "
"depend on <filename>defs.h</filename> and the C files do not. The reason is "
"quite simple: <_:buildtarget-1/> cannot be made by linking together "
"<filename>.c</filename> files—it must be made from <filename>.o</filename> "
"files. Likewise, if you change <filename>defs.h</filename>, it is not the "
"<filename>.c</filename> files that need to be re-created, it is the "
"<filename>.o</filename> files. If you think of dependencies in these "
"terms—which files (targets) need to be created from which files "
"(sources)—you should have no problems."
msgstr ""
"Você pode estar se perguntando neste ponto, onde <filename> a.o </ "
"filename>, <filename> b.o </ filename> e <filename> c.o </ filename> vieram "
"e porque eles Depende de <filename> defs.h </ filename> e os arquivos C não. "
"A razão é muito simples: <_: buildtarget-1 /> não pode ser feito vinculando "
"Arquivos <filename> .c </ filename> - devem ser feitos de <filename> .o </ "
"filename> arquivos. Da mesma forma, se você alterar <filename> defs.h </ "
"filename>, não é o <filename> .c </ filename> arquivos que precisam ser "
"recriados, é o Arquivos <filename> .o </ filename>. Se você pensar em "
"dependências nesses termos— quais arquivos (destinos) precisam ser criados a "
"partir de quais arquivos (fontes) não deve ter problemas."

#. (itstool) path: section/para
#: book.translate.xml:287
#, fuzzy
msgid ""
"An important thing to notice about the above example, is that all the "
"<filename>.o</filename> files appear as targets on more than one line. This "
"is perfectly all right: the target is made to depend on all the sources "
"mentioned on all the dependency lines. For example, <filename>a.o</filename> "
"depends on both <filename>defs.h</filename> and <filename>a.c</filename>."
msgstr ""
"Uma coisa importante a notar sobre o exemplo acima, é que todo o Arquivos "
"<filename> .o </ filename> aparecem como alvos em mais de uma linha. este "
"está perfeitamente bem: o alvo é feito para depender de todas as fontes "
"mencionado em todas as linhas de dependência. Por exemplo, <filename> a.o </ "
"filename> Depende de <filename> defs.h </ filename> e <filename> a.c </ "
"filename>."

#. (itstool) path: section/para
#: book.translate.xml:294
#, fuzzy
msgid ""
"The order of the dependency lines in the makefile is important: the first "
"target on the first dependency line in the makefile will be the one that "
"gets made if you do not say otherwise. That is why program comes first in "
"the example makefile, above."
msgstr ""
"A ordem das linhas de dependência no makefile é importante: o primeiro alvo "
"na primeira linha de dependência no makefile será o que é feito se você não "
"disser o contrário. É por isso que o programa vem em primeiro lugar o "
"exemplo makefile, acima."

#. (itstool) path: section/para
#: book.translate.xml:300
#, fuzzy
msgid ""
"Both targets and sources may contain the standard C-Shell wildcard "
"characters (<literal>{</literal>, <literal>}</literal>, <literal>*</"
"literal>, <literal>?</literal>, <literal>[</literal>, and <literal>]</"
"literal>), but the non-curly-brace ones may only appear in the final "
"component (the file portion) of the target or source. The characters mean "
"the following things:"
msgstr ""
"Ambos os destinos e fontes podem conter o caractere curinga padrão do C-"
"Shell caracteres (<literal> {</ literal>, <literal>} </ literal>, <literal> "
"* </ literal>, <literal>? </ literal>, <literal> [</ literal> e <literal>] </"
" literal>), mas os não-chaves podem aparecer apenas no final componente (a "
"parte do arquivo) do destino ou fonte. Os personagens significam as "
"seguintes coisas:"

#. (itstool) path: row/entry
#: book.translate.xml:311
#, fuzzy
msgid "<literal>{}</literal>"
msgstr "<literal> {} </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:313
#, fuzzy
msgid ""
"These enclose a comma-separated list of options and cause the pattern to be "
"expanded once for each element of the list. Each expansion contains a "
"different element. For example, <filename>src/{whiffle,beep,fish}.c</"
"filename> expands to the three words <filename>src/whiffle.c</filename>, "
"<filename>src/beep.c</filename>, and <filename>src/fish.c</filename>. These "
"braces may be nested and, unlike the other wildcard characters, the "
"resulting words need not be actual files. All other wildcard characters are "
"expanded using the files that exist when <application>PMake</application> is "
"started."
msgstr ""
"Estes incluem uma lista de opções separadas por vírgulas e fazem com que o "
"padrão seja expandido uma vez para cada elemento da lista. Cada expansão "
"contém um elemento diferente. Por exemplo, <filename> src / {whiffle, beep, "
"fish} .c </ filename> expande para as três palavras <filename> src / whiffle."
"c </ filename>, <filename> src / beep.c </ filename> e <filename> src / fish."
"c </ filename>. Estes chaves podem ser aninhadas e, ao contrário dos outros "
"caracteres curinga, as palavras resultantes não precisam ser arquivos reais. "
"Todos os outros caracteres curinga são expandido usando os arquivos que "
"existem quando o <application> PMake </ application> é começado."

#. (itstool) path: row/entry
#: book.translate.xml:328
#, fuzzy
msgid "<literal>*</literal>"
msgstr "<literal> * </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:330
#, fuzzy
msgid ""
"This matches zero or more characters of any sort. <filename>src/*.c</"
"filename> will expand to the same three words as above as long as src "
"contains those three files (and no other files that end in <filename>.c</"
"filename>).&gt;"
msgstr ""
"Isso corresponde a zero ou mais caracteres de qualquer tipo. <filename> src /"
" *. c </ filename> expandirá para as mesmas três palavras acima, desde que "
"src contém esses três arquivos (e nenhum outro arquivo que termine em "
"<filename> .c </ nome do arquivo>). & gt;"

#. (itstool) path: row/entry
#: book.translate.xml:338
#, fuzzy
msgid "<literal>?</literal>"
msgstr "<literal>? </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:340
#, fuzzy
msgid "Matches any single character."
msgstr "Corresponde a qualquer caractere único."

#. (itstool) path: row/entry
#: book.translate.xml:344
#, fuzzy
msgid "<literal>[]</literal>"
msgstr "<literal> [] </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:346
#, fuzzy
msgid ""
"This is known as a character class and contains either a list of single "
"characters, or a series of character ranges (<literal>a-z</literal>, for "
"example means all characters between <literal>a</literal> and <literal>z</"
"literal>), or both. It matches any single character contained in the list. "
"For example, <literal>[A-Za-z]</literal> will match all letters, while "
"<literal>[0123456789]</literal> will match all numbers."
msgstr ""
"Isso é conhecido como uma classe de caractere e contém uma lista de "
"caracteres, ou uma série de intervalos de caracteres (<literal> a-z </ "
"literal>, para exemplo significa todos os caracteres entre <literal> a </ "
"literal> e <literal> z </ literal>) ou ambos. Ele corresponde a qualquer "
"caractere único contido na lista. Por exemplo, <literal> [A-Za-z] </ "
"literal> corresponderá a todas as letras, enquanto <literal> [0123456789] </ "
"literal> corresponderá a todos os números."

#. (itstool) path: section/title
#: book.translate.xml:362
#, fuzzy
msgid "Shell Commands"
msgstr "Comandos da Shell"

#. (itstool) path: section/para
#: book.translate.xml:364
#, fuzzy
msgid ""
"<quote>Is not that nice,</quote> you say to yourself, <quote>but how are "
"files actually ``re-created'', as he likes to spell it?</quote> The re-"
"creation is accomplished by commands you place in the makefile. These "
"commands are passed to the Bourne shell (better known as <filename>/bin/sh</"
"filename>) to be executed and are expected to do what is necessary to update "
"the target file (<application>PMake</application> does not actually check to "
"see if the target was created. It just assumes it is there)."
msgstr ""
"<quote> Não é legal, </ quote> você diz para si mesmo, <quote> mas como são "
"arquivos realmente `` recriados '', como ele gosta de soletrar? </ quote> a "
"criação é realizada por comandos que você coloca no makefile. Estes comandos "
"são passados para o shell Bourne (mais conhecido como <filename> / bin / sh "
"</ filename>) a ser executado e espera-se que faça o que for necessário para "
"atualizar o arquivo de destino (<application> PMake </ application> não "
"verifica na verdade veja se o alvo foi criado. Apenas assume que está lá)."

#. (itstool) path: section/para
#: book.translate.xml:374
#, fuzzy
msgid ""
"Shell commands in a makefile look a lot like shell commands you would type "
"at a terminal, with one important exception: each command in a makefile must "
"be preceded by at least one tab."
msgstr ""
"Comandos shell em um makefile se parecem muito com os comandos shell que "
"você digitaria em um terminal, com uma exceção importante: cada comando em "
"um makefile deve ser precedido por pelo menos uma guia."

#. (itstool) path: section/para
#: book.translate.xml:379
#, fuzzy
msgid ""
"Each target has associated with it a shell script made up of one or more of "
"these shell commands. The creation script for a target should immediately "
"follow the dependency line for that target. While any given target may "
"appear on more than one dependency line, only one of these dependency lines "
"may be followed by a creation script, unless the <literal>::</literal> "
"operator was used on the dependency line."
msgstr ""
"Cada alvo tem associado a ele um shell script composto por um ou mais esses "
"comandos shell. O script de criação de um alvo deve ser imediatamente siga a "
"linha de dependência para esse alvo. Enquanto qualquer alvo pode aparecem em "
"mais de uma linha de dependência, apenas uma dessas linhas de dependência "
"pode ser seguido por um script de criação, a menos que o <literal> :: </ "
"literal> operador foi usado na linha de dependência."

#. (itstool) path: section/para
#: book.translate.xml:387
#, fuzzy
msgid ""
"If the double-colon was used, each dependency line for the target may be "
"followed by a shell script. That script will only be executed if the target "
"on the associated dependency line is out-of-date with respect to the sources "
"on that line, according to the rules I gave earlier. I'll give you a good "
"example of this later on."
msgstr ""
"Se o duplo-cólon foi usado, cada linha de dependência para o alvo pode ser "
"seguido por um script de shell. Esse script só será executado se o alvo na "
"linha de dependência associada está desatualizada em relação às fontes nessa "
"linha, de acordo com as regras que dei anteriormente. Eu vou te dar uma boa "
"exemplo disso mais tarde."

#. (itstool) path: section/para
#: book.translate.xml:394
#, fuzzy
msgid "To expand on the earlier makefile, you might add commands as follows:"
msgstr ""
"Para expandir o makefile anterior, você pode adicionar comandos da seguinte "
"maneira:"

#. (itstool) path: section/programlisting
#: book.translate.xml:397
#, fuzzy, no-wrap
msgid ""
"program         : a.o b.o c.o\n"
"        cc a.o b.o c.o -o program\n"
"\n"
"a.o b.o c.o     : defs.h\n"
"a.o             : a.c\n"
"       cc -c a.c\n"
"\n"
"b.o             : b.c\n"
"       cc -c b.c\n"
"\n"
"c.o             : c.c\n"
"       cc -c c.c"
msgstr ""
"programa: a.o b.o c.o \\ n         cc a.o b.o c.o -o programa \\ n \\ n a.o "
"b.o c.o: defs.h \\ n a.o: a.c \\ n        cc -c a.c \\ n \\ n b.o: b.c \\ n "
"       cc -c b.c \\ n \\ n c.o: c.c \\ n        cc -c c.c"

#. (itstool) path: section/para
#: book.translate.xml:410
#, fuzzy
msgid ""
"Something you should remember when writing a makefile is, the commands will "
"be executed if the target on the dependency line is out-of-date, not the "
"sources. In this example, the command <command>cc -c a.c</command> will be "
"executed if <filename>a.o</filename> is out-of-date. Because of the "
"<literal>:</literal> operator, this means that should <filename>a.c</"
"filename> or <filename>defs.h</filename> have been modified more recently "
"than <filename>a.o</filename>, the command will be executed (<filename>a.o</"
"filename> will be considered out-of-date)."
msgstr ""
"Algo que você deve lembrar ao escrever um makefile, os comandos serão ser "
"executado se o alvo na linha de dependência estiver desatualizado, não o "
"fontes. Neste exemplo, o comando <command> cc -c a.c </ command> será "
"executado se <filename> a.o </ filename> estiver desatualizado. Por causa do "
"Operador <literal>: </ literal>, isso significa que deve <filename> a.c </ "
"filename> ou <filename> defs.h </ filename> foram modificados mais "
"recentemente do que <filename> a.o </ filename>, o comando será executado "
"(<filename> a.o </ filename> será considerado desatualizado)."

#. (itstool) path: section/para
#: book.translate.xml:421
#, fuzzy
msgid ""
"Remember how I said the only difference between a makefile shell command and "
"a regular shell command was the leading tab? I lied. There is another way in "
"which makefile commands differ from regular ones. The first two characters "
"after the initial whitespace are treated specially. If they are any "
"combination of <filename>@</filename> and <literal>-</literal>, they cause "
"<application>PMake</application> to do different things."
msgstr ""
"Lembre-se como eu disse a única diferença entre um comando shell makefile e "
"um comando shell regular era a guia principal? Eu menti. Existe outra "
"maneira de quais comandos makefile diferem dos regulares. Os dois primeiros "
"caracteres após o espaço em branco inicial são tratados especialmente. Se "
"eles são algum combinação de <filename> @ </ filename> e <literal> - </ "
"literal>, eles causam <application> PMake </ application> para fazer coisas "
"diferentes."

#. (itstool) path: section/para
#: book.translate.xml:429
#, fuzzy
msgid ""
"In most cases, shell commands are printed before they are actually executed. "
"This is to keep you informed of what is going on. If an <literal>@</literal> "
"appears, however, this echoing is suppressed. In the case of an echo "
"command, say"
msgstr ""
"Na maioria dos casos, os comandos do shell são impressos antes de serem "
"realmente executados. Isso é para mantê-lo informado sobre o que está "
"acontecendo. Se um <literal> @ </ literal> aparece, no entanto, esse eco é "
"suprimido. No caso de um eco comando, digamos"

#. (itstool) path: section/programlisting
#: book.translate.xml:435
#, fuzzy, no-wrap
msgid "echo Linking index"
msgstr "índice de ligação echo"

#. (itstool) path: section/para
#: book.translate.xml:437
#, fuzzy
msgid "it would be rather silly to see"
msgstr "seria um pouco bobo ver"

#. (itstool) path: section/screen
#: book.translate.xml:439
#, fuzzy, no-wrap
msgid "echo Linking index\n"
"Linking index"
msgstr "echo Índice de vinculação \\ n Índice de vinculação"

#. (itstool) path: section/para
#: book.translate.xml:442
#, fuzzy
msgid ""
"so <application>PMake</application> allows you to place an <literal>@</"
"literal> before the command to prevent the command from being printed:"
msgstr ""
"então <application> PMake </ application> permite colocar um <literal> @ </ "
"literal> antes do comando para impedir que o comando seja impresso:"

#. (itstool) path: section/programlisting
#: book.translate.xml:446
#, fuzzy, no-wrap
msgid "@echo Linking index"
msgstr "@echo Linking Index"

#. (itstool) path: section/para
#: book.translate.xml:448
#, fuzzy
msgid ""
"The other special character is the <literal>-</literal>. In case you did not "
"know, shell commands finish with a certain <quote>exit status</quote>. This "
"status is made available by the operating system to whatever program invoked "
"the command. Normally this status will be <literal>0</literal> if everything "
"went ok and non-zero if something went wrong. For this reason, "
"<application>PMake</application> will consider an error to have occurred if "
"one of the shells it invokes returns a non-zero status. When it detects an "
"error, <application>PMake</application>'s usual action is to abort whatever "
"it is doing and exit with a non-zero status itself (any other targets that "
"were being created will continue being made, but nothing new will be started."
" <application>PMake</application> will exit after the last job finishes). "
"This behavior can be altered, however, by placing a <literal>-</literal> at "
"the front of a command (e.g. <command>-mv index index.old</command>), "
"certain command-line arguments, or doing other things, to be detailed later. "
"In such a case, the non-zero status is simply ignored and "
"<application>PMake</application> keeps chugging along."
msgstr ""
"O outro caractere especial é o <literal> - </ literal>. Caso você não tenha "
"sabe, os comandos shell terminam com um determinado <quote> status de saída "
"</ quote>. este status é disponibilizado pelo sistema operacional para "
"qualquer programa invocado o comando. Normalmente este status será <literal> "
"0 </ literal> se tudo foi ok e não-zero se algo deu errado. Por esta razão, "
"<application> PMake </ application> considerará um erro ocorrido se uma das "
"shells invocadas retorna um status diferente de zero. Quando detecta um "
"erro, a ação usual do <application> PMake </ application> é abortar qualquer "
"está fazendo e sai com um status diferente de zero (quaisquer outros alvos "
"que estavam sendo criados continuarão sendo feitos, mas nada de novo será "
"começado. <application> PMake </ application> sairá após o último trabalho "
"termina). Esse comportamento pode ser alterado, no entanto, colocando um "
"<literal> - </ literal> na frente de um comando (por exemplo, <command> -mv "
"index index.old </ comando>), certos argumentos de linha de comando, ou "
"fazer outras coisas, para ser detalhado mais tarde. Nesse caso, o status "
"diferente de zero é simplesmente ignorado e O <application> PMake </ "
"application> continua avançando."

#. (itstool) path: section/para
#: book.translate.xml:470
#, fuzzy
msgid ""
"Because all the commands are given to a single shell to execute, such things "
"as setting shell variables, changing directories, etc., last beyond the "
"command in which they are found. This also allows shell compound commands "
"(like for loops) to be entered in a natural manner. Since this could cause "
"problems for some makefiles that depend on each command being executed by a "
"single shell, <application>PMake</application> has a <option>-B</option> "
"flag (it stands for backwards-compatible) that forces each command to be "
"given to a separate shell. It also does several other things, all of which I "
"discourage since they are now old-fashioned."
msgstr ""
"Porque todos os comandos são dados a um único shell para executar, tais "
"coisas como configurar variáveis de shell, alterar diretórios, etc., durar "
"além do comando em que eles são encontrados. Isso também permite comandos "
"compostos de shell (como para loops) para ser inserido de uma maneira "
"natural. Como isso pode causar problemas para alguns makefiles que dependem "
"de cada comando sendo executado por um shell único, o <application> PMake </ "
"application> tem uma <option> -B </ option> flag (significa retro-"
"compatível) que força cada comando a ser dada a uma casca separada. Também "
"faz várias outras coisas, todas das quais eu desencorajar, uma vez que eles "
"são agora antiquados."

#. (itstool) path: section/para
#: book.translate.xml:483
#, fuzzy
msgid ""
"A target's shell script is fed to the shell on its (the shell's) input "
"stream. This means that any commands, such as <application>ci</application> "
"that need to get input from the terminal will not work right – they will get "
"the shell's input, something they probably will not find to their liking. A "
"simple way around this is to give a command like this:"
msgstr ""
"O shell script de um alvo é alimentado ao shell na sua entrada (da shell) "
"corrente. Isso significa que qualquer comando, como <application> ci </ "
"application> que precisa obter entrada do terminal não vai funcionar direito "
"- eles vão ficar a entrada do shell, algo que eles provavelmente não vão "
"encontrar ao seu gosto. UMA Uma maneira simples de contornar isso é dar um "
"comando como este:"

#. (itstool) path: section/screen
#: book.translate.xml:490
#, fuzzy, no-wrap
msgid "<command>ci $(SRCS) &lt; /dev/tty</command>"
msgstr "<comando> ci $ (SRCS) & lt; / dev / tty </ command>"

#. (itstool) path: section/para
#: book.translate.xml:492
#, fuzzy
msgid ""
"This would force the program's input to come from the terminal. If you "
"cannot do this for some reason, your only other alternative is to use "
"<application>PMake</application> in its fullest compatibility mode. See "
"<quote>Compatibility</quote> in <xref linkend=\"gods\"/>."
msgstr ""
"Isso forçaria a entrada do programa a vir do terminal. Se vocês não pode "
"fazer isso por algum motivo, sua única outra alternativa é usar "
"<application> PMake </ application> no seu modo de compatibilidade mais "
"completo. Vejo <quote> Compatibilidade </ quote> em <xref linkend = \\ "
"\"gods \\\" />."

#. (itstool) path: section/title
#: book.translate.xml:501
#, fuzzy
msgid "Variables"
msgstr "Variáveis"

#. (itstool) path: section/para
#: book.translate.xml:503
#, fuzzy
msgid ""
"<application>PMake</application>, like <application>Make</application> "
"before it, has the ability to save text in variables to be recalled later at "
"your convenience. Variables in <application>PMake</application> are used "
"much like variables in the shell and, by tradition, consist of all upper-"
"case letters (you do not have to use all upper-case letters. In fact there "
"is nothing to stop you from calling a variable <literal>@^&amp;$%$</literal>."
" Just tradition). Variables are assigned-to using lines of the form:"
msgstr ""
"<application> PMake </ application>, como <application> Make </ application> "
"antes disso, tem a capacidade de salvar texto em variáveis a serem lembradas "
"mais tarde sua conveniência. Variáveis no <application> PMake </ "
"application> são usadas muito parecido com variáveis na casca e, por "
"tradição, consistem em todas as letras maiúsculas (você não precisa usar "
"todas as letras maiúsculas. Na verdade, nada impede que você chame uma "
"variável <literal> @ ^ & $; $% </ literal>. Apenas tradição). Variáveis são "
"atribuídas para usar linhas do formulário:"

#. (itstool) path: section/programlisting
#: book.translate.xml:513
#, fuzzy, no-wrap
msgid "VARIABLE = value"
msgstr "VARIÁVEL = valor"

#. (itstool) path: section/para
#: book.translate.xml:515
#, fuzzy
msgid "appended-to by:"
msgstr "acrescentado por:"

#. (itstool) path: section/programlisting
#: book.translate.xml:517
#, fuzzy, no-wrap
msgid "VARIABLE += value"
msgstr "VARIÁVEL + = valor"

#. (itstool) path: section/para
#: book.translate.xml:519
#, fuzzy
msgid "conditionally assigned-to (if the variable is not already defined) by:"
msgstr ""
"condicionalmente atribuído a (se a variável ainda não estiver definida) por:"

#. (itstool) path: section/programlisting
#: book.translate.xml:522
#, fuzzy, no-wrap
msgid "VARIABLE ?= value"
msgstr "VARIÁVEL? = Valor"

#. (itstool) path: section/para
#: book.translate.xml:524
#, fuzzy
msgid ""
"and assigned-to with expansion (i.e. the value is expanded (see below) "
"before being assigned to the variable—useful for placing a value at the "
"beginning of a variable, or other things) by:"
msgstr ""
"e atribuído a com expansão (ou seja, o valor é expandido (veja abaixo) antes "
"de ser atribuído à variável - útil para colocar um valor no início de uma "
"variável ou outras coisas) por:"

#. (itstool) path: section/programlisting
#: book.translate.xml:529
#, fuzzy, no-wrap
msgid "VARIABLE := value"
msgstr "VARIÁVEL: = valor"

#. (itstool) path: section/para
#: book.translate.xml:531
#, fuzzy
msgid ""
"Any whitespace before value is stripped off. When appending, a space is "
"placed between the old value and the stuff being appended."
msgstr ""
"Qualquer espaço em branco antes do valor é retirado. Ao acrescentar, um "
"espaço é colocado entre o valor antigo e o material que está sendo anexado."

#. (itstool) path: section/para
#: book.translate.xml:535
#, fuzzy
msgid "The final way a variable may be assigned to is using:"
msgstr "A maneira final pela qual uma variável pode ser atribuída é usando:"

#. (itstool) path: section/programlisting
#: book.translate.xml:537
#, fuzzy, no-wrap
msgid "VARIABLE != shell-command"
msgstr "VARIÁVEL! = Shell-command"

#. (itstool) path: section/para
#: book.translate.xml:539
#, fuzzy
msgid ""
"In this case, shell-command has all its variables expanded (see below) and "
"is passed off to a shell to execute. The output of the shell is then placed "
"in the variable. Any newlines (other than the final one) are replaced by "
"spaces before the assignment is made. This is typically used to find the "
"current directory via a line like:"
msgstr ""
"Neste caso, o comando shell tem todas as suas variáveis expandidas (veja "
"abaixo) e é passado para um shell para executar. A saída do shell é então "
"colocada na variável. Qualquer nova linha (diferente da final) é substituída "
"por espaços antes da atribuição ser feita. Isso é normalmente usado para "
"encontrar diretório atual através de uma linha como:"

#. (itstool) path: section/programlisting
#: book.translate.xml:546
#, fuzzy, no-wrap
msgid "CWD             != pwd"
msgstr "CWD! = Pwd"

#. (itstool) path: note/para
#: book.translate.xml:549
#, fuzzy
msgid ""
"This is intended to be used to execute commands that produce small amounts "
"of output (e.g. <application>pwd</application>). The implementation is less "
"than intelligent and will likely freeze if you execute something that "
"produces thousands of bytes of output (8 Kb is the limit on many <trademark "
"class=\"registered\">UNIX</trademark> systems). The value of a variable may "
"be retrieved by enclosing the variable name in parentheses or curly braces "
"and preceding the whole thing with a dollar sign."
msgstr ""
"Isto destina-se a ser usado para executar comandos que produzem pequenas "
"quantidades de saída (por exemplo, <application> pwd </ application>). A "
"implementação é menos que inteligente e provavelmente vai congelar se você "
"executar algo que produz milhares de bytes de saída (8 Kb é o limite em "
"muitos <trademark class = \\ \"registered \\\"> UNIX </ trademark> sistemas)."
" O valor de uma variável pode ser recuperado colocando o nome da variável "
"entre parênteses ou chaves e precedendo a coisa toda com um cifrão."

#. (itstool) path: section/para
#: book.translate.xml:560
#, fuzzy
msgid ""
"For example, to set the variable <envar>CFLAGS</envar> to the string "
"<literal>-I/sprite/src/lib/libc -O,</literal> you would place a line:"
msgstr ""
"Por exemplo, para definir a variável <envar> CFLAGS </ envar> para a cadeia "
"<literal> -I / sprite / src / lib / libc -O, </ literal> você colocaria uma "
"linha:"

#. (itstool) path: section/programlisting
#: book.translate.xml:564
#, fuzzy, no-wrap
msgid "CFLAGS = -I/sprite/src/lib/libc -O"
msgstr "CFLAGS = -I / sprite / src / lib / libc -O"

#. (itstool) path: section/para
#: book.translate.xml:566
#, fuzzy
msgid ""
"in the makefile and use the word <literal>$(CFLAGS)</literal> wherever you "
"would like the string <literal>-I/sprite/src/lib/libc -O</literal> to appear."
" This is called variable expansion."
msgstr ""
"no makefile e use a palavra <literal> $ (CFLAGS) </ literal> onde quer que "
"você gostaria que a string <literal> -I / sprite / src / lib / libc -O </ "
"literal> fosse aparecer. Isso é chamado de expansão de variáveis."

#. (itstool) path: note/para
#: book.translate.xml:572
#, fuzzy
msgid ""
"Unlike <application>Make</application>, <application>PMake</application> "
"will not expand a variable unless it knows the variable exists. E.g. if you "
"have a <literal>${i}</literal> in a shell command and you have not assigned "
"a value to the variable <varname>i</varname> (the empty string is considered "
"a value, by the way), where <application>Make</application> would have "
"substituted the empty string, <application>PMake</application> will leave "
"the <literal>${i}</literal> alone. To keep <application>PMake</application> "
"from substituting for a variable it knows, precede the dollar sign with "
"another dollar sign (e.g. to pass <literal>${HOME}</literal> to the shell, "
"use <literal>$${HOME}</literal>). This causes <application>PMake</"
"application>, in effect, to expand the <literal>$</literal> macro, which "
"expands to a single <literal>$</literal>."
msgstr ""
"Ao contrário de <application> Make </ application>, <application> PMake </ "
"application> não expandirá uma variável, a menos que saiba que a variável "
"existe. Por exemplo. se vocês tem um <literal> $ {i} </ literal> em um "
"comando shell e você não atribuiu um valor para a variável <varname> i </ "
"varname> (a string vazia é considerada um valor, a propósito), onde "
"<application> Make </ application> teria substituiu a string vazia, "
"<application> PMake </ application> irá deixar o <literal> $ {i} </ literal> "
"sozinho. Para manter o <application> PMake </ application> de substituir uma "
"variável que conhece, precede o sinal de dólar com outro cifrão (por "
"exemplo, para passar <literal> $ {HOME} </ literal> para o shell, use "
"<literal> $$ {HOME} </ literal>). Isso faz com que <application> PMake </ "
"aplicação>, na verdade, para expandir a macro <literal> $ </ literal>, que "
"expande para um único <literal> $ </ literal>."

#. (itstool) path: section/para
#: book.translate.xml:590
#, fuzzy
msgid ""
"For compatibility, <application>Make</application>'s style of variable "
"expansion will be used if you invoke <application>PMake</application> with "
"any of the compatibility flags (<option>-V</option>, <option>-B</option> or "
"<option>-M</option>. The <option>-V</option> flag alters just the variable "
"expansion). There are two different times at which variable expansion occurs:"
" when parsing a dependency line, the expansion occurs immediately upon "
"reading the line. If any variable used on a dependency line is undefined, "
"<application>PMake</application> will print a message and exit. Variables in "
"shell commands are expanded when the command is executed. Variables used "
"inside another variable are expanded whenever the outer variable is expanded "
"(the expansion of an inner variable has no effect on the outer variable. For "
"example, if the outer variable is used on a dependency line and in a shell "
"command, and the inner variable changes value between when the dependency "
"line is read and the shell command is executed, two different values will be "
"substituted for the outer variable)."
msgstr ""
"Para compatibilidade, o estilo de variável <application> Make </ "
"application> expansão será usada se você chamar <application> PMake </ "
"application> com qualquer um dos flags de compatibilidade (<option> -V </ "
"option>, <option> -B </ option> ou <opção> -M </ option>. O sinalizador "
"<option> -V </ option> altera apenas a variável expansão). Existem dois "
"momentos diferentes em que a expansão das variáveis ocorre: ao analisar uma "
"linha de dependência, a expansão ocorre imediatamente ao ler a linha. Se "
"qualquer variável usada em uma linha de dependência for undefined, "
"<application> PMake </ application> imprimirá uma mensagem e sairá. "
"Variáveis nos comandos shell são expandidas quando o comando é executado. "
"Variáveis usadas dentro de outra variável são expandidas sempre que variável "
"é expandida (a expansão de uma variável interna não tem efeito sobre a "
"variável externa. Por exemplo, se a variável externa for usada em um linha "
"de dependência e em um comando shell, e a variável interna altera o valor "
"entre quando a linha de dependência é lida e o comando shell é executado, "
"dois valores diferentes serão substituídos pela variável externa)."

#. (itstool) path: section/para
#: book.translate.xml:610
#, fuzzy
msgid ""
"Variables come in four flavors, though they are all expanded the same and "
"all look about the same. They are (in order of expanding scope):"
msgstr ""
"As variáveis vêm em quatro sabores, embora todas sejam expandidas da mesma "
"forma e todos parecem iguais. Eles são (em ordem de expandir o escopo):"

#. (itstool) path: listitem/para
#: book.translate.xml:616
#, fuzzy
msgid "Local variables."
msgstr "Variáveis locais."

#. (itstool) path: listitem/para
#: book.translate.xml:620
#, fuzzy
msgid "Command-line variables."
msgstr "Variáveis de linha de comando."

#. (itstool) path: listitem/para
#: book.translate.xml:624
#, fuzzy
msgid "Global variables."
msgstr "Variáveis globais."

#. (itstool) path: listitem/para
#: book.translate.xml:628
#, fuzzy
msgid "Environment variables."
msgstr "Variáveis ambientais."

#. (itstool) path: section/para
#: book.translate.xml:632
#, fuzzy
msgid ""
"The classification of variables does not matter much, except that the "
"classes are searched from the top (local) to the bottom (environment) when "
"looking up a variable. The first one found wins."
msgstr ""
"A classificação das variáveis não importa muito, exceto que o classes são "
"pesquisadas a partir do topo (local) para o fundo (ambiente) quando "
"procurando uma variável. O primeiro encontrado vence."

#. (itstool) path: section/title
#: book.translate.xml:638
#, fuzzy
msgid "Local Variables"
msgstr "Variáveis Locais"

#. (itstool) path: section/para
#: book.translate.xml:640
#, fuzzy
msgid ""
"Each target can have as many as seven local variables. These are variables "
"that are only <quote>visible</quote> within that target's shell script and "
"contain such things as the target's name, all of its sources (from all its "
"dependency lines), those sources that were out-of-date, etc. Four local "
"variables are defined for all targets. They are:"
msgstr ""
"Cada destino pode ter até sete variáveis locais. Estas são variáveis que são "
"apenas <quote> visíveis </ quote> dentro do shell script desse alvo e contém "
"coisas como o nome do alvo, todas as suas fontes (de todas as linhas de "
"dependência), aquelas fontes que estavam desatualizadas, etc. variáveis são "
"definidas para todos os alvos. Eles são:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:649
#, fuzzy
msgid "<varname>.TARGET</varname>"
msgstr "<varname> .TARGET </ varname>"

#. (itstool) path: listitem/para
#: book.translate.xml:652
#, fuzzy
msgid "The name of the target."
msgstr "O nome do alvo."

#. (itstool) path: varlistentry/term
#: book.translate.xml:657
#, fuzzy
msgid "<varname>.OODATE</varname>"
msgstr "<varname> .OODATE </ varname>"

#. (itstool) path: listitem/para
#: book.translate.xml:660
#, fuzzy
msgid ""
"The list of the sources for the target that were considered out-of-date. The "
"order in the list is not guaranteed to be the same as the order in which the "
"dependencies were given."
msgstr ""
"A lista das origens do destino que foram consideradas desatualizadas. o "
"ordem na lista não é garantida para ser o mesmo que a ordem em que o "
"dependências foram dadas."

#. (itstool) path: varlistentry/term
#: book.translate.xml:668
#, fuzzy
msgid "<varname>.ALLSRC</varname>"
msgstr "<varname> .ALLSRC </ varname>"

#. (itstool) path: listitem/para
#: book.translate.xml:671
#, fuzzy
msgid ""
"The list of all sources for this target in the order in which they were "
"given."
msgstr ""
"A lista de todas as fontes para esse destino na ordem em que elas foram dado."
""

#. (itstool) path: varlistentry/term
#: book.translate.xml:677
#, fuzzy
msgid "<varname>.PREFIX</varname>"
msgstr "<varname> .PREFIX </ varname>"

#. (itstool) path: listitem/para
#: book.translate.xml:680
#, fuzzy
msgid ""
"The target without its suffix and without any leading path. E.g. for the "
"target <filename>../../lib/compat/fsRead.c</filename>, this variable would "
"contain <literal>fsRead</literal>."
msgstr ""
"O alvo sem seu sufixo e sem nenhum caminho principal. Por exemplo. para o "
"target <nome do arquivo> ../../ lib / compat / fsRead.c </ filename>, essa "
"variável contém <literal> fsRead </ literal>."

#. (itstool) path: section/para
#: book.translate.xml:688
#, fuzzy
msgid ""
"Three other local variables are set only for certain targets under special "
"circumstances. These are the <varname>.IMPSRC,</varname> <varname>.ARCHIVE,</"
"varname> and <varname>.MEMBER</varname> variables. When they are set and how "
"they are used is described later."
msgstr ""
"Três outras variáveis locais são definidas apenas para determinados alvos "
"sob circunstâncias. Estes são os <varname> .IMPSRC, </ varname> <varname> ."
"ARCHIVE, </ variáveis varname> e <varname> .MEMBER </ varname>. Quando eles "
"estão definidos e como eles são usados é descrito mais tarde."

#. (itstool) path: section/para
#: book.translate.xml:694
#, fuzzy
msgid ""
"Four of these variables may be used in sources as well as in shell scripts. "
"These are <varname>.TARGET</varname>, <varname>.PREFIX</varname>, <varname>."
"ARCHIVE</varname> and <varname>.MEMBER</varname>. The variables in the "
"sources are expanded once for each target on the dependency line, providing "
"what is known as a <quote>dynamic source,</quote> allowing you to specify "
"several dependency lines at once. For example:"
msgstr ""
"Quatro dessas variáveis podem ser usadas em fontes, bem como em scripts de "
"shell. Estes são <varname> .TARGET </ varname>, <varname> .PREFIX </ "
"varname>, <varname>. ARCHIVE </ varname> e <varname> .MEMBER </ varname>. As "
"variáveis no fontes são expandidas uma vez para cada destino na linha de "
"dependência, fornecendo o que é conhecido como <quote> fonte dinâmica, </ "
"quote> permitindo que você especifique várias linhas de dependência de uma "
"só vez. Por exemplo:"

#. (itstool) path: section/programlisting
#: book.translate.xml:703
#, fuzzy, no-wrap
msgid "$(OBJS)         : $(.PREFIX).c"
msgstr "$ (OBJS): $ (. PREFIXO) .c"

#. (itstool) path: section/para
#: book.translate.xml:705
#, fuzzy
msgid ""
"will create a dependency between each object file and its corresponding C "
"source file."
msgstr ""
"irá criar uma dependência entre cada arquivo de objeto e seu correspondente "
"C arquivo fonte."

#. (itstool) path: section/title
#: book.translate.xml:710
#, fuzzy
msgid "Command-line Variables"
msgstr "Variáveis da linha de comando"

#. (itstool) path: section/para
#: book.translate.xml:712
#, fuzzy
msgid ""
"Command-line variables are set when <application>PMake</application> is "
"first invoked by giving a variable assignment as one of the arguments. For "
"example:"
msgstr ""
"Variáveis de linha de comando são definidas quando <application> PMake </ "
"application> é primeiro invocado dando uma atribuição de variável como um "
"dos argumentos. Para exemplo:"

#. (itstool) path: section/screen
#: book.translate.xml:717
#, fuzzy, no-wrap
msgid "pmake \"CFLAGS = -I/sprite/src/lib/libc -O\""
msgstr "pmake \\ \"CFLAGS = -I / sprite / src / lib / libc -O \\\""

#. (itstool) path: section/para
#: book.translate.xml:719
#, fuzzy
msgid ""
"would make <envar>CFLAGS</envar> be a command-line variable with the given "
"value. Any assignments to <envar>CFLAGS</envar> in the makefile will have no "
"effect, because once it is set, there is (almost) nothing you can do to "
"change a command-line variable (the search order, you see). Command-line "
"variables may be set using any of the four assignment operators, though only "
"<literal>=</literal> and <literal>?=</literal> behave as you would expect "
"them to, mostly because assignments to command-line variables are performed "
"before the makefile is read, thus the values set in the makefile are "
"unavailable at the time. <literal>+=</literal> is the same as <literal>=</"
"literal>, because the old value of the variable is sought only in the scope "
"in which the assignment is taking place (for reasons of efficiency that I "
"will not get into here). <literal>:=</literal> and <literal>?=</literal> "
"will work if the only variables used are in the environment. <literal>!=</"
"literal> is sort of pointless to use from the command line, since the same "
"effect can no doubt be accomplished using the shell's own command "
"substitution mechanisms (backquotes and all that)."
msgstr ""
"tornaria <envar> CFLAGS </ envar> uma variável de linha de comando com o "
"dado valor. Quaisquer atribuições para <envar> CFLAGS </ envar> no makefile "
"não terão efeito, porque uma vez definido, não há (quase) nada que você "
"possa fazer para alterar uma variável de linha de comando (a ordem de "
"pesquisa, você vê). Linha de comando variáveis podem ser definidas usando "
"qualquer um dos quatro operadores de atribuição, <literal> = </ literal> e "
"<literal>? = </ literal> se comportam como você esperaria -los, "
"principalmente porque as atribuições às variáveis de linha de comando são "
"realizadas antes que o makefile seja lido, assim os valores definidos no "
"makefile são indisponível no momento. <literal> + = </ literal> é o mesmo "
"que <literal> = </ literal>, porque o valor antigo da variável é procurado "
"apenas no escopo em que a atribuição está ocorrendo (por razões de "
"eficiência que eu não vai entrar aqui). <literal>: = </ literal> e "
"<literal>? = </ literal> funcionará se as únicas variáveis utilizadas "
"estiverem no ambiente. <literal>! = </ literal> é meio inútil usar a partir "
"da linha de comando, uma vez que o mesmo efeito pode sem dúvida ser "
"realizado usando o próprio comando do shell mecanismos de substituição "
"(backquotes e tudo isso)."

#. (itstool) path: section/title
#: book.translate.xml:742
#, fuzzy
msgid "Global Variables"
msgstr "Variáveis globais"

#. (itstool) path: section/para
#: book.translate.xml:744
#, fuzzy
msgid ""
"Global variables are those set or appended-to in the makefile. There are two "
"classes of global variables: those you set and those <application>PMake</"
"application> sets. As I said before, the ones you set can have any name you "
"want them to have, except they may not contain a colon or an exclamation "
"point. The variables <application>PMake</application> sets (almost) always "
"begin with a period and always contain upper-case letters, only. The "
"variables are as follows:"
msgstr ""
"Variáveis globais são aquelas definidas ou anexadas no makefile. Existem "
"dois classes de variáveis globais: aquelas que você configura e aquelas "
"<application> PMake </ aplicação> conjuntos. Como eu disse antes, os que "
"você define podem ter qualquer nome que você quer que eles tenham, exceto "
"que eles não podem conter um cólon ou uma exclamação ponto. As variáveis "
"<application> PMake </ application> configuram (quase) sempre comece com um "
"período e sempre contenha apenas letras maiúsculas. o as variáveis são as "
"seguintes:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:756
#, fuzzy
msgid "<varname>.PMAKE</varname>"
msgstr "<varname> .PMAKE </ varname>"

#. (itstool) path: listitem/para
#: book.translate.xml:759
#, fuzzy
msgid ""
"The name by which <application>PMake</application> was invoked is stored in "
"this variable. For compatibility, the name is also stored in the "
"<varname>MAKE</varname> variable."
msgstr ""
"O nome pelo qual <application> PMake </ application> foi chamado é "
"armazenado em esta variável. Para compatibilidade, o nome também é "
"armazenado no Variável <varname> MAKE </ varname>."

#. (itstool) path: varlistentry/term
#: book.translate.xml:767
#, fuzzy
msgid "<varname>.MAKEFLAGS</varname>"
msgstr "<varname> .MAKEFLAGS </ varname>"

#. (itstool) path: listitem/para
#: book.translate.xml:770
#, fuzzy
msgid ""
"All the relevant flags with which <application>PMake</application> was "
"invoked. This does not include such things as <option>-f</option> or "
"variable assignments. Again for compatibility, this value is stored in the "
"<varname>MFLAGS</varname> variable as well."
msgstr ""
"Todos os sinalizadores relevantes com os quais <application> PMake </ "
"application> foi invocado. Isso não inclui itens como <option> -f </ option> "
"ou atribuições variáveis. Novamente, para compatibilidade, esse valor é "
"armazenado no Variável <varname> MFLAGS </ varname> também."

#. (itstool) path: section/para
#: book.translate.xml:780
#, fuzzy
msgid ""
"Two other variables, <varname>.INCLUDES</varname> and <varname>.LIBS,</"
"varname> are covered in the section on special targets in <xref linkend="
"\"shortcuts\"/>."
msgstr ""
"Duas outras variáveis, <varname> .INCLUDES </ varname> e <varname> .LIBS, </ "
"varname> são abordados na seção sobre alvos especiais em <xref linkend = \\ "
"\"atalhos \\\" />."

#. (itstool) path: section/para
#: book.translate.xml:784
#, fuzzy
msgid "Global variables may be deleted using lines of the form:"
msgstr "Variáveis globais podem ser excluídas usando linhas do formulário:"

#. (itstool) path: section/programlisting
#: book.translate.xml:787
#, fuzzy, no-wrap
msgid "#undef variable"
msgstr "variável #undef"

#. (itstool) path: section/para
#: book.translate.xml:789
#, fuzzy
msgid ""
"The <literal>#</literal> must be the first character on the line. Note that "
"this may only be done on global variables."
msgstr ""
"O <literal> # </ literal> deve ser o primeiro caractere na linha. Observe "
"que isso só pode ser feito em variáveis globais."

#. (itstool) path: section/title
#: book.translate.xml:795
#, fuzzy
msgid "Environment Variables"
msgstr "variáveis ambientais"

#. (itstool) path: section/para
#: book.translate.xml:797
#, fuzzy
msgid ""
"Environment variables are passed by the shell that invoked "
"<application>PMake</application> and are given by <application>PMake</"
"application> to each shell it invokes. They are expanded like any other "
"variable, but they cannot be altered in any way."
msgstr ""
"Variáveis de ambiente são passadas pelo shell que invocou <application> "
"PMake </ application> e são fornecidos pelo <application> PMake </ "
"application> para cada shell que invoca. Eles são expandidos como qualquer "
"outro variável, mas não podem ser alterados de forma alguma."

#. (itstool) path: section/para
#: book.translate.xml:803
#, fuzzy
msgid ""
"One special environment variable, <envar>PMAKE</envar>, is examined by "
"<application>PMake</application> for command-line flags, variable "
"assignments, etc., it should always use. This variable is examined before "
"the actual arguments to <application>PMake</application> are. In addition, "
"all flags given to <application>PMake</application>, either through the "
"<envar>PMAKE</envar> variable or on the command line, are placed in this "
"environment variable and exported to each shell <application>PMake</"
"application> executes. Thus recursive invocations of <application>PMake</"
"application> automatically receive the same flags as the top-most one."
msgstr ""
"Uma variável de ambiente especial, <envar> PMAKE </ envar>, é examinada por "
"<application> PMake </ application> para sinalizadores de linha de comando, "
"variável atribuições, etc., deve sempre usar. Esta variável é examinada "
"antes os argumentos reais para <application> PMake </ application> são. Além "
"do que, além do mais, todos os sinalizadores dados a <application> PMake </ "
"application>, seja pelo <envar> PMAKE </ envar> variável ou na linha de "
"comando, são colocados neste variável de ambiente e exportado para cada "
"shell <application> PMake </ aplicativo> é executado. Assim invocações "
"recursivas de <application> PMake </ application> recebe automaticamente os "
"mesmos flags que o mais alto."

#. (itstool) path: section/para
#: book.translate.xml:815
#, fuzzy
msgid ""
"Using all these variables, you can compress the sample makefile even more:"
msgstr ""
"Usando todas essas variáveis, você pode compactar o makefile de amostra "
"ainda mais:"

#. (itstool) path: section/programlisting
#: book.translate.xml:818
#, fuzzy, no-wrap
msgid ""
"OBJS            = a.o b.o c.o\n"
"\n"
"program         : $(OBJS)\n"
"        cc $(.ALLSRC) -o $(.TARGET)\n"
"\n"
"$(OBJS)         : defs.h\n"
"\n"
"a.o             : a.c\n"
"        cc -c a.c\n"
"\n"
"b.o             : b.c\n"
"        cc -c b.c\n"
"\n"
"c.o             : c.c\n"
"        cc -c c.c"
msgstr ""
"OBJS = a.o b.o c.o \\ n \\ n programa: $ (OBJS) \\ n         cc $ (. ALLSRC) "
"-o $ (. TARGET) \\ n \\ n $ (OBJS): defs.h \\ n \\ n a.o: a.c \\ n "
"        cc -c a.c \\ n \\ n b.o: b.c \\ n         cc -c b.c \\ n \\ n c.o: c."
"c \\ n         cc -c c.c"

#. (itstool) path: section/title
#: book.translate.xml:837
#, fuzzy
msgid "Comments"
msgstr "Comentários"

#. (itstool) path: section/para
#: book.translate.xml:839
#, fuzzy
msgid ""
"Comments in a makefile start with a <literal>#</literal> character and "
"extend to the end of the line. They may appear anywhere you want them, "
"except in a shell command (though the shell will treat it as a comment, too)."
" If, for some reason, you need to use the <literal>#</literal> in a variable "
"or on a dependency line, put a backslash in front of it. <application>PMake</"
"application> will compress the two into a single <literal>#</literal>."
msgstr ""
"Comentários em um makefile começam com um caractere <literal> # </ literal> "
"e estender até o final da linha. Eles podem aparecer em qualquer lugar que "
"você quiser, exceto em um comando shell (embora o shell o trate como um "
"comentário, também). Se, por algum motivo, você precisar usar o <literal> # "
"</ literal> em um variável ou em uma linha de dependência, coloque uma barra "
"invertida na frente dela. <application> PMake </ application> compactará os "
"dois em um único <literal> # </ literal>."

#. (itstool) path: note/para
#: book.translate.xml:849
#, fuzzy
msgid ""
"This is not true if <application>PMake</application> is operating in full-"
"compatibility mode)."
msgstr ""
"Isso não é verdade se <application> PMake </ application> estiver operando "
"em full- modo de compatibilidade)."

#. (itstool) path: section/title
#: book.translate.xml:855
#, fuzzy
msgid "Parallelism"
msgstr "Paralelismo"

#. (itstool) path: section/para
#: book.translate.xml:857
#, fuzzy
msgid ""
"<application>PMake</application> was specifically designed to re-create "
"several targets at once, when possible. You do not have to do anything "
"special to cause this to happen (unless <application>PMake</application> was "
"configured to not act in parallel, in which case you will have to make use "
"of the <option>-L</option> and <option>-J</option> flags (see below)), but "
"you do have to be careful at times."
msgstr ""
"O <application> PMake </ application> foi projetado especificamente para "
"recriar vários alvos ao mesmo tempo, quando possível. Você não tem que fazer "
"nada especial para causar isso (a menos que <application> PMake </ "
"application> configurado para não agir em paralelo, caso em que você terá "
"que fazer uso das opções <option> -L </ option> e <option> -J </ option> "
"(veja abaixo)), mas você tem que ter cuidado às vezes."

#. (itstool) path: section/para
#: book.translate.xml:865
#, fuzzy
msgid ""
"There are several problems you are likely to encounter. One is that some "
"makefiles (and programs) are written in such a way that it is impossible for "
"two targets to be made at once. The program <application>xstr</application>, "
"for example, always modifies the files <filename>strings</filename> and "
"<filename>x.c</filename>. There is no way to change it. Thus you cannot run "
"two of them at once without something being trashed. Similarly, if you have "
"commands in the makefile that always send output to the same file, you will "
"not be able to make more than one target at once unless you change the file "
"you use. You can, for instance, add a <literal>$$$$</literal> to the end of "
"the file name to tack on the process ID of the shell executing the command "
"(each <literal>$$</literal> expands to a single <literal>$</literal>, thus "
"giving you the shell variable <literal>$$</literal>). Since only one shell "
"is used for all the commands, you will get the same file name for each "
"command in the script."
msgstr ""
"Existem vários problemas que você provavelmente encontrará. Uma é que alguns "
"makefiles (e programas) são escritos de tal maneira que é impossível para "
"dois alvos a serem feitos de uma só vez. O programa <application> xstr </ "
"application>, por exemplo, sempre modifica os arquivos <filename> strings </ "
"filename> e <nome do arquivo> x.c </ filename>. Não há como mudar isso. "
"Assim você não pode correr dois deles de uma vez sem algo sendo destruído. "
"Da mesma forma, se você tem comandos no makefile que sempre enviam saída "
"para o mesmo arquivo, você Não será possível criar mais de um destino de uma "
"só vez, a menos que você altere o arquivo você usa. Você pode, por exemplo, "
"adicionar um <literal> $$$$ </ literal> ao final de o nome do arquivo para "
"identificar o ID do processo do shell que está executando o comando (cada "
"<literal> $$ </ literal> expande para um único <literal> $ </ literal>, "
"dando-lhe a variável de shell <literal> $$ </ literal>). Desde apenas uma "
"concha é usado para todos os comandos, você obterá o mesmo nome de arquivo "
"para cada comando no script."

#. (itstool) path: section/para
#: book.translate.xml:883
#, fuzzy
msgid ""
"The other problem comes from improperly-specified dependencies that worked "
"in <application>Make</application> because of its sequential, depth-first "
"way of examining them. While I do not want to go into depth on how "
"<application>PMake</application> works (look in <xref linkend=\"gods\"/> if "
"you are interested), I will warn you that files in two different levels of "
"the dependency tree may be examined in a different order in "
"<application>PMake</application> than they were in <application>Make</"
"application>. For example, given the makefile:"
msgstr ""
"O outro problema vem de dependências especificadas incorretamente que "
"funcionaram em <application> Make </ application> devido à sua profundidade "
"seqüencial maneira de examiná-los. Enquanto eu não quero entrar em "
"profundidade sobre como <application> PMake </ application> funciona (veja "
"em <xref linkend = \\ \"gods \\\" /> se você está interessado), vou avisá-lo "
"que arquivos em dois níveis diferentes de a árvore de dependência pode ser "
"examinada em uma ordem diferente <application> PMake </ application> do que "
"estavam em <application> Make </ aplicação>. Por exemplo, dado o makefile:"

#. (itstool) path: section/programlisting
#: book.translate.xml:894
#, fuzzy, no-wrap
msgid "a               :\n"
"\n"
"b c b           : d"
msgstr "a \\ n b c b: d"

#. (itstool) path: para/buildtarget
#: book.translate.xml:899 book.translate.xml:903 book.translate.xml:905
#: book.translate.xml:908 book.translate.xml:1101
#, fuzzy
msgid "c"
msgstr "c"

#. (itstool) path: para/buildtarget
#: book.translate.xml:900 book.translate.xml:1103
#, fuzzy
msgid "d"
msgstr "d"

#. (itstool) path: para/buildtarget
#: book.translate.xml:900 book.translate.xml:904 book.translate.xml:909
#: book.translate.xml:1105
#, fuzzy
msgid "b"
msgstr "b"

#. (itstool) path: para/buildtarget
#: book.translate.xml:901 book.translate.xml:1103
#, fuzzy
msgid "a"
msgstr "uma"

#. (itstool) path: section/para
#: book.translate.xml:898
#, fuzzy
msgid ""
"<application>PMake</application> will examine the targets in the order <_:"
"buildtarget-1/>, <_:buildtarget-2/>, <_:buildtarget-3/>, <_:buildtarget-4/>. "
"If the makefile's author expected <application>PMake</application> to abort "
"before making <_:buildtarget-5/> if an error occurred while making <_:"
"buildtarget-6/>, or if <_:buildtarget-7/> needed to exist before <_:"
"buildtarget-8/> was made, (s)he will be sorely disappointed. The "
"dependencies are incomplete, since in both these cases, <_:buildtarget-9/> "
"would depend on <_:buildtarget-10/>. So watch out."
msgstr ""
"O <application> PMake </ application> examinará os destinos na ordem <_: "
"buildtarget-1 />, <_: buildtarget-2 />, <_: buildtarget-3 />, <_: "
"buildtarget-4 />. Se o autor do makefile esperar que o <application> PMake </"
" application> aborte antes de fazer <_: buildtarget-5 /> se um erro ocorreu "
"ao fazer <_: buildtarget-6 />, ou se <_: buildtarget-7 /> precisou existir "
"antes de <_: buildtarget-8 /> foi feito, ele será muito desapontado. o "
"dependências são incompletas, pois em ambos os casos, <_: buildtarget-9 /> "
"dependeria de <_: buildtarget-10 />. Então cuidado."

#. (itstool) path: section/para
#: book.translate.xml:911
#, fuzzy
msgid ""
"Another problem you may face is that, while <application>PMake</application> "
"is set up to handle the output from multiple jobs in a graceful fashion, the "
"same is not so for input. It has no way to regulate input to different jobs, "
"so if you use the redirection from <filename>/dev/tty</filename> I mentioned "
"earlier, you must be careful not to run two of the jobs at once."
msgstr ""
"Outro problema que você pode enfrentar é que, enquanto <application> PMake </"
" application> está configurado para manipular a saída de várias tarefas de "
"maneira elegante, mesmo não é assim para entrada. Não tem como regular a "
"entrada para trabalhos diferentes, então se você usar o redirecionamento de "
"<filename> / dev / tty </ filename> eu mencionei anteriormente, você deve "
"ter cuidado para não executar dois dos jobs de uma só vez."

#. (itstool) path: section/title
#: book.translate.xml:921
#, fuzzy
msgid "Writing and Debugging a Makefile"
msgstr "Escrevendo e depurando um Makefile"

#. (itstool) path: section/para
#: book.translate.xml:923
#, fuzzy
msgid ""
"Now you know most of what is in a <filename>Makefile</filename>, what do you "
"do next? There are two choices: use one of the uncommonly-available makefile "
"generators or write your own makefile (I leave out the third choice of "
"ignoring <application>PMake</application> and doing everything by hand as "
"being beyond the bounds of common sense)."
msgstr ""
"Agora você sabe mais do que está em um <filename> Makefile </ filename>, o "
"que você fazer o próximo? Existem duas opções: usar um dos makefiles "
"invulgarmente disponíveis geradores ou escrever o seu próprio makefile (eu "
"deixo de fora a terceira escolha de ignorando <application> PMake </ "
"application> e fazendo tudo manualmente estar além dos limites do senso "
"comum)."

#. (itstool) path: section/para
#: book.translate.xml:931
#, fuzzy
msgid ""
"When faced with the writing of a makefile, it is usually best to start from "
"first principles: just what are you trying to do? What do you want the "
"makefile finally to produce? To begin with a somewhat traditional example, "
"let's say you need to write a makefile to create a program, <command>expr</"
"command>, that takes standard infix expressions and converts them to prefix "
"form (for no readily apparent reason). You have got three source files, in "
"C, that make up the program: <filename>main.c</filename>, <filename>parse.c</"
"filename>, and <filename>output.c</filename>. Harking back to my pithy "
"advice about dependency lines, you write the first line of the file:"
msgstr ""
"Quando confrontado com a escrita de um makefile, geralmente é melhor começar "
"primeiros princípios: o que você está tentando fazer? O que você quer do "
"makefile finalmente para produzir? Para começar com um exemplo um tanto "
"tradicional, digamos que você precise escrever um makefile para criar um "
"programa, <command> expr </ comando>, que usa expressões infix padrão e as "
"converte em prefixo forma (por nenhuma razão aparente). Você tem três "
"arquivos de origem, em C, que compõem o programa: <filename> main.c </ "
"filename>, <filename> parse.c </ filename> e <filename> output.c </ "
"filename>. Voltando ao meu pithy conselhos sobre linhas de dependência, você "
"escreve a primeira linha do arquivo:"

#. (itstool) path: section/programlisting
#: book.translate.xml:944
#, fuzzy, no-wrap
msgid "expr            : main.o parse.o output.o"
msgstr "expr: main.o parse.o output.o"

#. (itstool) path: section/para
#: book.translate.xml:946
#, fuzzy
msgid ""
"because you remember <filename>expr</filename> is made from <filename>.o</"
"filename> files, not <filename>.c</filename> files. Similarly for the "
"<filename>.o</filename> files you produce the lines:"
msgstr ""
"porque você se lembra <filename> expr </ filename> é feito de <filename> .o "
"</ filename> arquivos, não arquivos <filename> .c </ filename>. Da mesma "
"forma para o Arquivos <filename> .o </ filename> você produz as linhas:"

#. (itstool) path: section/programlisting
#: book.translate.xml:951
#, fuzzy, no-wrap
msgid ""
"main.o          : main.c\n"
"\n"
"parse.o         : parse.c\n"
"\n"
"output.o        : output.c\n"
"\n"
"main.o parse.o output.o : defs.h"
msgstr ""
"main.o: main.c \\ n \\ n parse.o: parse.c \\ n \\ n output.o: output.c \\ n "
"\\ n main.o parse.o output.o: defs.h"

#. (itstool) path: section/para
#: book.translate.xml:959
#, fuzzy
msgid ""
"Great. You have now got the dependencies specified. What you need now is "
"commands. These commands, remember, must produce the target on the "
"dependency line, usually by using the sources you have listed. You remember "
"about local variables? Good, so it should come to you as no surprise when "
"you write:"
msgstr ""
"Ótimo. Você agora tem as dependências especificadas. O que você precisa "
"agora é comandos. Esses comandos, lembre-se, devem produzir o alvo no linha "
"de dependência, geralmente usando as fontes que você listou. Você lembra "
"sobre variáveis locais? Bom, então deveria vir a você como nenhuma surpresa "
"quando você escreve:"

#. (itstool) path: section/programlisting
#: book.translate.xml:966
#, fuzzy, no-wrap
msgid "expr            : main.o parse.o output.o\n"
"\tcc -o $(.TARGET) $(.ALLSRC)"
msgstr "expr: main.o parse.o output.o \\ n \\ tcc -o $ (. TARGET) $ (. ALLSRC)"

#. (itstool) path: section/para
#: book.translate.xml:969
#, fuzzy
msgid ""
"Why use the variables? If your program grows to produce postfix expressions "
"too (which, of course, requires a name change or two), it is one fewer place "
"you have to change the file. You cannot do this for the object files, "
"however, because they depend on their corresponding source files and "
"<filename>defs.h</filename>, thus if you said:"
msgstr ""
"Por que usar as variáveis? Se o seu programa crescer para produzir "
"expressões postfix também (o que, é claro, requer uma mudança de nome ou "
"duas), é um lugar a menos você tem que mudar o arquivo. Você não pode fazer "
"isso para os arquivos de objeto, no entanto, porque eles dependem de seus "
"arquivos de origem correspondentes e <filename> defs.h </ filename>, "
"portanto, se você disse:"

#. (itstool) path: section/programlisting
#: book.translate.xml:976
#, fuzzy, no-wrap
msgid "cc -c $(.ALLSRC)"
msgstr "cc -c $ (. ALLSRC)"

#. (itstool) path: section/para
#: book.translate.xml:978
#, fuzzy
msgid "you will get (for <filename>main.o</filename>):"
msgstr "você irá obter (para <filename> main.o </ filename>):"

#. (itstool) path: section/programlisting
#: book.translate.xml:980
#, fuzzy, no-wrap
msgid "cc -c main.c defs.h"
msgstr "cc -c main.c defs.h"

#. (itstool) path: section/para
#: book.translate.xml:982
#, fuzzy
msgid "which is wrong. So you round out the makefile with these lines:"
msgstr "o que está errado. Então você completa o makefile com estas linhas:"

#. (itstool) path: section/programlisting
#: book.translate.xml:985
#, fuzzy, no-wrap
msgid ""
"main.o          : main.c\n"
"\tcc -c main.c\n"
"\n"
"parse.o         : parse.c\n"
"\tcc -c parse.c\n"
"\n"
"output.o        : output.c\n"
"\tcc -c output.c"
msgstr ""
"main.o: main.c \\ n \\ tcc -c main.c \\ n \\ n parse.o: parse.c \\ n \\ tcc -"
"c parse.c \\ n \\ n output.o: output.c \\ n \\ tcc -c output.c"

#. (itstool) path: section/para
#: book.translate.xml:994
#, fuzzy
msgid ""
"The makefile is now complete and will, in fact, create the program you want "
"it to without unnecessary compilations or excessive typing on your part. "
"There are two things wrong with it, however (aside from it being altogether "
"too long, something I will address in <xref linkend=\"shortcuts\"/>):"
msgstr ""
"O makefile agora está completo e, de fato, criará o programa que você deseja "
"sem compilações desnecessárias ou digitação excessiva de sua parte. Há duas "
"coisas erradas nisso, no entanto (além de ser completamente muito tempo, "
"algo que abordarei em <xref linkend = \\ \"atalhos \\\" />):"

#. (itstool) path: listitem/para
#: book.translate.xml:1002
#, fuzzy
msgid ""
"The string <literal>main.o parse.o output.o</literal> is repeated twice, "
"necessitating two changes when you add postfix (you were planning on that, "
"were not you?). This is in direct violation of de Boor's First Rule of "
"writing makefiles:"
msgstr ""
"A string <literal> main.o parse.o output.o </ literal> é repetida duas "
"vezes, necessitando de duas mudanças quando você adiciona o postfix (você "
"estava planejando isso, não era você?). Isto está em violação direta da "
"Primeira Regra de Boor de escrevendo makefiles:"

#. (itstool) path: listitem/para
#: book.translate.xml:1008
#, fuzzy
msgid ""
"Anything that needs to be written more than once should be placed in a "
"variable. I cannot emphasize this enough as being very important to the "
"maintenance of a makefile and its program."
msgstr ""
"Qualquer coisa que precise ser escrita mais de uma vez deve ser colocada em "
"um variável. Eu não posso enfatizar isso o suficiente como sendo muito "
"importante para o manutenção de um makefile e seu programa."

#. (itstool) path: listitem/para
#: book.translate.xml:1015
#, fuzzy
msgid ""
"There is no way to alter the way compilations are performed short of editing "
"the makefile and making the change in all places. This is evil and violates "
"de Boor's Second Rule, which follows directly from the first:"
msgstr ""
"Não há como alterar o modo como as compilações são executadas antes da "
"edição o makefile e fazendo a mudança em todos os lugares. Isso é mal e "
"viola Segunda Regra de Boor, que segue diretamente da primeira:"

#. (itstool) path: listitem/para
#: book.translate.xml:1020
#, fuzzy
msgid ""
"Any flags or programs used inside a makefile should be placed in a variable "
"so they may be changed, temporarily or permanently, with the greatest ease."
msgstr ""
"Qualquer sinalizadores ou programas usados dentro de um makefile devem ser "
"colocados em uma variável então eles podem ser mudados, temporariamente ou "
"permanentemente, com a maior facilidade."

#. (itstool) path: section/para
#: book.translate.xml:1026
#, fuzzy
msgid "The makefile should more properly read:"
msgstr "O makefile deve ler mais corretamente:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1028
#, fuzzy, no-wrap
msgid ""
"OBJS            = main.o parse.o output.o\n"
"\n"
"expr            : $(OBJS)\n"
"\t$(CC) $(CFLAGS) -o $(.TARGET) $(.ALLSRC)\n"
"\n"
"main.o          : main.c\n"
"\t$(CC) $(CFLAGS) -c main.c\n"
"\n"
"parse.o         : parse.c\n"
"\t$(CC) $(CFLAGS) -c parse.c\n"
"\n"
"output.o        : output.c\n"
"\t$(CC) $(CFLAGS) -c output.c\n"
"\n"
"$(OBJS)         : defs.h"
msgstr ""
"OBJS = main.o parse.o output.o \\ n \\ n expr: $ (OBJS) \\ n \\ t $ (CC) $ "
"(CFLAGS) -o $ (.DARG) $ (. ALLSRC) \\ n \\ n main.o: main.c \\ n \\ t $ (CC) "
"$ (CFLAGS) -c main.c \\ n \\ n parse.o: parse.c \\ n \\ t $ (CC) $ (CFLAGS) -"
"c parse.c \\ n \\ n output.o: output.c \\ n \\ t $ (CC) $ (CFLAGS) -c output."
"c \\ n \\ n $ (OBJS): defs.h"

#. (itstool) path: section/para
#: book.translate.xml:1044
#, fuzzy
msgid ""
"Alternatively, if you like the idea of dynamic sources mentioned in <xref "
"linkend=\"localvariables\"/>, you could write it like this:"
msgstr ""
"Alternativamente, se você gosta da ideia de fontes dinâmicas mencionadas em "
"<xref linkend = \\ \"localvariables \\\" />, você poderia escrevê-lo assim:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1048
#, fuzzy, no-wrap
msgid ""
"OBJS            = main.o parse.o output.o\n"
"\n"
"expr            : $(OBJS)\n"
"\t$(CC) $(CFLAGS) -o $(.TARGET) $(.ALLSRC)\n"
"\n"
"$(OBJS)         : $(.PREFIX).c defs.h\n"
"\t$(CC) $(CFLAGS) -c $(.PREFIX).c"
msgstr ""
"OBJS = main.o parse.o output.o \\ n \\ n expr: $ (OBJS) \\ n \\ t $ (CC) $ "
"(CFLAGS) -o $ (.DARG) $ (. ALLSRC) \\ n \\ n $ (OBJS): $ (. PREFIXO) .c defs."
"h \\ n \\ t $ (CC) $ (CFLAGS) -c $ (. PREFIX) .c"

#. (itstool) path: section/para
#: book.translate.xml:1056
#, fuzzy
msgid ""
"These two rules and examples lead to de Boor's First Corollary: "
"<emphasis>Variables are your friends</emphasis>."
msgstr ""
"Essas duas regras e exemplos levam ao primeiro Corolário de Boor: <emphasis> "
"As variáveis são seus amigos </ emphasis>."

#. (itstool) path: section/para
#: book.translate.xml:1060
#, fuzzy
msgid ""
"Once you have written the makefile comes the sometimes-difficult task of "
"making sure the darn thing works. Your most helpful tool to make sure the "
"makefile is at least syntactically correct is the <option>-n</option> flag, "
"which allows you to see if <application>PMake</application> will choke on "
"the makefile. The second thing the <option>-n</option> flag lets you do is "
"see what <application>PMake</application> would do without it actually doing "
"it, thus you can make sure the right commands would be executed were you to "
"give <application>PMake</application> its head."
msgstr ""
"Depois de ter escrito o makefile vem a tarefa às vezes difícil de "
"certificando-se que a maldita coisa funciona. Sua ferramenta mais útil para "
"garantir que makefile é pelo menos sintaticamente correto é o sinalizador "
"<option> -n </ option>, o que permite que você veja se o <application> PMake "
"</ application> será bloqueado o makefile. A segunda coisa que o sinalizador "
"<option> -n </ option> permite fazer é ver o que o <application> PMake </ "
"application> faria sem realmente fazer isso, assim você pode ter certeza que "
"os comandos certos seriam executados se você dê <application> PMake </ "
"application> sua cabeça."

#. (itstool) path: section/para
#: book.translate.xml:1071
#, fuzzy
msgid ""
"When you find your makefile is not behaving as you hoped, the first question "
"that comes to mind (after <quote>What time is it, anyway?</quote>) is "
"<quote>Why not?</quote> In answering this, two flags will serve you well: "
"<literal>-d m</literal> and <quote>-p 2</quote>. The first causes "
"<application>PMake</application> to tell you as it examines each target in "
"the makefile and indicate why it is deciding whatever it is deciding. You "
"can then use the information printed for other targets to see where you went "
"wrong. The <quote>-p 2</quote> flag makes <application>PMake</application> "
"print out its internal state when it is done, allowing you to see that you "
"forgot to make that one chapter depend on that file of macros you just got a "
"new version of. The output from <quote>-p 2</quote> is intended to resemble "
"closely a real makefile, but with additional information provided and with "
"variables expanded in those commands <application>PMake</application> "
"actually printed or executed."
msgstr ""
"Quando você encontrar o seu makefile não está se comportando como você "
"esperava, a primeira pergunta que vem à mente (após <quote> Que horas são, "
"afinal? </ quote>) é <quote> Por que não? </ quote> Ao responder isso, duas "
"bandeiras servirão bem para você: <literal> -d m </ literal> e <quote> -p 2 "
"</ quote>. As primeiras causas <application> PMake </ application> para "
"informá-lo enquanto examina cada destino em o makefile e indique porque está "
"decidindo o que quer que esteja decidindo. Você pode então usar as "
"informações impressas para outros alvos para ver onde você foi errado. O "
"sinalizador <quote> -p 2 </ quote> torna <application> PMake </ application> "
"imprimir o seu estado interno quando isso é feito, permitindo que você veja "
"que você esqueci de fazer esse capítulo depender desse arquivo de macros que "
"você acabou de obter nova versão do. A saída de <quote> -p 2 </ quote> "
"destina-se a se assemelhar de perto um makefile real, mas com informações "
"adicionais fornecidas e com variáveis expandidas nesses comandos "
"<application> PMake </ application> realmente impresso ou executado."

#. (itstool) path: section/para
#: book.translate.xml:1090
#, fuzzy
msgid ""
"Something to be especially careful about is circular dependencies. For "
"example:"
msgstr ""
"Algo para ser especialmente cuidadoso é com dependências circulares. Para "
"exemplo:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1093
#, fuzzy, no-wrap
msgid "a         : b\n"
"\n"
"b         : c d\n"
"\n"
"d         : a"
msgstr "a: b \\ n \\ n b: c d \\ n \\ n d: a"

#. (itstool) path: section/para
#: book.translate.xml:1099
#, fuzzy
msgid ""
"In this case, because of how <application>PMake</application> works, <_:"
"buildtarget-1/> is the only thing <application>PMake</application> will "
"examine, because <_:buildtarget-2/> and <_:buildtarget-3/> will effectively "
"fall off the edge of the universe, making it impossible to examine <_:"
"buildtarget-4/> (or them, for that matter). <application>PMake</application> "
"will tell you (if run in its normal mode) all the targets involved in any "
"cycle it looked at (i.e. if you have two cycles in the graph (naughty, "
"naughty), but only try to make a target in one of them, <application>PMake</"
"application> will only tell you about that one. You will have to try to make "
"the other to find the second cycle). When run as <application>Make</"
"application>, it will only print the first target in the cycle."
msgstr ""
"Nesse caso, devido ao funcionamento do <application> PMake </ application>, "
"<_: buildtarget-1 /> é a única coisa que o <application> PMake </ "
"application> examine, porque <_: buildtarget-2 /> e <_: buildtarget-3 /> "
"será efetivamente cair fora da borda do universo, tornando impossível "
"examinar <_: buildtarget-4 /> (ou eles, para esse assunto). <application> "
"PMake </ application> irá dizer-lhe (se executado em seu modo normal) todos "
"os alvos envolvidos em qualquer ciclo que olhou (ou seja, se você tem dois "
"ciclos no gráfico (impertinente, impertinente), mas apenas tente fazer um "
"alvo em um deles, <application> PMake </ application> só lhe dirá sobre isso."
" Você terá que tentar fazer o outro para encontrar o segundo ciclo). Quando "
"executado como <application> Make </ aplicação>, imprimirá apenas o primeiro "
"destino no ciclo."

#. (itstool) path: section/title
#: book.translate.xml:1117
#, fuzzy
msgid "Invoking PMake"
msgstr "Invocando PMake"

#. (itstool) path: section/para
#: book.translate.xml:1119
#, fuzzy
msgid ""
"<application>PMake</application> comes with a wide variety of flags to "
"choose from. They may appear in any order, interspersed with command-line "
"variable assignments and targets to create. The flags are as follows:"
msgstr ""
"<application> PMake </ application> vem com uma grande variedade de "
"sinalizadores para escolha de. Eles podem aparecer em qualquer ordem, "
"intercalados com linha de comando atribuições de variáveis e destinos para "
"criar. As bandeiras são as seguintes:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:1126
#, fuzzy
msgid "<option>-d <replaceable>what</replaceable></option>"
msgstr "<option> -d <replaceable> o que </ replaceable> </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1129
#, fuzzy
msgid ""
"This causes <application>PMake</application> to spew out debugging "
"information that may prove useful to you. If you cannot figure out why "
"<application>PMake</application> is doing what it is doing, you might try "
"using this flag. The <replaceable>what</replaceable> parameter is a string "
"of single characters that tell <application>PMake</application> what aspects "
"you are interested in. Most of what I describe will make little sense to "
"you, unless you have dealt with <application>Make</application> before. Just "
"remember where this table is and come back to it as you read on. The "
"characters and the information they produce are as follows:"
msgstr ""
"Isso faz com que o <application> PMake </ application> elimine a depuração "
"informações que podem ser úteis para você. Se você não consegue descobrir "
"porque <application> PMake </ application> está fazendo o que está fazendo, "
"você pode tentar usando este sinalizador. O parâmetro <replaceable> what </ "
"replaceable> é uma string de caracteres únicos que informam <application> "
"PMake </ application> que aspectos você está interessado. A maior parte do "
"que eu descrevo fará pouco sentido para você, a menos que tenha lidado com "
"<application> Make </ application> antes. Somente lembre-se de onde esta "
"tabela está e volte para ela enquanto você lê. o caracteres e as informações "
"que eles produzem são os seguintes:"

#. (itstool) path: row/entry
#: book.translate.xml:1148
#, fuzzy
msgid "<literal>a</literal>"
msgstr "<literal> a </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1150
#, fuzzy
msgid "Archive searching and caching."
msgstr "Arquivar pesquisa e armazenamento em cache."

#. (itstool) path: row/entry
#: book.translate.xml:1154
#, fuzzy
msgid "<literal>c</literal>"
msgstr "<literal> c </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1156
#, fuzzy
msgid "Conditional evaluation."
msgstr "Avaliação condicional."

#. (itstool) path: row/entry
#: book.translate.xml:1160
#, fuzzy
msgid "<literal>d</literal>"
msgstr "<literal> d </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1162
#, fuzzy
msgid "The searching and caching of directories."
msgstr "A pesquisa e o armazenamento em cache de diretórios."

#. (itstool) path: row/entry
#: book.translate.xml:1167
#, fuzzy
msgid "<literal>j</literal>"
msgstr "<literal> j </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1169
#, fuzzy
msgid ""
"Various snippets of information related to the running of the multiple "
"shells. Not particularly interesting."
msgstr ""
"Vários trechos de informações relacionadas à execução dos múltiplos "
"cartuchos. Não é particularmente interessante."

#. (itstool) path: row/entry
#: book.translate.xml:1175
#, fuzzy
msgid "<literal>m</literal>"
msgstr "<literal> m </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1177
#, fuzzy
msgid ""
"The making of each target: what target is being examined; when it was last "
"modified; whether it is out-of-date; etc."
msgstr ""
"A realização de cada alvo: qual alvo está sendo examinado; quando foi o "
"último modificado; se está desatualizado; etc."

#. (itstool) path: row/entry
#: book.translate.xml:1183
#, fuzzy
msgid "<literal>p</literal>"
msgstr "<literal> p </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1185
#, fuzzy
msgid "Makefile parsing."
msgstr "Makefile parsing."

#. (itstool) path: row/entry
#: book.translate.xml:1189
#, fuzzy
msgid "<literal>r</literal>"
msgstr "<literal> r </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1191
#, fuzzy
msgid "Remote execution."
msgstr "Execução remota."

#. (itstool) path: row/entry
#: book.translate.xml:1195
#, fuzzy
msgid "<literal>s</literal>"
msgstr "<literal> s </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1197
#, fuzzy
msgid ""
"The application of suffix-transformation rules. (See <xref linkend="
"\"shortcuts\"/>.)"
msgstr ""
"A aplicação de regras de transformação de sufixo. (Veja <xref linkend = \\ "
"\"atalhos \\\" />."

#. (itstool) path: row/entry
#: book.translate.xml:1202
#, fuzzy
msgid "<literal>t</literal>"
msgstr "<literal> t </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1204
#, fuzzy
msgid "The maintenance of the list of targets."
msgstr "A manutenção da lista de alvos."

#. (itstool) path: row/entry
#: book.translate.xml:1208
#, fuzzy
msgid "<literal>v</literal>"
msgstr "<Literal> em </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:1210
#, fuzzy
msgid "Variable assignment."
msgstr "Atribuição variável."

#. (itstool) path: listitem/para
#: book.translate.xml:1216
#, fuzzy
msgid ""
"Of these all, the <literal>m</literal> and <literal>s</literal> letters will "
"be most useful to you. If the <option>-d</option> is the final argument or "
"the argument from which it would get these key letters (see below for a note "
"about which argument would be used) begins with a –, all of these debugging "
"flags will be set, resulting in massive amounts of output."
msgstr ""
"Destes, as letras <literal> m </ literal> e <literal> s </ literal> serão "
"ser mais útil para você. Se a <option> -d </ option> for o argumento final "
"ou o argumento do qual obteria essas letras-chave (veja abaixo uma nota "
"sobre qual argumento seria usado) começa com a -, todas essas depurações "
"flags serão definidas, resultando em grandes quantidades de saída."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1227
#, fuzzy
msgid "<option>-f</option> makefile"
msgstr "<option> -f </ option> makefile"

#. (itstool) path: listitem/para
#: book.translate.xml:1230
#, fuzzy
msgid ""
"Specify a makefile to read different from the standard makefiles "
"(<filename>Makefile</filename> or <filename>makefile</filename>). If "
"makefile is <literal>-</literal>, <application>PMake</application> uses the "
"standard input. This is useful for making quick and dirty makefiles."
msgstr ""
"Especifique um makefile para ler diferente dos makefiles padrão (<filename> "
"Makefile </ filename> ou <filename> makefile </ filename>). E se makefile é "
"<literal> - </ literal>, <application> PMake </ application> usa o entrada "
"padrão. Isso é útil para fazer makefiles rápidos e sujos."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1240
#, fuzzy
msgid "<option>-h</option>"
msgstr "<option> -h </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1243
#, fuzzy
msgid ""
"Prints out a summary of the various flags <application>PMake</application> "
"accepts. It can also be used to find out what level of concurrency was "
"compiled into the version of <application>PMake</application> you are using "
"(look at <literal>-J</literal> and <literal>-L</literal>) and various other "
"information on how <application>PMake</application> was configured."
msgstr ""
"Imprime um resumo dos vários sinalizadores <application> PMake </ "
"application> aceita. Também pode ser usado para descobrir qual nível de "
"simultaneidade foi compilado na versão do <application> PMake </ "
"application> que você está usando (olhe para <literal> -J </ literal> e "
"<literal> -L </ literal>) e vários outros informações sobre como o "
"<application> PMake </ application> foi configurado."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1254
#, fuzzy
msgid "<option>-i</option>"
msgstr "<option> -i </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1257
#, fuzzy
msgid ""
"If you give this flag, <application>PMake</application> will ignore non-zero "
"status returned by any of its shells. It is like placing a <literal>-</"
"literal> before all the commands in the makefile."
msgstr ""
"Se você der este sinalizador, <application> PMake </ application> ignorará "
"não-zero status retornado por qualquer um de seus shells. É como colocar um "
"<literal> - </ literal> antes de todos os comandos no makefile."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1265
#, fuzzy
msgid "<option>-k</option>"
msgstr "<option> -k </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1268
#, fuzzy
msgid ""
"This is similar to <option>-i</option> in that it allows <application>PMake</"
"application> to continue when it sees an error, but unlike <option>-i</"
"option>, where <application>PMake</application> continues blithely as if "
"nothing went wrong, <option>-k</option> causes it to recognize the error and "
"only continue work on those things that do not depend on the target, either "
"directly or indirectly (through depending on something that depends on it), "
"whose creation returned the error. The <option>k</option> is for <quote>keep "
"going</quote>."
msgstr ""
"Isso é semelhante a <option> -i </ option> porque permite <application> "
"PMake </ application> para continuar quando vir um erro, mas ao contrário de "
"<option> -i </ opção>, em que <application> PMake </ application> continua "
"como se estivesse nada deu errado, <option> -k </ option> faz com que ele "
"reconheça o erro e só continue trabalhando nas coisas que não dependem do "
"alvo, seja direta ou indiretamente (dependendo de algo que depende disso), "
"cuja criação retornou o erro. A <option> k </ option> é para <quote> keep "
"indo </ quote>."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1281
#, fuzzy
msgid "<option>-l</option>"
msgstr "<option> -l </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1284
#, fuzzy
msgid ""
"<application>PMake</application> has the ability to lock a directory against "
"other people executing it in the same directory (by means of a file called "
"<filename>LOCK.make</filename> that it creates and checks for in the "
"directory). This is a Good Thing because two people doing the same thing in "
"the same place can be disastrous for the final product (too many cooks and "
"all that). Whether this locking is the default is up to your system "
"administrator. If locking is on, <option>-l</option> will turn it off, and "
"vice versa. Note that this locking will not prevent you from invoking "
"<application>PMake</application> twice in the same place–if you own the lock "
"file, <application>PMake</application> will warn you about it but continue "
"to execute."
msgstr ""
"<application> PMake </ application> tem a capacidade de bloquear um "
"diretório contra outras pessoas executando-o no mesmo diretório (por meio de "
"um arquivo chamado <filename> LOCK.make </ filename> que cria e verifica no "
"diretório). Isso é uma coisa boa porque duas pessoas fazendo a mesma coisa o "
"mesmo local pode ser desastroso para o produto final (muitos cozinheiros e "
"tudo isso). Se esse bloqueio é o padrão, depende do seu sistema "
"administrador. Se o bloqueio estiver ativado, <option> -l </ option> será "
"desativado e vice-versa. Note que este bloqueio não impedirá que você "
"invoque <application> PMake </ application> duas vezes no mesmo lugar - se "
"você possui o bloqueio arquivo, <application> PMake </ application> irá "
"avisá-lo sobre isso, mas continuar executar."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1301
#, fuzzy
msgid "<option>-m <replaceable>directory</replaceable></option>"
msgstr "<option> -m <replaceable> directory </ replaceable> </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1304
#, fuzzy
msgid ""
"Tells <application>PMake</application> another place to search for included "
"makefiles via the &lt;<replaceable>filename</replaceable>&gt; style. Several "
"<filename>-m</filename> options can be given to form a search path. If this "
"construct is used the default system makefile search path is completely "
"overridden."
msgstr ""
"Diz ao <application> PMake </ application> outro local para pesquisar "
"incluído makefiles através do & lt; <replaceable> nome de ficheiro </ "
"replaceable> & gt; estilo. De várias Opções <filename> -m </ filename> podem "
"ser fornecidas para formar um caminho de pesquisa. Se este construir é usado "
"o caminho de pesquisa do sistema makefile padrão é completamente sobrescrito."
""

#. (itstool) path: varlistentry/term
#: book.translate.xml:1314
#, fuzzy
msgid "<option>-n</option>"
msgstr "<option> -n </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1317
#, fuzzy
msgid ""
"This flag tells <application>PMake</application> not to execute the commands "
"needed to update the out-of-date targets in the makefile. Rather, "
"<application>PMake</application> will simply print the commands it would "
"have executed and exit. This is particularly useful for checking the "
"correctness of a makefile. If <application>PMake</application> does not do "
"what you expect it to, it is a good chance the makefile is wrong."
msgstr ""
"Esse sinalizador diz ao <application> PMake </ application> para não "
"executar os comandos necessário atualizar as metas desatualizadas no "
"makefile. Em vez, <application> PMake </ application> simplesmente imprimirá "
"os comandos que ele ter executado e sair. Isso é particularmente útil para "
"verificar correção de um makefile. Se <application> PMake </ application> "
"não fizer o que você espera, é uma boa chance que o makefile esteja errado."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1328
#, fuzzy
msgid "<option>-p number</option>"
msgstr "<option> -p number </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1331
#, fuzzy
msgid ""
"This causes <application>PMake</application> to print its input in a "
"reasonable form, though not necessarily one that would make immediate sense "
"to anyone but me. The number is a bitwise OR of 1 and 2, where 1 means it "
"should print the input before doing any processing and 2 says it should "
"print it after everything has been re-created. Thus <option>-p 3</option> "
"would print it twice-a-once before processing and once after (you might find "
"the difference between the two interesting). This is mostly useful to me, "
"but you may find it informative in some bizarre circumstances."
msgstr ""
"Isso faz com que <application> PMake </ application> imprima sua entrada em "
"um forma razoável, embora não necessariamente um que faria sentido imediato "
"para ninguém além de mim. O número é um bit a bit OR de 1 e 2, em que 1 "
"significa deve imprimir a entrada antes de fazer qualquer processamento e 2 "
"diz que deve imprimi-lo depois que tudo foi recriado. Assim <option> -p 3 </ "
"option> imprimiria duas vezes por vez antes do processamento e uma vez "
"depois (você pode encontrar a diferença entre os dois interessantes). Isso é "
"muito útil para mim mas você pode achar que é informativo em algumas "
"circunstâncias bizarras."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1345
#, fuzzy
msgid "<option>-q</option>"
msgstr "<option> -q </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1348
#, fuzzy
msgid ""
"If you give <application>PMake</application> this flag, it will not try to "
"re-create anything. It will just see if anything is out-of-date and exit non-"
"zero if so."
msgstr ""
"Se você der a <application> PMake </ application> este flag, ele não tentará "
"recriar qualquer coisa. Só vai ver se alguma coisa está desatualizada e sair "
"sem zero em caso afirmativo."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1355
#, fuzzy
msgid "<option>-r</option>"
msgstr "<option> -r </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1358
#, fuzzy
msgid ""
"When <application>PMake</application> starts up, it reads a default makefile "
"that tells it what sort of system it is on and gives it some idea of what to "
"do if you do not tell it anything. I will tell you about it in <xref linkend="
"\"shortcuts\"/>. If you give this flag, <application>PMake</application> "
"will not read the default makefile."
msgstr ""
"Quando o <application> PMake </ application> é iniciado, ele lê um makefile "
"padrão que diz que tipo de sistema é e dá uma ideia do que faça se você não "
"disser nada. Eu vou falar sobre isso em <xref linkend = \\ \"atalhos \\\" />."
" Se você der este sinalizador, <application> PMake </ application> não lerá "
"o makefile padrão."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1368
#, fuzzy
msgid "<option>-s</option>"
msgstr "<option> -s </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1371
#, fuzzy
msgid ""
"This causes <application>PMake</application> to not print commands before "
"they are executed. It is the equivalent of putting an <quote>@</quote> "
"before every command in the makefile."
msgstr ""
"Isso faz com que <application> PMake </ application> não imprima comandos "
"antes eles são executados. É o equivalente a colocar um <quote> @ </ quote> "
"antes de cada comando no makefile."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1379
#, fuzzy
msgid "<option>-t</option>"
msgstr "<option> -t </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1382
#, fuzzy
msgid ""
"Rather than try to re-create a target, <application>PMake</application> will "
"simply <quote>touch</quote> it so as to make it appear up-to-date. If the "
"target did not exist before, it will when <application>PMake</application> "
"finishes, but if the target did exist, it will appear to have been updated."
msgstr ""
"Em vez de tentar recriar um destino, <application> PMake </ application> "
"simplesmente <quote> toque </ quote> para que pareça atualizado. Se o "
"destino não existia antes, quando <application> PMake </ application> "
"termina, mas se o alvo existir, ele parecerá ter sido atualizado."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1392
#, fuzzy
msgid "<option>-v</option>"
msgstr "<option> -v </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1395
#, fuzzy
msgid ""
"Targets can still be created in parallel, however. This is the mode "
"<application>PMake</application> will enter if it is invoked either as "
"<command>smake</command> or <command>vmake</command>."
msgstr ""
"Os alvos ainda podem ser criados em paralelo, no entanto. Este é o modo "
"<application> PMake </ application> entrará se for invocado como <comando> "
"smake </ command> ou <command> vmake </ command>."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1403
#, fuzzy
msgid "<option>-x</option>"
msgstr "<opção> -x </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1406
#, fuzzy
msgid ""
"This tells <application>PMake</application> it is OK to export jobs to other "
"machines, if they are available. It is used when running in Make mode, as "
"exporting in this mode tends to make things run slower than if the commands "
"were just executed locally."
msgstr ""
"Isso informa ao <application> PMake </ application> que é OK exportar "
"trabalhos para outro máquinas, se estiverem disponíveis. É usado ao executar "
"no modo Make, como exportar neste modo tende a tornar as coisas mais lentas "
"do que se os comandos foram executados apenas localmente."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1415
#, fuzzy
msgid "<option>-B</option>"
msgstr "<opção> -B </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1418
#, fuzzy
msgid ""
"Forces <application>PMake</application> to be as backwards-compatible with "
"<application>Make</application> as possible while still being itself. This "
"includes:"
msgstr ""
"Força <application> PMake </ application> a ser compatível com versões "
"anteriores <application> Make </ application> possível enquanto ainda está "
"sendo usado. este inclui:"

#. (itstool) path: listitem/para
#: book.translate.xml:1424
#, fuzzy
msgid "Executing one shell per shell command"
msgstr "Executando um shell por comando shell"

#. (itstool) path: listitem/para
#: book.translate.xml:1428
#, fuzzy
msgid ""
"Expanding anything that looks even vaguely like a variable, with the empty "
"string replacing any variable <application>PMake</application> does not know."
""
msgstr ""
"Expandindo tudo o que parece vagamente como uma variável, com o vazio string "
"substituindo qualquer variável <application> PMake </ application> não sabe."

#. (itstool) path: listitem/para
#: book.translate.xml:1434
#, fuzzy
msgid ""
"Refusing to allow you to escape a <literal>#</literal> with a backslash."
msgstr ""
"Recusando-se a permitir que você escape de um <literal> # </ literal> com "
"uma barra invertida."

#. (itstool) path: listitem/para
#: book.translate.xml:1439
#, fuzzy
msgid ""
"Permitting undefined variables on dependency lines and conditionals (see "
"below). Normally this causes <application>PMake</application> to abort."
msgstr ""
"Permitindo variáveis indefinidas em linhas de dependência e condicionais "
"(ver abaixo). Normalmente isso faz com que o <application> PMake </ "
"application> seja interrompido."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1448
#, fuzzy
msgid "<option>-C</option>"
msgstr "<opção> -C </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1451
#, fuzzy
msgid ""
"This nullifies any and all compatibility mode flags you may have given or "
"implied up to the time the <option>-C</option> is encountered. It is useful "
"mostly in a makefile that you wrote for <application>PMake</application> to "
"avoid bad things happening when someone runs <application>PMake</"
"application> as <application>make</application> or has things set in the "
"environment that tell it to be compatible. <option>-C</option> is not placed "
"in the <envar>PMAKE</envar> environment variable or the <varname>.MAKEFLAGS</"
"varname> or <envar>MFLAGS</envar> global variables."
msgstr ""
"Isso anula todos e quaisquer sinalizadores de modo de compatibilidade que "
"você possa ter dado ou implícita até o momento em que <option> -C </ option> "
"é encontrado. É útil principalmente em um makefile que você escreveu para "
"<application> PMake </ application> para evitar coisas ruins que acontecem "
"quando alguém executa <application> PMake </ application> as <application> "
"make </ application> ou tem coisas definidas no ambiente que diz que é "
"compatível. <option> -C </ option> não é colocado na variável de ambiente "
"<envar> PMAKE </ envar> ou o <varname> .MAKEFLAGS </ varname> ou <envar> "
"MFLAGS </ envar> variáveis globais."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1465
#, fuzzy
msgid "<option>-D <replaceable>variable</replaceable></option>"
msgstr "<option> -D <replaceable> variable </ replaceable> </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1468
#, fuzzy
msgid ""
"Allows you to define a variable to have <quote>1</quote> as its value. The "
"variable is a global variable, not a command-line variable. This is useful "
"mostly for people who are used to the C compiler arguments and those using "
"conditionals, which I will get into in <xref linkend=\"condition\"/>."
msgstr ""
"Permite que você defina uma variável para ter <quote> 1 </ quote> como seu "
"valor. o variável é uma variável global, não uma variável de linha de "
"comando. Isso é útil principalmente para pessoas que estão acostumadas com "
"os argumentos do compilador C e aqueles que usam condicionais, que eu vou "
"entrar em <xref linkend = \\ \"condition \\\" />."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1477
#, fuzzy
msgid "<option>-I <replaceable>directory</replaceable></option>"
msgstr "<option> -I <replaceable> directory </ replaceable> </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1480
#, fuzzy
msgid ""
"Tells <application>PMake</application> another place to search for included "
"makefiles. Yet another thing to be explained in <xref linkend=\"shortcuts\"/"
"> (<xref linkend=\"including\"/>, to be precise)."
msgstr ""
"Diz ao <application> PMake </ application> outro local para pesquisar "
"incluído makefiles. Ainda outra coisa a ser explicada em <xref linkend = \\ "
"\"shortcuts \\\" / > (<xref linkend = \\ \"incluindo \\\" />, para ser "
"preciso)."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1488
#, fuzzy
msgid "<option>-J <replaceable>number</replaceable></option>"
msgstr "<option> -J <replaceable> number </ replaceable> </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1491
#, fuzzy
msgid ""
"Gives the absolute maximum number of targets to create at once on both local "
"and remote machines."
msgstr ""
"Dá o número máximo absoluto de alvos para criar de uma vez em ambos os "
"locais e máquinas remotas."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1497
#, fuzzy
msgid "<option>-L <replaceable>number</replaceable></option>"
msgstr "<option> -L <replaceable> number </ replaceable> </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1500
#, fuzzy
msgid ""
"This specifies the maximum number of targets to create on the local machine "
"at once. This may be <literal>0</literal>, though you should be wary of "
"doing this, as <application>PMake</application> may hang until a remote "
"machine becomes available, if one is not available when it is started."
msgstr ""
"Isso especifica o número máximo de destinos para criar na máquina local de "
"uma vez só. Isso pode ser <literal> 0 </ literal>, embora você deva "
"desconfiar fazendo isso, como <application> PMake </ application> pode "
"travar até um controle remoto a máquina fica disponível, se não estiver "
"disponível quando ela for iniciada."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1510
#, fuzzy
msgid "<option>-M</option>"
msgstr "<opção> -M </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1513
#, fuzzy
msgid ""
"This is the flag that provides absolute, complete, full compatibility with "
"<application>Make</application>. It still allows you to use all but a few of "
"the features of <application>PMake</application>, but it is non-parallel. "
"This is the mode <application>PMake</application> enters if you call it "
"<command>make</command>."
msgstr ""
"Esta é a bandeira que fornece compatibilidade absoluta, completa e completa "
"com <application> Make </ application>. Ele ainda permite que você use "
"todos, mas alguns os recursos do <application> PMake </ application>, mas "
"não é paralelo. Este é o modo <application> PMake </ application> entra se "
"você chamá-lo <command> make </ command>."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1523
#, fuzzy
msgid "<option>-P</option>"
msgstr "<opção> -P </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1526
#, fuzzy
msgid ""
"When creating targets in parallel, several shells are executing at once, "
"each wanting to write its own two cents'-worth to the screen. This output "
"must be captured by <application>PMake</application> in some way in order to "
"prevent the screen from being filled with garbage even more indecipherable "
"than you usually see. <application>PMake</application> has two ways of doing "
"this, one of which provides for much cleaner output and a clear separation "
"between the output of different jobs, the other of which provides a more "
"immediate response so one can tell what is really happening. The former is "
"done by notifying you when the creation of a target starts, capturing the "
"output and transferring it to the screen all at once when the job finishes. "
"The latter is done by catching the output of the shell (and its children) "
"and buffering it until an entire line is received, then printing that line "
"preceded by an indication of which job produced the output. Since I prefer "
"this second method, it is the one used by default. The first method will be "
"used if you give the <option>-P</option> flag to <application>PMake</"
"application>."
msgstr ""
"Ao criar alvos em paralelo, vários shells estão sendo executados de uma só "
"vez, cada um querendo escrever seus próprios dois centavos para a tela. Esta "
"saída deve ser capturado pelo <application> PMake </ application> de alguma "
"forma, a fim de impedir que a tela seja preenchida com lixo ainda mais "
"indecifrável do que você costuma ver. <application> PMake </ application> "
"tem duas maneiras de fazer isso, um dos quais fornece saída muito mais limpa "
"e uma separação clara entre a saída de diferentes trabalhos, a outra fornece "
"mais resposta imediata para que se possa dizer o que realmente está "
"acontecendo. O primeiro é feito notificando-o quando a criação de um alvo "
"começa, capturando o saída e transferi-lo para a tela de uma só vez quando o "
"trabalho termina. O último é feito pegando a saída do shell (e seus filhos) "
"e armazená-lo em buffer até que uma linha inteira seja recebida e, em "
"seguida, imprimir essa linha precedido por uma indicação de qual trabalho "
"produziu a saída. Desde que eu prefiro este segundo método, é aquele usado "
"por padrão. O primeiro método será usado se você der o sinalizador <option> -"
"P </ option> para <application> PMake </ aplicação>."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1549
#, fuzzy
msgid "<option>-V</option>"
msgstr "<opção> -V </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1552
#, fuzzy
msgid ""
"As mentioned before, the <option>-V</option> flag tells <application>PMake</"
"application> to use <application>Make</application>'s style of expanding "
"variables, substituting the empty string for any variable it does not know."
msgstr ""
"Como mencionado anteriormente, o sinalizador <option> -V </ option> indica "
"ao <application> PMake </ application> para usar o estilo de expansão do "
"<application> Make </ application> variáveis, substituindo a string vazia "
"por qualquer variável que não conhece."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1561
#, fuzzy
msgid "<option>-W</option>"
msgstr "<opção> -W </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1564
#, fuzzy
msgid ""
"There are several times when <application>PMake</application> will print a "
"message at you that is only a warning, i.e. it can continue to work in spite "
"of your having done something silly (such as forgotten a leading tab for a "
"shell command). Sometimes you are well aware of silly things you have done "
"and would like <application>PMake</application> to stop bothering you. This "
"flag tells it to shut up about anything non-fatal."
msgstr ""
"Existem várias vezes quando o <application> PMake </ application> imprime "
"mensagem para você que é apenas um aviso, ou seja, pode continuar a "
"funcionar apesar de de ter feito algo bobo (como esquecer um guia principal "
"para um comando shell). Às vezes você está bem ciente das coisas bobas que "
"você fez e gostaria que o <application> PMake </ application> parasse de "
"incomodá-lo. este bandeira diz para calar a boca sobre qualquer coisa não "
"fatal."

#. (itstool) path: varlistentry/term
#: book.translate.xml:1575
#, fuzzy
msgid "<option>-X</option>"
msgstr "<opção> -X </ option>"

#. (itstool) path: listitem/para
#: book.translate.xml:1578
#, fuzzy
msgid ""
"This flag causes <application>PMake</application> to not attempt to export "
"any jobs to another machine."
msgstr ""
"Esse sinalizador faz com que <application> PMake </ application> não tente "
"exportar qualquer trabalho para outra máquina."

#. (itstool) path: section/para
#: book.translate.xml:1584
#, fuzzy
msgid ""
"Several flags may follow a single <literal>-</literal>. Those flags that "
"require arguments take them from successive parameters. For example:"
msgstr ""
"Vários flags podem seguir um único <literal> - </ literal>. Aquelas "
"bandeiras que requerem argumentos que os tirem de parâmetros sucessivos. Por "
"exemplo:"

#. (itstool) path: section/screen
#: book.translate.xml:1588
#, fuzzy, no-wrap
msgid "pmake -fDnI server.mk DEBUG /chip2/X/server/include"
msgstr "pmake -fDnI server.mk DEBUG / chip2 / X / servidor / include"

#. (itstool) path: section/para
#: book.translate.xml:1590
#, fuzzy
msgid ""
"will cause <application>PMake</application> to read <filename>server.mk</"
"filename> as the input makefile, define the variable <varname>DEBUG</"
"varname> as a global variable and look for included makefiles in the "
"directory <filename>/chip2/X/server/include</filename>."
msgstr ""
"fará com que <application> PMake </ application> leia <nomedoarquivo> server."
"mk </ filename> como o makefile de entrada, defina a variável <varname> "
"DEBUG </ varname> como uma variável global e procure por makefiles incluídos "
"no diretório <nome do arquivo> / chip2 / X / server / include </ filename>."

#. (itstool) path: section/title
#: book.translate.xml:1598
#, fuzzy
msgid "Summary"
msgstr "Resumo"

#. (itstool) path: section/para
#: book.translate.xml:1600
#, fuzzy
msgid "A makefile is made of four types of lines:"
msgstr "Um makefile é feito de quatro tipos de linhas:"

#. (itstool) path: listitem/para
#: book.translate.xml:1604
#, fuzzy
msgid "Dependency lines"
msgstr "Linhas de dependência"

#. (itstool) path: section/para
#: book.translate.xml:1620
#, fuzzy
msgid ""
"A dependency line is a list of one or more targets, an operator (<literal>:</"
"literal>, <literal>::</literal>, or <literal>!</literal>), and a list of "
"zero or more sources. Sources may contain wildcards and certain local "
"variables."
msgstr ""
"Uma linha de dependência é uma lista de um ou mais destinos, um operador "
"(<literal>: </ literal>, <literal> :: </ literal>, ou <literal>! </ "
"literal>), e uma lista de zero ou mais fontes. Fontes podem conter curingas "
"e certas variáveis."

#. (itstool) path: section/para
#: book.translate.xml:1625
#, fuzzy
msgid ""
"A creation command is a regular shell command preceded by a tab. In "
"addition, if the first two characters after the tab (and other whitespace) "
"are a combination of <literal>@</literal> or <literal>-</literal>, "
"<application>PMake</application> will cause the command to not be printed "
"(if the character is <literal>@</literal>) or errors from it to be ignored "
"(if <literal>-</literal>). A blank line, dependency line or variable "
"assignment terminates a creation script. There may be only one creation "
"script for each target with a <literal>:</literal> or <literal>!</literal> "
"operator."
msgstr ""
"Um comando de criação é um comando de shell regular precedido por uma guia. "
"Em Além disso, se os dois primeiros caracteres após a guia (e outros espaços "
"em branco) são uma combinação de <literal> @ </ literal> ou <literal> - </ "
"literal>, <application> PMake </ application> fará com que o comando não "
"seja impresso (se o caractere for <literal> @ </ literal>) ou erros dele "
"serem ignorados (se <literal> - </ literal>). Uma linha em branco, linha de "
"dependência ou variável atribuição termina um script de criação. Pode haver "
"apenas uma criação script para cada destino com um <literal>: </ literal> ou "
"<literal>! </ literal> operador."

#. (itstool) path: section/para
#: book.translate.xml:1635
#, fuzzy
msgid ""
"Variables are places to store text. They may be unconditionally assigned-to "
"using the <literal>=</literal> operator, appended-to using the <literal>+=</"
"literal> operator, conditionally (if the variable is undefined) assigned-to "
"with the <literal>?=</literal> operator, and assigned-to with variable "
"expansion with the <literal>:=</literal> operator. The output of a shell "
"command may be assigned to a variable using the <literal>!=</literal> "
"operator. Variables may be expanded (their value inserted) by enclosing "
"their name in parentheses or curly braces, preceded by a dollar sign. A "
"dollar sign may be escaped with another dollar sign. Variables are not "
"expanded if <application>PMake</application> does not know about them. There "
"are seven local variables: <varname>.TARGET</varname>, <varname>.ALLSRC</"
"varname>, <varname>.OODATE</varname>, <varname>.PREFIX</varname>, <varname>."
"IMPSRC</varname>, <varname>.ARCHIVE</varname>, and <varname>.MEMBER</"
"varname>. Four of them (<varname>.TARGET</varname>, <varname>.PREFIX</"
"varname>, <varname>.ARCHIVE</varname>, and <varname>.MEMBER</varname>) may "
"be used to specify <quote>dynamic sources</quote>. Variables are good. Know "
"them. Love them. Live them."
msgstr ""
"Variáveis são locais para armazenar texto. Eles podem ser atribuídos "
"incondicionalmente usando o operador <literal> = </ literal>, anexado ao "
"usando o <literal> + = </ literal> operator, condicionalmente (se a variável "
"for indefinida) assigned-to com o operador <literal>? = </ literal>, e "
"atribuído a com variável expansão com o operador <literal>: = </ literal>. A "
"saída de um shell comando pode ser atribuído a uma variável usando o "
"<literal>! = </ literal> operador. Variáveis podem ser expandidas (seu valor "
"inserido) por anexar seu nome entre parênteses ou chaves, precedido por um "
"sinal de dólar. UMA cifrão pode ser escapado com outro sinal de dólar. "
"Variáveis não são expandido se <application> PMake </ application> não "
"souber sobre eles. Lá são sete variáveis locais: <varname> .TARGET </ "
"varname>, <varname> .ALLSRC </ varname>, <varname> .OODATE </ varname>, "
"<varname> .PREFIX </ varname>, <varname>. IMPSRC </ varname>, <varname> ."
"ARCHIVE </ varname> e <varname> .MEMBER </ varname>. Quatro deles (<varname> "
".TARGET </ varname>, <varname> .PREFIX </ varname>, <varname> .ARCHIVE </ "
"varname>, e <varname> .MEMBER </ varname>) podem ser usado para especificar "
"<quote> fontes dinâmicas </ quote>. Variáveis são boas. Conhecer eles. Amá-"
"los. Viva eles."

#. (itstool) path: section/para
#: book.translate.xml:1655
#, fuzzy
msgid ""
"Debugging of makefiles is best accomplished using the <option>-n</option>, "
"<option>-d m</option>, and <option>-p 2</option> flags."
msgstr ""
"A depuração de makefiles é melhor realizada usando o <option> -n </ option>, "
"<option> -d m </ option> e <option> -p 2 </ option> flags."

#. (itstool) path: chapter/title
#: book.translate.xml:1666
#, fuzzy
msgid "Short-cuts and Other Nice Things"
msgstr "Atalhos e outras coisas boas"

#. (itstool) path: chapter/para
#: book.translate.xml:1668
#, fuzzy
msgid ""
"Based on what I have told you so far, you may have gotten the impression "
"that <application>PMake</application> is just a way of storing away commands "
"and making sure you do not forget to compile something. Good. That is just "
"what it is. However, the ways I have described have been inelegant, at best, "
"and painful, at worst. This chapter contains things that make the writing of "
"makefiles easier and the makefiles themselves shorter and easier to modify "
"(and, occasionally, simpler). In this chapter, I assume you are somewhat "
"more familiar with Sprite (or <trademark class=\"registered\">UNIX</"
"trademark>, if that is what you are using) than I did in <xref linkend="
"\"basics\"/>, just so you are on your toes. So without further ado…"
msgstr ""
"Com base no que lhe contei até agora, você pode ter tido a impressão que "
"<application> PMake </ application> é apenas uma maneira de armazenar "
"comandos e certificando-se de não esquecer de compilar alguma coisa. Boa. "
"Isso é apenas o que é isso. No entanto, as formas que descrevi foram "
"deselegantes, na melhor das hipóteses e doloroso, na pior das hipóteses. "
"Este capítulo contém coisas que tornam a escrita de makefiles mais fáceis e "
"os makefiles em si menores e mais fáceis de modificar (e, ocasionalmente, "
"mais simples). Neste capítulo, eu suponho que você é um pouco mais "
"familiarizado com o Sprite (ou <trademark class = \\ \"registered \\\"> UNIX "
"</ trademark>, se é isso que você está usando) do que eu fiz em <xref "
"linkend = \\ \"básico \\\" />, só assim você está no seu pé. Então sem mais "
"delongas…"

#. (itstool) path: section/title
#: book.translate.xml:1681
#, fuzzy
msgid "Transformation Rules"
msgstr "Regras de Transformação"

#. (itstool) path: section/para
#: book.translate.xml:1683
#, fuzzy
msgid ""
"As you know, a file's name consists of two parts: a base name, which gives "
"some hint as to the contents of the file, and a suffix, which usually "
"indicates the format of the file. Over the years, as <trademark class="
"\"registered\">UNIX</trademark> has developed, naming conventions, with "
"regard to suffixes, have also developed that have become almost as "
"incontrovertible as Law. E.g. a file ending in <filename>.c</filename> is "
"assumed to contain C source code; one with a <filename>.o</filename> suffix "
"is assumed to be a compiled, relocatable object file that may be linked into "
"any program; a file with a <filename>.ms</filename> suffix is usually a text "
"file to be processed by <application>Troff</application> with the <literal>-"
"ms</literal> macro package, and so on. One of the best aspects of both "
"<application>Make</application> and <application>PMake</application> comes "
"from their understanding of how the suffix of a file pertains to its "
"contents and their ability to do things with a file based solely on its "
"suffix. This ability comes from something known as a transformation rule. A "
"transformation rule specifies how to change a file with one suffix into a "
"file with another suffix."
msgstr ""
"Como você sabe, o nome de um arquivo consiste em duas partes: um nome base, "
"que dá alguma dica sobre o conteúdo do arquivo, e um sufixo, que geralmente "
"indica o formato do arquivo. Ao longo dos anos, como <trademark class = \\ "
"\"registered \\\"> UNIX </ trademark> foi desenvolvido, com convenções de "
"nomenclatura, com relação aos sufixos, também se desenvolveram e se tornaram "
"quase tão incontrovertível como lei. Por exemplo. um arquivo terminado em "
"<filename> .c </ filename> é Presumido para conter código-fonte C; um com um "
"sufixo <filename> .o </ filename> é considerado um arquivo de objeto "
"compilável e relocável que pode ser vinculado qualquer programa; um arquivo "
"com um sufixo <filename> .ms </ filename> é geralmente um texto arquivo a "
"ser processado pelo <application> Troff </ application> com o <literal> - ms "
"</ literal> pacote macro, e assim por diante. Um dos melhores aspectos de "
"ambos <application> Make </ application> e <application> PMake </ "
"application> são da sua compreensão de como o sufixo de um arquivo pertence "
"ao seu conteúdo e sua capacidade de fazer as coisas com um arquivo baseado "
"exclusivamente em sua sufixo. Essa habilidade vem de algo conhecido como "
"regra de transformação. UMA regra de transformação especifica como alterar "
"um arquivo com um sufixo em um arquivo com outro sufixo."

#. (itstool) path: section/para
#: book.translate.xml:1704
#, fuzzy
msgid ""
"A transformation rule looks much like a dependency line, except the target "
"is made of two known suffixes stuck together. Suffixes are made known to "
"<application>PMake</application> by placing them as sources on a dependency "
"line whose target is the special target <varname>.SUFFIXES</varname>. E.g.:"
msgstr ""
"Uma regra de transformação se parece muito com uma linha de dependência, "
"exceto o destino é feito de dois sufixos conhecidos juntos. Sufixos são "
"conhecidos <application> PMake </ application> colocando-os como fontes em "
"uma dependência linha cujo destino é o destino especial <varname> .SUFFIXES "
"</ varname>. Por exemplo.:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1711
#, fuzzy, no-wrap
msgid ".SUFFIXES   : .o .c\n"
".c.o        :\n"
"\t$(CC) $(CFLAGS) -c $(.IMPSRC)"
msgstr ".SUFFIXES: .o .c \\ n .vigarista \\ t $ (CC) $ (CFLAGS) -c $ (. IMPSRC)"

#. (itstool) path: section/para
#: book.translate.xml:1715
#, fuzzy
msgid ""
"The creation script attached to the target is used to trans form a file with "
"the first suffix (in this case, <filename>.c</filename>) into a file with "
"the second suffix (here, <filename>.o</filename>). In addition, the target "
"inherits whatever attributes have been applied to the transformation rule. "
"The simple rule given above says that to transform a C source file into an "
"object file, you compile it using <application>cc</application> with the "
"<option>-c</option> flag. This rule is taken straight from the system "
"makefile. Many transformation rules (and suffixes) are defined there, and I "
"refer you to it for more examples (type <command>pmake -h</command> to find "
"out where it is)."
msgstr ""
"O script de criação anexado ao destino é usado para transformar um arquivo "
"com o primeiro sufixo (neste caso, <filename> .c </ filename>) em um arquivo "
"com o segundo sufixo (aqui, <nome do arquivo> .o </ filename>). Além disso, "
"o alvo herda quaisquer atributos que tenham sido aplicados à regra de "
"transformação. A regra simples dada acima diz que transformar um arquivo de "
"origem C em um arquivo objeto, você compila usando <application> cc </ "
"application> com o Sinalizador <option> -c </ option>. Esta regra é tirada "
"diretamente do sistema makefile. Muitas regras de transformação (e sufixos) "
"são definidas lá, e eu encaminhá-lo para mais exemplos (digite <comando> "
"pmake -h </ command> para encontrar onde está)."

#. (itstool) path: section/para
#: book.translate.xml:1730
#, fuzzy
msgid ""
"There are several things to note about the transformation rule given above:"
msgstr ""
"Há várias coisas a serem observadas sobre a regra de transformação dada "
"acima:"

#. (itstool) path: listitem/para
#: book.translate.xml:1735
#, fuzzy
msgid ""
"The <varname>.IMPSRC</varname> variable. This variable is set to the "
"<quote>implied source</quote> (the file from which the target is being "
"created; the one with the first suffix), which, in this case, is the "
"<filename>.c</filename> file."
msgstr ""
"A variável <varname> .IMPSRC </ varname>. Esta variável é definida para o "
"<quote> fonte implícita </ quote> (o arquivo do qual o alvo está sendo "
"criado; aquele com o primeiro sufixo), que, nesse caso, é o Arquivo "
"<filename> .c </ filename>."

#. (itstool) path: listitem/para
#: book.translate.xml:1744
#, fuzzy
msgid ""
"The <envar>CFLAGS</envar> variable. Almost all of the transformation rules "
"in the system makefile are set up using variables that you can alter in your "
"makefile to tailor the rule to your needs. In this case, if you want all "
"your C files to be compiled with the <option>-g</option> flag, to provide "
"information for dbx, you would set the <envar>CFLAGS</envar> variable to "
"contain <option>-g</option> (<literal>CFLAGS = -g</literal>) and "
"<application>PMake</application> would take care of the rest."
msgstr ""
"A variável <envar> CFLAGS </ envar>. Quase todas as regras de transformação "
"no makefile do sistema são configurados usando variáveis que você pode "
"alterar em seu makefile para adaptar a regra às suas necessidades. Neste "
"caso, se você quiser tudo seus arquivos C a serem compilados com o "
"sinalizador <option> -g </ option>, para fornecer informações para o dbx, "
"você configuraria a variável <envar> CFLAGS </ envar> para contém <option> -"
"g </ option> (<literal> CFLAGS = -g </ literal>) e O <application> PMake </ "
"application> cuidaria do resto."

#. (itstool) path: section/para
#: book.translate.xml:1757
#, fuzzy
msgid ""
"To give you a quick example, the makefile in <xref linkend=\"envvars\"/> "
"could be changed to this:"
msgstr ""
"Para dar um exemplo rápido, o makefile em <xref linkend = \\ \"envvars \\\" /"
"> poderia ser alterado para isso:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1760
#, fuzzy, no-wrap
msgid ""
"OBJS            = a.o b.o c.o\n"
"program         : $(OBJS)\n"
"\t $(CC) -o $(.TARGET) $(.ALLSRC)\n"
"$(OBJS)         : defs.h"
msgstr ""
"OBJS = a.o b.o c.o \\ n programa: $ (OBJS) \\ n \\ t $ (CC) -o $ (. TARGET) "
"$ (. ALLSRC) \\ n $ (OBJS): defs.h"

#. (itstool) path: footnote/para
#: book.translate.xml:1768
#, fuzzy
msgid ""
"This is also somewhat cleaner, I think, than the dynamic source solution "
"presented in <xref linkend=\"writeanddebug\"/>."
msgstr ""
"Isso também é um pouco mais limpo do que a solução de origem dinâmica "
"apresentado em <xref linkend = \\ \"writeanddebug \\\" />."

#. (itstool) path: section/para
#: book.translate.xml:1765
#, fuzzy
msgid ""
"The transformation rule I gave above takes the place of the 6 lines <_:"
"footnote-1/>:"
msgstr ""
"A regra de transformação que dei acima toma o lugar das 6 linhas <_: nota de "
"rodapé-1 />:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1773
#, fuzzy, no-wrap
msgid ""
"a.o             : a.c\n"
"\tcc -c a.c\n"
"b.o             : b.c\n"
"\tcc -c b.c\n"
"c.o             : c.c\n"
"\tcc -c c.c"
msgstr ""
"a.o: a.c \\ n \\ tcc -c a.c \\ n b.o: b.c \\ n \\ tcc -c b.c \\ n c.o: c.c "
"\\ n \\ tcc -c c.c"

#. (itstool) path: section/para
#: book.translate.xml:1780
#, fuzzy
msgid ""
"Now you may be wondering about the dependency between the <filename>.o</"
"filename> and <filename>.c</filename> files – it is not mentioned anywhere "
"in the new makefile. This is because it is not needed: one of the effects of "
"applying a transformation rule is the target comes to depend on the implied "
"source. That's why it is called the implied source."
msgstr ""
"Agora você pode estar se perguntando sobre a dependência entre o <filename> ."
"o </ filename> e <filename> .c </ filename> arquivos - não é mencionado em "
"nenhum lugar no novo makefile. Isto é porque não é necessário: um dos "
"efeitos de aplicando uma regra de transformação é o alvo passa a depender do "
"implícito fonte. É por isso que é chamado de fonte implícita."

#. (itstool) path: section/para
#: book.translate.xml:1788
#, fuzzy
msgid "For a more detailed example. Say you have a makefile like this:"
msgstr ""
"Para um exemplo mais detalhado. Digamos que você tenha um makefile assim:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1791
#, fuzzy, no-wrap
msgid "a.out           : a.o b.o\n"
"\t$(CC) $(.ALLSRC)"
msgstr "a.out: a.o b.o \\ n \\ t $ (CC) $ (. ALLSRC)"

#. (itstool) path: section/para
#: book.translate.xml:1794
#, fuzzy
msgid "and a directory set up like this:"
msgstr "e um diretório configurado assim:"

#. (itstool) path: section/screen
#: book.translate.xml:1796
#, fuzzy, no-wrap
msgid ""
"total 4\n"
"-rw-rw-r--  1 deboor        34 Sep  7 00:43 Makefile\n"
"-rw-rw-r--  1 deboor       119 Oct  3 19:39 a.c\n"
"-rw-rw-r--  1 deboor       201 Sep  7 00:43 a.o\n"
"-rw-rw-r--  1 deboor        69 Sep  7 00:43 b.c"
msgstr ""
"total 4 \\ n -rw-rw-r-- 1 deboor 34 7 de setembro 00:43 Makefile \\ n -rw-rw-"
"r-- 1 deboor 119 3 de outubro 19:39 a.c \\ n -rw-rw-r-- 1 deboor 201 7 de "
"setembro 00:43 a.o \\ n -rw-rw-r-- 1 deboor 69 7 de setembro 00:43 b.c"

#. (itstool) path: section/para
#: book.translate.xml:1802
#, fuzzy
msgid ""
"While just typing <command>pmake</command> will do the right thing, it is "
"much more informative to type <command>pmake -d s</command>. This will show "
"you what <application>PMake</application> is up to as it processes the files."
" In this case, <application>PMake</application> prints the following:"
msgstr ""
"Enquanto apenas digitar <command> pmake </ command> fará a coisa certa, é "
"muito mais informativo para digitar <command> pmake -d s </ command>. Isso "
"vai mostrar o que o <application> PMake </ application> está fazendo "
"enquanto processa o arquivos. Nesse caso, <application> PMake </ "
"application> imprime o seguinte:"

#. (itstool) path: section/screen
#: book.translate.xml:1809
#, fuzzy, no-wrap
msgid ""
"Suff_FindDeps (a.out)\n"
"     using existing source a.o\n"
"     applying .o -&gt; .out to \"a.o\"\n"
"Suff_FindDeps (a.o)\n"
"     trying a.c...got it\n"
"     applying .c -&gt; .o to \"a.c\"\n"
"Suff_FindDeps (b.o)\n"
"     trying b.c...got it\n"
"     applying .c -&gt; .o to \"b.c\"\n"
"Suff_FindDeps (a.c)\n"
"     trying a.y...not there\n"
"     trying a.l...not there\n"
"     trying a.c,v...not there\n"
"     trying a.y,v...not there\n"
"     trying a.l,v...not there\n"
"Suff_FindDeps (b.c)\n"
"     trying b.y...not there\n"
"     trying b.l...not there\n"
"     trying b.c,v...not there\n"
"     trying b.y,v...not there\n"
"     trying b.l,v...not there\n"
"--- a.o ---\n"
"cc  -c a.c\n"
"--- b.o ---\n"
"cc  -c b.c\n"
"--- a.out ---\n"
"cc a.o b.o"
msgstr ""
"Suff_FindDeps (a.out) \\ n      usando a fonte existente a.o \\ n "
"     aplicando .o - & gt; .out para \\ \"a.o \\\" \\ n Suff_FindDeps (a.o) "
"\\ n      tentando a.c ... entendeu      aplicando .c - & gt; .o para \\ \"a."
"c \\\" \\ n Suff_FindDeps (b.o) \\ n      tentando b.c ... entendeu "
"     aplicando .c - & gt; .o para \\ \"b.c \\\" \\ n Suff_FindDeps (a.c) \\ "
"n      tentando a.y ... não existe \\ n      tentando a.l ... não existe \\ "
"n      tentando a.c, v ... não existe \\ n      tentando a.y, v ... não "
"existe \\ n      tentando a.l, v ... não existe \\ n Suff_FindDeps (b.c) \\ "
"n      tentando b.y ... não existe \\ n      tentando b.l ... não existe \\ "
"n      tentando b.c, v ... não existe \\ n      tentando b.y, v ... não "
"existe \\ n      tentando b.l, v ... não existe \\ n --- a.o --- \\ n cc -c "
"a.c \\ n --- b.o --- \\ n cc -c b.c \\ n --- a.out --- \\ n cc a.o b.o"

#. (itstool) path: section/para
#: book.translate.xml:1837
#, fuzzy
msgid ""
"<computeroutput>Suff_FindDeps</computeroutput> is the name of a function in "
"<application>PMake</application> that is called to check for implied sources "
"for a target using transformation rules. The transformations it tries are, "
"naturally enough, limited to the ones that have been defined (a "
"transformation may be defined multiple times, by the way, but only the most "
"recent one will be used). You will notice, however, that there is a definite "
"order to the suffixes that are tried. This order is set by the relative "
"positions of the suffixes on the <varname>.SUFFIXES</varname> line – the "
"earlier a suffix appears, the earlier it is checked as the source of a "
"transformation. Once a suffix has been defined, the only way to change its "
"position in the pecking order is to remove all the suffixes (by having a "
"<varname>.SUFFIXES</varname> dependency line with no sources) and redefine "
"them in the order you want. (Previously-defined transformation rules will be "
"automatically redefined as the suffixes they involve are re-entered.) "
"Another way to affect the search order is to make the dependency explicit. "
"In the above example, <filename>a.out</filename> depends on <filename>a.o</"
"filename> and <filename>b.o</filename>. Since a transformation exists from "
"<filename>.o</filename> to <filename>.out</filename>, <application>PMake</"
"application> uses that, as indicated by the <computeroutput>using existing "
"source a.o</computeroutput> message."
msgstr ""
"<computeroutput> Suff_FindDeps </ computeroutput> é o nome de uma função em "
"<application> PMake </ application> que é chamado para verificar fontes "
"implícitas para um destino usando regras de transformação. As transformações "
"que ele tenta são, naturalmente, limitado aos que foram definidos (um "
"transformação pode ser definida várias vezes, a propósito, mas apenas o mais "
"um recente será usado). Você vai notar, no entanto, que há um definitivo "
"ordem para os sufixos que são tentados. Esta ordem é definida pelo parente "
"posições dos sufixos na linha <varname> .SUFFIXES </ varname> - o mais cedo "
"um sufixo aparece, quanto mais cedo ele é verificado como a fonte de um "
"transformação. Uma vez que um sufixo tenha sido definido, a única maneira de "
"mudar posição na hierarquia é para remover todos os sufixos (por ter um "
"<varname> .SUFFIXES </ varname> linha de dependência sem fontes) e redefinir "
"-los na ordem que você deseja. (As regras de transformação definidas "
"anteriormente serão automaticamente redefinidos, pois os sufixos envolvidos "
"são redigitados.) Outra maneira de afetar a ordem de pesquisa é tornar a "
"dependência explícita. No exemplo acima, <filename> a.out </ filename> "
"depende do <filename> a.o </ filename> e <nome do arquivo> b.o </ filename>. "
"Desde que existe uma transformação de <filename> .o </ filename> para "
"<filename> .out </ filename>, <application> PMake </ application> usa isso, "
"conforme indicado pelo <computeroutput> usando source a.o </ computeroutput> "
"mensagem."

#. (itstool) path: section/para
#: book.translate.xml:1864
#, fuzzy
msgid ""
"The search for a transformation starts from the suffix of the target and "
"continues through all the defined transformations, in the order dictated by "
"the suffix ranking, until an existing file with the same base (the target "
"name minus the suffix and any leading directories) is found. At that point, "
"one or more transformation rules will have been found to change the one "
"existing file into the target."
msgstr ""
"A busca por uma transformação começa a partir do sufixo do alvo e continua "
"através de todas as transformações definidas, na ordem ditada a "
"classificação do sufixo, até um arquivo existente com a mesma base (o "
"destino nome menos o sufixo e quaisquer diretórios principais) é encontrado. "
"Nesse ponto, uma ou mais regras de transformação terão sido encontradas para "
"alterar o arquivo existente no destino."

#. (itstool) path: section/para
#: book.translate.xml:1872
#, fuzzy
msgid ""
"For example, ignoring what's in the system makefile for now, say you have a "
"makefile like this:"
msgstr ""
"Por exemplo, ignorando o que está no makefile do sistema por enquanto, "
"digamos que você tenha um makefile assim:"

#. (itstool) path: section/screen
#: book.translate.xml:1875
#, fuzzy, no-wrap
msgid ""
".SUFFIXES       : .out .o .c .y .l\n"
".l.c            :\n"
"\tlex $(.IMPSRC)\n"
"\tmv lex.yy.c $(.TARGET)\n"
".y.c            :\n"
"\tyacc $(.IMPSRC)\n"
"\tmv y.tab.c $(.TARGET)\n"
".c.o            :\n"
"\tcc -c $(.IMPSRC)\n"
".o.out          :\n"
"\tcc -o $(.TARGET) $(.IMPSRC)"
msgstr ""
".SUFFIXES: .out .o .c .y .l \\ n .l.c: \\ n \\ tlex $ (. IMPSRC) \\ n \\ tmv "
"lex.yy.c $ (. TARGET) \\ n .y.c: \\ n \\ tyacc $ (. IMPSRC) \\ n \\ tmv y."
"tab.c $ (. TARGET) \\ n .vigarista \\ tcc -c $ (. IMPSRC) \\ n .o.out: \\ n "
"\\ tcc -o $ (. TARGET) $ (. IMPSRC)"

#. (itstool) path: section/para
#: book.translate.xml:1887
#, fuzzy
msgid ""
"and the single file <filename>jive.l</filename>. If you were to type "
"<command>pmake -rd ms jive.out</command>, you would get the following output "
"for <filename>jive.out</filename>:"
msgstr ""
"e o arquivo único <filename> jive.l </ filename>. Se você fosse digitar "
"<command> pmake -rd ms jive.out </ command>, você obteria a seguinte saída "
"para <nome_do_arquivo> jive.out </ filename>:"

#. (itstool) path: section/screen
#: book.translate.xml:1892
#, fuzzy, no-wrap
msgid ""
"Suff_FindDeps (jive.out)\n"
"     trying jive.o...not there\n"
"     trying jive.c...not there\n"
"     trying jive.y...not there\n"
"     trying jive.l...got it\n"
"     applying .l -&gt; .c to \"jive.l\"\n"
"     applying .c -&gt; .o to \"jive.c\"\n"
"     applying .o -&gt; .out to \"jive.o\""
msgstr ""
"Suff_FindDeps (jive.out) \\ n      tentando jive.o ... não existe \\ n "
"     tentando jive.c ... não existe \\ n      tentando jive.y ... não existe "
"\\ n      tentando jive.l ... tenho isso \\ n      aplicando .l - & gt; .c "
"para \\ \"jive.l \\\" \\ n      aplicando .c - & gt; .o para \\ \"jive.c "
"\\\" \\ n      aplicando .o - & gt; .out para \\ \"jive.o \\\""

#. (itstool) path: section/para
#: book.translate.xml:1901
#, fuzzy
msgid ""
"and this is why: <application>PMake</application> starts with the target "
"<filename>jive.out</filename>, figures out its suffix (<filename>.out</"
"filename>) and looks for things it can transform to a <filename>.out</"
"filename> file. In this case, it only finds <filename>.o</filename>, so it "
"looks for the file <filename>jive.o</filename>. It fails to find it, so it "
"looks for transformations into a <filename>.o</filename> file. Again it has "
"only one choice: <filename>.c</filename>. So it looks for <filename>jive.c</"
"filename> and, as you know, fails to find it. At this point it has two "
"choices: it can create the <filename>.c</filename> file from either a "
"<filename>.y</filename> file or a <filename>.l</filename> file. Since "
"<filename>.y</filename> came first on the <varname>.SUFFIXES</varname> line, "
"it checks for <filename>jive.y</filename> first, but can not find it, so it "
"looks for <filename>jive.l</filename> and, lo and behold, there it is. At "
"this point, it has defined a transformation path as follows:"
msgstr ""
"e é por isso: <application> PMake </ application> começa com o destino "
"<filename> jive.out </ filename>, descobre seu sufixo (<filename> .out </ "
"filename>) e procura por coisas que ele pode transformar em um <filename> ."
"out </ nome do arquivo> arquivo. Neste caso, só encontra <filename> .o </ "
"filename>, por isso procura pelo arquivo <filename> jive.o </ filename>. Não "
"consegue encontrá-lo, por isso procura por transformações em um arquivo "
"<filename> .o </ filename>. Mais uma vez tem apenas uma escolha: <nome do "
"arquivo> .c </ filename>. Então, ele procura por <filename> jive.c </ "
"filename> e, como você sabe, não consegue encontrá-lo. Neste ponto, tem dois "
"escolhas: pode criar o arquivo <filename> .c </ filename> a partir de um "
"Arquivo <filename> .y </ filename> ou um arquivo <filename> .l </ filename>. "
"Desde a <filename> .y </ filename> veio primeiro na linha <varname> ."
"SUFFIXES </ varname>, ele verifica primeiro <filename> jive.y </ filename>, "
"mas não consegue encontrá-lo, por isso procura por <filename> jive.l </ "
"filename> e eis que aí está. No Neste ponto, definiu um caminho de "
"transformação da seguinte forma:"

#. (itstool) path: section/literallayout
#: book.translate.xml:1919
#, fuzzy, no-wrap
msgid ""
"<filename>.l</filename>  -&gt;  <filename>.c</filename>  -&gt;  <filename>."
"o</filename>  -&gt; <filename>.out</filename>"
msgstr ""
"<nome do arquivo> .l </ filename> - & gt; <nome do arquivo> .c </ filename> -"
" & gt; <nome do arquivo> .o </ filename> - & gt; <nome do arquivo> .out </ "
"filename>"

#. (itstool) path: section/para
#: book.translate.xml:1921
#, fuzzy
msgid ""
"and applies the transformation rules accordingly. For completeness, and to "
"give you a better idea of what <application>PMake</application> actually did "
"with this three-step transformation, this is what <application>PMake</"
"application> printed for the rest of the process:"
msgstr ""
"e aplica as regras de transformação de acordo. Para completar e para dar uma "
"ideia melhor do que <application> PMake </ application> realmente fez com "
"essa transformação de três etapas, é isso que <application> PMake </ "
"aplicação> impresso para o resto do processo:"

#. (itstool) path: section/screen
#: book.translate.xml:1927
#, fuzzy, no-wrap
msgid ""
"Suff_FindDeps (jive.o)\n"
"     using existing source jive.c\n"
"     applying .c -&gt; .o to \"jive.c\"\n"
"Suff_FindDeps (jive.c)\n"
"     using existing source jive.l\n"
"     applying .l -&gt; .c to \"jive.l\"\n"
"Suff_FindDeps (jive.l)\n"
"Examining jive.l...modified 17:16:01 Oct 4, 1987...up-to-date\n"
"Examining jive.c...non-existent...out-of-date\n"
"--- jive.c ---\n"
"lex jive.l\n"
"... meaningless lex output deleted ...\n"
"mv lex.yy.c jive.c\n"
"Examining jive.o...non-existent...out-of-date\n"
"--- jive.o ---\n"
"cc -c jive.c\n"
"Examining jive.out...non-existent...out-of-date\n"
"--- jive.out ---\n"
"cc -o jive.out jive.o"
msgstr ""
"Suff_FindDeps (jive.o) \\ n      usando a fonte existente jive.c \\ n "
"     aplicando .c - & gt; .o para \\ \"jive.c \\\" \\ n Suff_FindDeps (jive."
"c) \\ n      usando a fonte existente jive.l \\ n      aplicando .l - & gt; ."
"c para \\ \"jive.l \\\" \\ n Suff_FindDeps (jive.l) \\ n Examinando jive.l .."
". modificado 17:16:01 4 de outubro de 1987 ... up-to-date \\ n Examinando "
"jive.c ... inexistente ... desatualizado \\ n --- jive.c --- \\ n lex jive.l "
"\\ n ... saída de lex sem sentido excluída ... \\ n mv lex.yy.c jive.c \\ n "
"Examinando jive.o ... inexistente ... desatualizado \\ n --- jive.o --- \\ n "
"cc -c jive.c \\ n Examinando jive.out ... inexistente ... out-of-date \\ n --"
"- jive.out --- \\ n cc -o jive.out jive.o"

#. (itstool) path: para/buildtarget
#. (itstool) path: entry/buildtarget
#: book.translate.xml:1952 book.translate.xml:2578
#, fuzzy
msgid ".NULL"
msgstr ".NULO"

#. (itstool) path: section/para
#: book.translate.xml:1947
#, fuzzy
msgid ""
"One final question remains: what does <application>PMake</application> do "
"with targets that have no known suffix? <application>PMake</application> "
"simply pretends it actually has a known suffix and searches for "
"transformations accordingly. The suffix it chooses is the source for the <_:"
"buildtarget-1/> target mentioned later. In the system makefile, <filename>."
"out</filename> is chosen as the <quote>null suffix</quote> because most "
"people use <application>PMake</application> to create programs. You are, "
"however, free and welcome to change it to a suffix of your own choosing. The "
"null suffix is ignored, however, when <application>PMake</application> is in "
"compatibility mode (see <xref linkend=\"gods\"/>)."
msgstr ""
"Uma última questão permanece: o que <application> PMake </ application> faz "
"com alvos que não têm sufixo conhecido? <application> PMake </ application> "
"simplesmente finge que realmente tem um sufixo conhecido e procura por "
"transformações em conformidade. O sufixo escolhido é a fonte para o <_: "
"buildtarget-1 /> meta mencionada posteriormente. No makefile do sistema, "
"<filename>. out </ filename> é escolhido como o <quote> sufixo nulo </ "
"quote> porque a maioria as pessoas usam <application> PMake </ application> "
"para criar programas. Tu es, no entanto, livre e bem-vindo para alterá-lo "
"para um sufixo de sua escolha. o O sufixo nulo é ignorado, no entanto, "
"quando <application> PMake </ application> está em modo de compatibilidade "
"(veja <xref linkend = \\ \"gods \\\" />)."

#. (itstool) path: section/title
#: book.translate.xml:1963
#, fuzzy
msgid "Including Other Makefiles"
msgstr "Incluindo outros Makefiles"

#. (itstool) path: section/para
#: book.translate.xml:1965
#, fuzzy
msgid ""
"Just as for programs, it is often useful to extract certain parts of a "
"makefile into another file and just include it in other makefiles somehow. "
"Many compilers allow you say something like:"
msgstr ""
"Assim como nos programas, muitas vezes é útil extrair certas partes de um "
"makefile em outro arquivo e apenas incluí-lo em outros makefiles de alguma "
"forma. Muitos compiladores permitem que você diga algo como:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1970
#, fuzzy, no-wrap
msgid "#include \"defs.h\""
msgstr "#include \\ \"defs.h \\\""

#. (itstool) path: section/para
#: book.translate.xml:1972
#, fuzzy
msgid ""
"to include the contents of <filename>defs.h</filename> in the source file. "
"<application>PMake</application> allows you to do the same thing for "
"makefiles, with the added ability to use variables in the filenames. An "
"include directive in a makefile looks either like this:"
msgstr ""
"para incluir o conteúdo de <filename> defs.h </ filename> no arquivo de "
"origem. <application> PMake </ application> permite que você faça a mesma "
"coisa makefiles, com a capacidade adicional de usar variáveis nos nomes de "
"arquivos. A incluir diretiva em um makefile se parece com isso:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1978
#, fuzzy, no-wrap
msgid "#include &lt;file&gt;"
msgstr "#include & lt; file & gt;"

#. (itstool) path: section/para
#: book.translate.xml:1980
#, fuzzy
msgid "or this:"
msgstr "ou isto:"

#. (itstool) path: section/programlisting
#: book.translate.xml:1982
#, fuzzy, no-wrap
msgid "#include \"file\""
msgstr "#include \\ \"file \\\""

#. (itstool) path: section/para
#: book.translate.xml:1984
#, fuzzy
msgid ""
"The difference between the two is where <application>PMake</application> "
"searches for the file: the first way, <application>PMake</application> will "
"look for the file only in the system makefile directory (or directories) (to "
"find out what that directory is, give <application>PMake</application> the "
"<filename>-h</filename> flag). The system makefile directory search path can "
"be overridden via the <option>-m</option> option. For files in double-"
"quotes, the search is more complex:"
msgstr ""
"A diferença entre os dois é onde <application> PMake </ application> procura "
"pelo arquivo: a primeira maneira, o <application> PMake </ application> "
"procure o arquivo apenas no diretório makefile (ou diretórios) do sistema "
"(para descobrir qual é esse diretório, dê ao <application> PMake </ "
"application> <filename> -h </ filename> flag). O caminho de pesquisa do "
"diretório makefile do sistema pode ser sobrescrito através da opção <option> "
"-m </ option>. Para arquivos em aspas, a pesquisa é mais complexa:"

#. (itstool) path: listitem/para
#: book.translate.xml:1996
#, fuzzy
msgid "The directory of the makefile that's including the file."
msgstr "O diretório do makefile que está incluindo o arquivo."

#. (itstool) path: listitem/para
#: book.translate.xml:2001
#, fuzzy
msgid ""
"The current directory (the one in which you invoked <application>PMake</"
"application>)."
msgstr ""
"O diretório atual (aquele no qual você chamou <application> PMake </ "
"aplicação>)."

#. (itstool) path: listitem/para
#: book.translate.xml:2006
#, fuzzy
msgid ""
"The directories given by you using <option>-I</option> flags, in the order "
"in which you gave them."
msgstr ""
"Os diretórios dados por você usando os flags <option> -I </ option>, na "
"ordem em que você deu a eles."

#. (itstool) path: listitem/para
#: book.translate.xml:2012
#, fuzzy
msgid ""
"Directories given by <varname>.PATH</varname> dependency lines (see <xref "
"linkend=\"gods\"/>)."
msgstr ""
"Diretórios fornecidos pelas linhas de dependência <varname> .PATH </ "
"varname> (consulte <xref linkend = \\ \"deuses \\\" />)."

#. (itstool) path: listitem/para
#: book.translate.xml:2018
#, fuzzy
msgid "The system makefile directory."
msgstr "O diretório makefile do sistema."

#. (itstool) path: section/para
#: book.translate.xml:2022
#, fuzzy
msgid "in that order."
msgstr "naquela ordem."

#. (itstool) path: section/para
#: book.translate.xml:2024
#, fuzzy
msgid ""
"You are free to use <application>PMake</application> variables in the "
"filename – <application>PMake</application> will expand them before "
"searching for the file. You must specify the searching method with either "
"angle brackets or double-quotes outside of a variable expansion. I.e. the "
"following:"
msgstr ""
"Você está livre para usar as variáveis <application> PMake </ application> "
"no filename - <application> PMake </ application> irá expandi-los antes "
"procurando pelo arquivo. Você deve especificar o método de pesquisa com "
"colchetes angulares ou aspas duplas fora de uma expansão variável. Ou seja a "
"Segue:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2030
#, fuzzy, no-wrap
msgid "SYSTEM    = &lt;command.mk&gt;\n"
"\n"
"#include $(SYSTEM)"
msgstr "SYSTEM = & lt; comando.mk & gt; \\ n \\ n #include $ (SYSTEM)"

#. (itstool) path: section/para
#: book.translate.xml:2034
#, fuzzy
msgid "will not work."
msgstr "não funciona."

#. (itstool) path: section/title
#: book.translate.xml:2038
#, fuzzy
msgid "Saving Commands"
msgstr "Salvando Comandos"

#. (itstool) path: section/para
#: book.translate.xml:2040
#, fuzzy
msgid ""
"There may come a time when you will want to save certain commands to be "
"executed when everything else is done. For instance: you are making several "
"different libraries at one time and you want to create the members in "
"parallel. Problem is, <application>ranlib</application> is another one of "
"those programs that can not be run more than once in the same directory at "
"the same time (each one creates a file called <filename>__.SYMDEF</filename> "
"into which it stuffs information for the linker to use. Two of them running "
"at once will overwrite each other's file and the result will be garbage for "
"both parties). You might want a way to save the ranlib commands til the end "
"so they can be run one after the other, thus keeping them from trashing each "
"other's file. <application>PMake</application> allows you to do this by "
"inserting an ellipsis (<quote>...</quote>) as a command between commands to "
"be run at once and those to be run later."
msgstr ""
"Pode chegar um momento em que você desejará salvar certos comandos para "
"executado quando tudo o resto é feito. Por exemplo: você está fazendo várias "
"bibliotecas diferentes ao mesmo tempo e você quer criar os membros em "
"paralelo. O problema é que <application> ranlib </ application> é outro os "
"programas que não podem ser executados mais de uma vez no mesmo diretório em "
"ao mesmo tempo (cada um cria um arquivo chamado <filename> __. SYMDEF </ "
"filename> em que ele armazena informações para o vinculador usar. Dois deles "
"correndo de uma só vez irá sobrescrever o arquivo do outro e o resultado "
"será lixo para ambas as partes). Você pode querer uma maneira de salvar os "
"comandos do ranlib até o final para que eles possam ser executados um após o "
"outro, evitando assim que sejam destruídos arquivo do outro. <application> "
"PMake </ application> permite que você faça isso inserir reticências "
"(<quote> ... </ quote>) como um comando entre comandos para ser executado de "
"uma só vez e aqueles a serem executados mais tarde."

#. (itstool) path: section/para
#: book.translate.xml:2057
#, fuzzy
msgid ""
"So for the <application>ranlib</application> case above, you might do this:"
msgstr ""
"Portanto, para o caso <application> ranlib </ application> acima, você pode "
"fazer isto:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2060
#, fuzzy, no-wrap
msgid ""
"lib1.a          : $(LIB1OBJS)\n"
"\trm -f $(.TARGET)\n"
"\tar cr $(.TARGET) $(.ALLSRC)\n"
"\t...\n"
"\tranlib $(.TARGET)\n"
"\n"
"lib2.a          : $(LIB2OBJS)\n"
"\trm -f $(.TARGET)\n"
"\tar cr $(.TARGET) $(.ALLSRC)\n"
"\t...\n"
"\tranlib $(.TARGET)"
msgstr ""
"lib1.a: $ (LIB1OBJS) \\ n \\ trm -f $ (. TARGET) \\ n \\ tar cr $ (. TARGET) "
"$ (. ALLSRC) \\ n \\ t ... \\ n \\ tranlib $ (. TARGET) \\ n \\ n lib2.a: $ "
"(LIB2OBJS) \\ n \\ trm -f $ (. TARGET) \\ n \\ tar cr $ (. TARGET) $ (. "
"ALLSRC) \\ n \\ t ... \\ n \\ tranlib $ (. TARGET)"

#. (itstool) path: section/para
#: book.translate.xml:2072
#, fuzzy
msgid "This would save both"
msgstr "Isso salvaria tanto"

#. (itstool) path: section/programlisting
#: book.translate.xml:2074
#, fuzzy, no-wrap
msgid "ranlib $(.TARGET)"
msgstr "ranlib $ (. TARGET)"

#. (itstool) path: section/para
#: book.translate.xml:2076
#, fuzzy
msgid ""
"commands until the end, when they would run one after the other (using the "
"correct value for the <varname>.TARGET</varname> variable, of course)."
msgstr ""
"comandos até o final, quando eles seriam executados um após o outro (usando "
"o valor correto para a variável <varname> .TARGET </ varname>, é claro)."

#. (itstool) path: section/para
#: book.translate.xml:2080
#, fuzzy
msgid ""
"Commands saved in this manner are only executed if <application>PMake</"
"application> manages to re-create everything without an error."
msgstr ""
"Comandos salvos dessa maneira são executados somente se <application> PMake "
"</ application> consegue recriar tudo sem um erro."

#. (itstool) path: section/title
#: book.translate.xml:2086
#, fuzzy
msgid "Target Attributes"
msgstr "Atributos de Destino"

#. (itstool) path: section/para
#: book.translate.xml:2088
#, fuzzy
msgid ""
"<application>PMake</application> allows you to give attributes to targets by "
"means of special sources. Like everything else <application>PMake</"
"application> uses, these sources begin with a period and are made up of all "
"upper-case letters. There are various reasons for using them, and I will try "
"to give examples for most of them. Others you will have to find uses for "
"yourself. Think of it as <quote>an exercise for the reader</quote>. By "
"placing one (or more) of these as a source on a dependency line, you are "
"<quote>marking the target(s) with that attribute</quote>. That is just the "
"way I phrase it, so you know."
msgstr ""
"<application> PMake </ application> permite-lhe atribuir atributos aos alvos "
"por meios de fontes especiais. Como tudo mais <application> PMake </ "
"aplicações, essas fontes começam com um período e são compostas de todas as "
"letras maiúsculas. Existem várias razões para usá-las, e vou tentar para dar "
"exemplos para a maioria deles. Outros você terá que encontrar usos para você "
"mesmo. Pense nisso como <quote> um exercício para o leitor </ quote>. Por "
"colocando um (ou mais) destes como uma fonte em uma linha de dependência, "
"você está <quote> marcando o (s) alvo (s) com esse atributo </ quote>. Isso "
"é apenas o maneira como eu fraseio, então você sabe."

#. (itstool) path: section/para
#: book.translate.xml:2100
#, fuzzy
msgid ""
"Any attributes given as sources for a transformation rule are applied to the "
"target of the transformation rule when the rule is applied."
msgstr ""
"Todos os atributos fornecidos como fontes para uma regra de transformação "
"são aplicados ao alvo da regra de transformação quando a regra é aplicada."

#. (itstool) path: row/entry
#: book.translate.xml:2111
#, fuzzy
msgid "<literal>.DONTCARE</literal>"
msgstr "<literal> .DONTCARE </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2113
#, fuzzy
msgid ""
"If a target is marked with this attribute and <application>PMake</"
"application> can not figure out how to create it, it will ignore this fact "
"and assume the file is not really needed or actually exists and "
"<application>PMake</application> just can not find it. This may prove wrong, "
"but the error will be noted later on, not when <application>PMake</"
"application> tries to create the target so marked. This attribute also "
"prevents <application>PMake</application> from attempting to touch the "
"target if it is given the <option>-t</option> flag."
msgstr ""
"Se um destino estiver marcado com este atributo e <application> PMake </ "
"aplicação> não consigo descobrir como criá-lo, ele irá ignorar este fato e "
"assumir que o arquivo não é realmente necessário ou realmente existe e "
"<application> PMake </ application> simplesmente não consegue encontrá-lo. "
"Isso pode ser errado mas o erro será anotado mais tarde, não quando "
"<application> PMake </ application> tenta criar o alvo tão marcado. Este "
"atributo também impede que o <application> PMake </ application> tente tocar "
"no alvo se for dado o sinalizador <option> -t </ option>."

#. (itstool) path: row/entry
#: book.translate.xml:2127
#, fuzzy
msgid "<literal>.EXEC</literal>"
msgstr "<literal> .EXEC </ literal>"

#. (itstool) path: para/buildtarget
#: book.translate.xml:2142
#, fuzzy
msgid "COMPILE"
msgstr "COMPILAR"

#. (itstool) path: para/programlisting
#: book.translate.xml:2145
#, fuzzy, no-wrap
msgid ""
"system          : init a.fasl b.fasl c.fasl\n"
"\tfor i in $(.ALLSRC);\n"
"\tdo\n"
"\t\techo -n '(load \"' &gt;&gt; input\n"
"\t\techo -n ${i} &gt;&gt; input\n"
"\t\techo '\")' &gt;&gt; input\n"
"\tdone\n"
"\techo '(dump \"$(.TARGET)\")' &gt;&gt; input\n"
"\tlisp &lt; input\n"
"\n"
"a.fasl          : a.l init COMPILE\n"
"b.fasl          : b.l init COMPILE\n"
"c.fasl          : c.l init COMPILE\n"
"COMPILE         : .USE\n"
"\techo '(compile \"$(.ALLSRC)\")' &gt;&gt; input\n"
"init            : .EXEC\n"
"\techo '(load-system)' &gt; input"
msgstr ""
"sistema: init a.fasl b.fasl c.fasl \\ n \\ tfor i em $ (. ALLSRC); \\ n \\ "
"tdo \\ n \\ t \\ techo -n '(carregar \\ \"' & gt; & gt; entrada \\ n \\ t \\ "
"techo -n $ {i} & gt; & gt; entrada \\ n \\ t \\ techo '\\ \")' & gt; & gt; "
"entrada \\ n \\ tdone \\ n \\ techo '(dump \\ \"$ (. TARGET) \\\")' & gt; & "
"gt; entrada \\ n \\ tlisp & lt; entrada \\ n \\ n a.fasl: a.l init COMPILE "
"\\ n b.fasl: b.l init COMPILAR \\ n c.fasl: c.l init COMPILAR \\ n COMPILAR: "
".USE \\ n \\ techo '(compilar \\ \"$ (. ALLSRC) \\\")' & gt; & gt; entrada "
"\\ n init: .EXEC \\ n \\ techo '(load-system)' & gt; entrada"

#. (itstool) path: entry/para
#: book.translate.xml:2129
#, fuzzy
msgid ""
"This attribute causes its shell script to be executed while having no effect "
"on targets that depend on it. This makes the target into a sort of "
"subroutine. An example. Say you have some LISP files that need to be "
"compiled and loaded into a LISP process. To do this, you echo LISP commands "
"into a file and execute a LISP with this file as its input when everything "
"is done. Say also that you have to load other files from another system "
"before you can compile your files and further, that you do not want to go "
"through the loading and dumping unless one of your files has changed. Your "
"makefile might look a little bit like this (remember, this is an educational "
"example, and do not worry about the <_:buildtarget-1/> rule, all will soon "
"become clear, grasshopper): <_:programlisting-2/> <literal>.EXEC</literal> "
"sources, do not appear in the local variables of targets that depend on them "
"(nor are they touched if <application>PMake</application> is given the "
"<option>-t</option> flag). Note that all the rules, not just that for "
"system, include init as a source. This is because none of the other targets "
"can be made until init has been made, thus they depend on it."
msgstr ""
"Este atributo faz com que seu script de shell seja executado sem efeito em "
"alvos que dependem disso. Isso torna o alvo uma espécie de sub-rotina. Um "
"exemplo. Digamos que você tenha alguns arquivos LISP que precisam ser "
"compilado e carregado em um processo LISP. Para fazer isso, você ecoa os "
"comandos LISP em um arquivo e executar um LISP com este arquivo como sua "
"entrada quando tudo é feito. Diga também que você tem que carregar outros "
"arquivos de outro sistema antes que você possa compilar seus arquivos e, "
"além disso, que você não quer ir através do carregamento e descarregamento, "
"a menos que um dos seus arquivos tenha mudado. Seu makefile pode parecer um "
"pouco com isso (lembre-se, isso é um exemplo, e não se preocupe com a regra "
"<_: buildtarget-1 />, tudo em breve tornar-se claro, gafanhoto): <_: "
"programlisting-2 /> <literal> .EXEC </ literal> fontes, não aparecem nas "
"variáveis locais dos alvos que dependem deles (nem são tocados se o "
"<application> PMake </ application> receber o <option> -t </ option> flag). "
"Note que todas as regras, não apenas aquelas para sistema, inclua init como "
"uma fonte. Isto é porque nenhum dos outros alvos pode ser feito até que o "
"init tenha sido feito, assim eles dependem dele."

#. (itstool) path: row/entry
#: book.translate.xml:2174
#, fuzzy
msgid "<literal>.EXPORT</literal>"
msgstr "<literal> .EXPORT </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2176
#, fuzzy
msgid ""
"This is used to mark those targets whose creation should be sent to another "
"machine if at all possible. This may be used by some exportation schemes if "
"the exportation is expensive. You should ask your system administrator if it "
"is necessary."
msgstr ""
"Isso é usado para marcar os destinos cuja criação deve ser enviada para "
"outro máquina, se possível. Isso pode ser usado por alguns esquemas de "
"exportação se a exportação é cara. Você deve perguntar ao administrador do "
"sistema se é necessário."

#. (itstool) path: row/entry
#: book.translate.xml:2185
#, fuzzy
msgid "<literal>.EXPORTSAME</literal>"
msgstr "<literal> .EXPORTSAME </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2187
#, fuzzy
msgid ""
"Tells the export system that the job should be exported to a machine of the "
"same architecture as the current one. Certain operations (e.g. running text "
"through nroff) can be performed the same on any architecture (CPU and "
"operating system type), while others (e.g. compiling a program with cc) must "
"be performed on a machine with the same architecture. Not all export systems "
"will support this attribute."
msgstr ""
"Informa ao sistema de exportação que o trabalho deve ser exportado para uma "
"máquina do mesma arquitetura que a atual. Certas operações (por exemplo, "
"executando texto nroff) podem ser executados da mesma forma em qualquer "
"arquitetura (CPU e tipo de sistema operacional), enquanto outros (por "
"exemplo, compilar um programa com cc) devem ser executado em uma máquina com "
"a mesma arquitetura. Nem todos os sistemas de exportação irá suportar este "
"atributo."

#. (itstool) path: row/entry
#: book.translate.xml:2199
#, fuzzy
msgid "<literal>.IGNORE</literal>"
msgstr "<literal> .IGNORE </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2201
#, fuzzy
msgid ""
"Giving a target the <literal>.IGNORE</literal> attribute causes "
"<application>PMake</application> to ignore errors from any of the target's "
"commands, as if they all had <literal>-</literal> before them."
msgstr ""
"Dar um alvo ao atributo <literal> .IGNORE </ literal> causa <application> "
"PMake </ application> para ignorar erros de qualquer um dos comandos, como "
"se todos eles tivessem <literal> - </ literal> antes deles."

#. (itstool) path: row/entry
#: book.translate.xml:2209
#, fuzzy
msgid "<literal>.INVISIBLE</literal>"
msgstr "<literal> .INVISÍVEL </ literal>"

#. (itstool) path: para/programlisting
#: book.translate.xml:2218
#, fuzzy, no-wrap
msgid ""
"prog1           : $(PROG1OBJS) prog2 MAKEINSTALL\n"
"prog2           : $(PROG2OBJS) .INVISIBLE MAKEINSTALL"
msgstr ""
"prog1: $ (PROG1OBJS) prog2 MAKEINSTALL \\ n prog2: $ (PROG2OBJS) .INVISÍVEL "
"MAKEINSTALL"

#. (itstool) path: para/buildtarget
#: book.translate.xml:2226
#, fuzzy
msgid "prog2"
msgstr "prog2"

#. (itstool) path: entry/para
#: book.translate.xml:2211
#, fuzzy
msgid ""
"This allows you to specify one target as a source for another without the "
"one affecting the other's local variables. Useful if, say, you have a "
"makefile that creates two programs, one of which is used to create the "
"other, so it must exist before the other is created. You could say <_:"
"programlisting-1/> where <literal>MAKEINSTALL</literal> is some complex "
"<literal>.USE</literal> rule (see below) that depends on the <varname>."
"ALLSRC</varname> variable containing the right things. Without the <literal>."
"INVISIBLE</literal> attribute for <_:buildtarget-2/>, the "
"<literal>MAKEINSTALL</literal> rule could not be applied. This is not as "
"useful as it should be, and the semantics may change (or the whole thing go "
"away) in the not-too-distant future."
msgstr ""
"Isso permite que você especifique um destino como uma fonte para outro sem "
"um afetando as variáveis locais do outro. Útil se, digamos, você tiver "
"makefile que cria dois programas, um dos quais é usado para criar o outro, "
"então deve existir antes do outro ser criado. Você poderia dizer <_: "
"programlisting-1 /> onde <literal> MAKEINSTALL </ literal> é algum complexo "
"Regra <literal> .USE </ literal> (veja abaixo) que depende do <varname>. "
"Variável ALLSRC </ varname> contendo as coisas certas. Sem o <literal>. "
"INVISIBLE </ literal> atributo para <_: buildtarget-2 />, o A regra "
"<literal> MAKEINSTALL </ literal> não pôde ser aplicada. Isto não é tão útil "
"como deveria ser, e a semântica pode mudar (ou a coisa toda vai distância) "
"em um futuro não muito distante."

#. (itstool) path: row/entry
#: book.translate.xml:2235
#, fuzzy
msgid "<literal>.JOIN</literal>"
msgstr "<literal> .JOIN </ literal>"

#. (itstool) path: para/programlisting
#: book.translate.xml:2257
#, fuzzy, no-wrap
msgid ""
"program         : $(OBJS) libraries\n"
"\tcc -o $(.TARGET) $(.ALLSRC)\n"
"\n"
"libraries       : lib1.a lib2.a lib3.a lib4.a .JOIN\n"
"\tranlib $(.OODATE)"
msgstr ""
"programa: bibliotecas $ (OBJS) \\ n \\ tcc -o $ (. TARGET) $ (. ALLSRC) \\ n "
"\\ n bibliotecas: lib1.a lib2.a lib3.a lib4.a .JOIN \\ n \\ tranlib $ (. "
"OODATE)"

#. (itstool) path: entry/para
#: book.translate.xml:2237
#, fuzzy
msgid ""
"This is another way to avoid performing some operations in parallel while "
"permitting everything else to be done so. Specifically it forces the "
"target's shell script to be executed only if one or more of the sources was "
"out-of-date. In addition, the target's name, in both its <varname>.TARGET</"
"varname> variable and all the local variables of any target that depends on "
"it, is replaced by the value of its <varname>.ALLSRC</varname> variable. As "
"an example, suppose you have a program that has four libraries that compile "
"in the same directory along with, and at the same time as, the program. You "
"again have the problem with ranlib that I mentioned earlier, only this time "
"it is more severe: you can not just put the ranlib off to the end since the "
"program will need those libraries before it can be re-created. You can do "
"something like this: <_:programlisting-1/> In this case, <application>PMake</"
"application> will re-create the <literal>$(OBJS)</literal> as necessary, "
"along with <filename>lib1.a</filename>, <filename>lib2.a</filename>, "
"<filename>lib3.a</filename> and <filename>lib4.a</filename>. It will then "
"execute ranlib on any library that was changed and set program's <varname>."
"ALLSRC</varname> variable to contain what's in <literal>$(OBJS)</literal> "
"followed by <quote><filename>lib1.a</filename> <filename>lib2.a</filename> "
"<filename>lib3.a</filename> <filename>lib4.a</filename>.</quote> In case you "
"are wondering, it is called <literal>.JOIN</literal> because it joins "
"together different threads of the <quote>input graph</quote> at the target "
"marked with the attribute. Another aspect of the <literal>.JOIN</literal> "
"attribute is it keeps the target from being created if the <option>-t</"
"option> flag was given."
msgstr ""
"Esta é outra maneira de evitar executar algumas operações em paralelo "
"enquanto permitindo que tudo o mais seja feito. Especificamente, força o "
"script shell do alvo a ser executado apenas se uma ou mais das fontes foi "
"desatualizado. Além disso, o nome do alvo, em ambos os <varname> .TARGET </ "
"variável varname> e todas as variáveis locais de qualquer destino que "
"depende ele é substituído pelo valor de sua variável <varname> .ALLSRC </ "
"varname>. Como um exemplo, suponha que você tenha um programa que tenha "
"quatro bibliotecas que compilam no mesmo diretório, juntamente com o "
"programa e ao mesmo tempo. Você novamente tenho o problema com o ranlib que "
"mencionei anteriormente, só que desta vez é mais grave: você não pode "
"simplesmente colocar o ranlib no final, já que o O programa precisará dessas "
"bibliotecas antes de poder ser recriado. Você pode fazer algo como isto: <_: "
"programlisting-1 /> Neste caso, <application> PMake </ application> recriará "
"o <literal> $ (OBJS) </ literal> conforme necessário, juntamente com "
"<filename> lib1.a </ filename>, <filename> lib2.a </ filename>, <filename> "
"lib3.a </ filename> e <filename> lib4.a </ filename>. Então será Execute o "
"ranlib em qualquer biblioteca que tenha sido alterada e defina o <varname> "
"do programa. Variável ALLSRC </ varname> para conter o que está em <literal> "
"$ (OBJS) </ literal> seguido por <quote> <filename> lib1.a </ filename> "
"<filename> lib2.a </ filename> <filename> lib3.a </ filename> <filename> "
"lib4.a </ filename>. </ quote> Caso você está se perguntando, ele é chamado "
"de <literal> .JOIN </ literal> porque se junta juntos diferentes threads do "
"<quote> gráfico de entrada </ quote> no alvo marcado com o atributo. Outro "
"aspecto do <literal> .JOIN </ literal> atributo é ele impede que o alvo seja "
"criado se o <option> -t </ opção> bandeira foi dada."

#. (itstool) path: row/entry
#: book.translate.xml:2287
#, fuzzy
msgid "<literal>.MAKE</literal>"
msgstr "<literal> .MAKE </ literal>"

#. (itstool) path: para/literallayout
#: book.translate.xml:2299
#, fuzzy, no-wrap
msgid "<command>pmake -n</command>"
msgstr "<comando> pmake -n </ command>"

#. (itstool) path: entry/para
#: book.translate.xml:2289
#, fuzzy
msgid ""
"The <literal>.MAKE</literal> attribute marks its target as being a recursive "
"invocation of PMake. This forces <application>PMake</application> to execute "
"the script associated with the target (if it is out-of-date) even if you "
"gave the <option>-n</option> or <option>-t</option> flag. By doing this, you "
"can start at the top of a system and type <_:literallayout-1/> and have it "
"descend the directory tree (if your makefiles are set up correctly), "
"printing what it would have executed if you had not included the <option>-n</"
"option> flag."
msgstr ""
"O atributo <literal> .MAKE </ literal> marca seu alvo como sendo um "
"recursivo invocação de PMake. Isso força o <application> PMake </ "
"application> a executar o script associado ao destino (se estiver "
"desatualizado), mesmo se você deu o sinalizador <option> -n </ option> ou "
"<option> -t </ option>. Ao fazer isso, você pode começar no topo de um "
"sistema e digitar <_: literallayout-1 /> e tê-lo descer a árvore de "
"diretórios (se seus makefiles estiverem configurados corretamente), "
"imprimindo o que seria executado se você não tivesse incluído o <option> -n "
"</ opção> flag."

#. (itstool) path: row/entry
#: book.translate.xml:2308
#, fuzzy
msgid "<literal>.NOEXPORT</literal>"
msgstr "<literal> .NOEXPORT </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2310
#, fuzzy
msgid ""
"If possible, <application>PMake</application> will attempt to export the "
"creation of all targets to another machine (this depends on how "
"<application>PMake</application> was configured). Sometimes, the creation is "
"so simple, it is pointless to send it to another machine. If you give the "
"target the <literal>.NOEXPORT</literal> attribute, it will be run loally, "
"even if you have given <application>PMake</application> the <option>-L 0</"
"option> flag."
msgstr ""
"Se possível, o <application> PMake </ application> tentará exportar o "
"criação de todos os alvos para outra máquina (isso depende de como O "
"<application> PMake </ application> foi configurado). Às vezes, a criação é "
"tão simples, é inútil enviá-lo para outra máquina. Se você der o alvo o "
"atributo <literal> .NOEXPORT </ literal>, ele será executado loally, mesmo "
"que você tenha dado <application> PMake </ application>, o <option> -L 0 </ "
"opção> flag."

#. (itstool) path: row/entry
#: book.translate.xml:2324
#, fuzzy
msgid "<literal>.NOTMAIN</literal>"
msgstr "<literal> .NOTMAIN </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2326
#, fuzzy
msgid ""
"Normally, if you do not specify a target to make in any other way, "
"<application>PMake</application> will take the first target on the first "
"dependency line of a makefile as the target to create. That target is known "
"as the <quote>Main Target</quote> and is labeled as such if you print the "
"dependencies out using the <option>-p</option> flag. Giving a target this "
"attribute tells <application>PMake</application> that the target is "
"definitely not the Main Target. This allows you to place targets in an "
"included makefile and have <application>PMake</application> create something "
"else by default."
msgstr ""
"Normalmente, se você não especificar um destino para fazer de outra maneira, "
"<application> PMake </ application> assumirá o primeiro alvo no primeiro "
"linha de dependência de um makefile como o destino a ser criado. Esse alvo é "
"conhecido como o <quote> Principal alvo </ quote> e é rotulado como tal se "
"você imprimir dependências usando o sinalizador <option> -p </ option>. "
"Dando um alvo esta atributo informa ao <application> PMake </ application> "
"que o destino é definitivamente não é o alvo principal. Isso permite que "
"você coloque alvos em um incluiu makefile e tem <application> PMake </ "
"application> criando algo mais por padrão."

#. (itstool) path: row/entry
#: book.translate.xml:2342
#, fuzzy
msgid "<literal>.PRECIOUS</literal>"
msgstr "<literal> .PRECIOUS </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2344
#, fuzzy
msgid ""
"When <application>PMake</application> is interrupted (you type control-C at "
"the keyboard), it will attempt to clean up after itself by removing any half-"
"made targets. If a target has the <literal>.PRECIOUS</literal> attribute, "
"however, <application>PMake</application> will leave it alone. An additional "
"side effect of the <literal>::</literal> operator is to mark the targets as "
"<literal>.PRECIOUS</literal>."
msgstr ""
"Quando <application> PMake </ application> é interrompido (você digita "
"control-C em o teclado), ele tentará limpar depois de si removendo qualquer "
"metade metas feitas. Se um alvo tiver o atributo <literal> .PRECIOUS </ "
"literal>, no entanto, o <application> PMake </ application> irá deixá-lo "
"sozinho. Um adicional efeito colateral do operador <literal> :: </ literal> "
"é marcar os alvos como <literal> .PRECIOUS </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2356
#, fuzzy
msgid "<literal>.SILENT</literal>"
msgstr "<literal> .SILENT </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:2358
#, fuzzy
msgid ""
"Marking a target with this attribute keeps its commands from being printed "
"when they are executed, just as if they had an <literal>@</literal> in front "
"of them."
msgstr ""
"Marcar um alvo com este atributo impede que seus comandos sejam impressos "
"quando eles são executados, como se eles tivessem um <literal> @ </ literal> "
"na frente deles."

#. (itstool) path: row/entry
#: book.translate.xml:2365
#, fuzzy
msgid "<literal>.USE</literal>"
msgstr "<literal> .USE </ literal>"

#. (itstool) path: para/programlisting
#: book.translate.xml:2388
#, fuzzy, no-wrap
msgid ""
"lib1.a          : $(LIB1OBJS) MAKELIB\n"
"lib2.a          : $(LIB2OBJS) MAKELIB\n"
"\n"
"MAKELIB         : .USE\n"
"\trm -f $(.TARGET)\n"
"\tar cr $(.TARGET) $(.ALLSRC)\n"
"\t...\n"
"\tranlib $(.TARGET)"
msgstr ""
"lib1.a: $ (LIB1OBJS) MAKELIB \\ n lib2.a: $ (LIB2OBJS) MAKELIB \\ n \\ n "
"MAKELIB: .USE \\ n \\ trm -f $ (. TARGET) \\ n \\ tar cr $ (. TARGET) $ (. "
"ALLSRC) \\ n \\ t ... \\ n \\ tranlib $ (. TARGET)"

#. (itstool) path: para/buildtarget
#: book.translate.xml:2403 book.translate.xml:2406
#, fuzzy
msgid "MAKELIB"
msgstr "MAKELIB"

#. (itstool) path: entry/para
#: book.translate.xml:2367
#, fuzzy
msgid ""
"By giving a target this attribute, you turn it into <application/>PMake's "
"equivalent of a macro. When the target is used as a source for another "
"target, the other target acquires the commands, sources and attributes "
"(except <literal>.USE</literal>) of the source. If the target already has "
"commands, the <literal>.USE</literal> target's commands are added to the end."
" If more than one <literal>.USE</literal>-marked source is given to a "
"target, the rules are applied sequentially. The typical <literal>.USE</"
"literal> rule (as I call them) will use the sources of the target to which "
"it is applied (as stored in the <varname>.ALLSRC</varname> variable for the "
"target) as its <quote>arguments,</quote> if you will. For example, you "
"probably noticed that the commands for creating <filename>lib1.a</filename> "
"and <filename>lib2.a</filename> in the example in section <xref linkend="
"\"savingcmds\"/> were exactly the same. You can use the <literal>.USE</"
"literal> attribute to eliminate the repetition, like so: <_:programlisting-1/"
"> Several system makefiles (not to be confused with The System Makefile) "
"make use of these <literal>.USE</literal> rules to make your life easier "
"(they are in the default, system makefile directory...take a look). Note "
"that the <literal>.USE</literal> rule source itself (<_:buildtarget-2/>) "
"does not appear in any of the targets's local variables. There is no limit "
"to the number of times I could use the <_:buildtarget-3/> rule. If there "
"were more libraries, I could continue with <literal>lib3.a : $(LIB3OBJS) "
"MAKELIB</literal> and so on and so forth."
msgstr ""
"Ao atribuir um alvo a esse atributo, você o transforma em <application /> "
"PMake equivalente a uma macro. Quando o alvo é usado como fonte para outro "
"alvo, o outro alvo adquire os comandos, fontes e atributos (exceto <literal> "
".USE </ literal>) da fonte. Se o alvo já tiver comandos, os comandos do "
"<literal> .USE </ literal> target são adicionados ao fim. Se mais de uma "
"fonte marcada com <literal> .USE </ literal> for dada a um alvo, as regras "
"são aplicadas sequencialmente. O típico <literal> .USE </ regra literal> "
"(como eu os chamo) usará as fontes do alvo para as quais ele é aplicado "
"(conforme armazenado na variável <varname> .ALLSRC </ varname> para o alvo) "
"como seus argumentos <quote>, </ quote> se você quiser. Por exemplo, você "
"provavelmente notou que os comandos para criar <filename> lib1.a </ "
"filename> e <filename> lib2.a </ filename> no exemplo na seção <xref linkend "
"= \\ \"savingcmds \\\" /> eram exatamente os mesmos. Você pode usar o "
"<literal> .USE </ literal> atributo para eliminar a repetição, da seguinte "
"forma: <_: programlisting-1 / > Vários makefiles do sistema (não confundir "
"com o Makefile do Sistema) faça uso destas regras <literal> .USE </ literal> "
"para facilitar sua vida (eles estão no diretório padrão, makefile do sistema "
"... dê uma olhada). Nota que a própria fonte de regra <literal> .USE </ "
"literal> (<_: buildtarget-2 />) não aparece em nenhuma das variáveis locais "
"dos alvos. Não há limite para o número de vezes que eu poderia usar a regra "
"<_: buildtarget-3 />. Se lá foram mais bibliotecas, eu poderia continuar com "
"<literal> lib3.a: $ (LIB3OBJS) MAKELIB </ literal> e assim por diante."

#. (itstool) path: section/title
#: book.translate.xml:2417
#, fuzzy
msgid "Special Targets"
msgstr "Metas Especiais"

#. (itstool) path: section/para
#: book.translate.xml:2419
#, fuzzy
msgid ""
"As there were in <application>Make</application>, so there are certain "
"targets that have special meaning to <application>PMake</application>. When "
"you use one on a dependency line, it is the only target that may appear on "
"the left-hand-side of the operator. As for the attributes and variables, all "
"the special targets begin with a period and consist of upper-case letters "
"only. I will not describe them all in detail because some of them are rather "
"complex and I will describe them in more detail than you will want in <xref "
"linkend=\"gods\"/>. The targets are as follows:"
msgstr ""
"Como havia em <application> Make </ application>, então há certas destinos "
"que possuem um significado especial para <application> PMake </ application>."
" Quando você usa um em uma linha de dependência, é o único alvo que pode "
"aparecer em o lado esquerdo do operador. Quanto aos atributos e variáveis, "
"todos os alvos especiais começam com um período e consistem em letras "
"maiúsculas só. Eu não vou descrevê-los todos em detalhes, porque alguns "
"deles são bastante complexo e vou descrevê-los com mais detalhes do que você "
"vai querer em <xref linkend = \\ \"deuses \\\" />. Os alvos são os seguintes:"
""

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2437 book.translate.xml:2465
#, fuzzy
msgid ".BEGIN"
msgstr ".INÍCIO"

#. (itstool) path: row/entry
#: book.translate.xml:2439
#, fuzzy
msgid ""
"Any commands attached to this target are executed before anything else is "
"done. You can use it for any initialization that needs doing."
msgstr ""
"Quaisquer comandos anexados a este alvo são executados antes de qualquer "
"outra coisa ser feito. Você pode usá-lo para qualquer inicialização que "
"precise ser executada."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2446 book.translate.xml:2454 book.translate.xml:2456
#, fuzzy
msgid ".DEFAULT"
msgstr ".PADRÃO"

#. (itstool) path: row/entry
#: book.translate.xml:2448
#, fuzzy
msgid ""
"This is sort of a <literal>.USE</literal> rule for any target (that was used "
"only as a source) that <application>PMake</application> can not figure out "
"any other way to create. It is only <quote>sort of</quote> a <literal>.USE</"
"literal> rule because only the shell script attached to the <_:buildtarget-1/"
"> target is used. The <varname>.IMPSRC</varname> variable of a target that "
"inherits <_:buildtarget-2/>'s commands is set to the target's own name."
msgstr ""
"Esta é uma espécie de regra <literal> .USE </ literal> para qualquer alvo "
"(que foi usado somente como uma fonte) que <application> PMake </ "
"application> não consegue descobrir qualquer outra maneira de criar. É "
"apenas <quote> uma espécie de </ quote> <literal> .USE </ quote> literal> "
"rule porque somente o shell script anexado ao <_: buildtarget-1 / > target é "
"usado. A variável <varname> .IMPSRC </ varname> de um destino que herda <_: "
"buildtarget-2 /> os comandos são definidos para o nome do alvo."

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2462 book.translate.xml:3811
#, fuzzy
msgid ".END"
msgstr ".FIM"

#. (itstool) path: row/entry
#: book.translate.xml:2464
#, fuzzy
msgid ""
"This serves a function similar to <_:buildtarget-1/>, in that commands "
"attached to it are executed once everything has been re-created (so long as "
"no errors occurred). It also serves the extra function of being a place on "
"which <application>PMake</application> can hang commands you put off to the "
"end. Thus the script for this target will be executed before any of the "
"commands you save with the <quote>...</quote>."
msgstr ""
"Isto serve uma função similar a <_: buildtarget-1 />, nesses comandos "
"anexado a ele são executados uma vez que tudo foi recriado (desde que nenhum "
"erro ocorreu). Ele também serve a função extra de ser um lugar em qual "
"<application> PMake </ application> pode travar os comandos que você coloca "
"no fim. Assim, o script para este alvo será executado antes de qualquer um "
"dos comandos que você salva com o <quote> ... </ quote>."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2477
#, fuzzy
msgid ".EXPORT"
msgstr ".EXPORTAR"

#. (itstool) path: row/entry
#: book.translate.xml:2479
#, fuzzy
msgid ""
"The sources for this target are passed to the exportation system compiled "
"into <application>PMake</application>. Some systems will use these sources "
"to configure themselves. You should ask your system administrator about this."
""
msgstr ""
"As origens deste destino são passadas para o sistema de exportação compilado "
"em <application> PMake </ application>. Alguns sistemas usarão essas fontes "
"para se configurar. Você deve perguntar ao seu administrador do sistema "
"sobre isso."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2487 book.translate.xml:2615
#, fuzzy
msgid ".IGNORE"
msgstr ".IGNORAR"

#. (itstool) path: row/entry
#: book.translate.xml:2489
#, fuzzy
msgid ""
"This target marks each of its sources with the <literal>.IGNORE</literal> "
"attribute. If you do not give it any sources, then it is like giving the "
"<option>-i</option> flag when you invoke <application>PMake</application> – "
"errors are ignored for all commands."
msgstr ""
"Este alvo marca cada uma de suas fontes com o <literal> .IGNORE </ literal> "
"atributo. Se você não der nenhuma fonte, é como dar o <option> -i </ option> "
"flag quando você chama <application> PMake </ application> - erros são "
"ignorados para todos os comandos."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2498 book.translate.xml:2542
#, fuzzy
msgid ".INCLUDES"
msgstr ". INCLUI"

#. (itstool) path: para/buildtarget
#. (itstool) path: entry/buildtarget
#: book.translate.xml:2506 book.translate.xml:2589 book.translate.xml:2605
#: book.translate.xml:2901 book.translate.xml:2912 book.translate.xml:2916
#, fuzzy
msgid ".PATH"
msgstr ".CAMINHO"

#. (itstool) path: para/programlisting
#: book.translate.xml:2514
#, fuzzy, no-wrap
msgid ""
".SUFFIXES       : .bitmap\n"
".PATH.bitmap    : /usr/local/X/lib/bitmaps\n"
".INCLUDES       : .bitmap"
msgstr ""
".SUFFIXES: .bitmap \\ n .PATH.bitmap: / usr / local / X / lib / bitmaps \\ n "
". INCLUI: .bitmap"

#. (itstool) path: para/programlisting
#: book.translate.xml:2523
#, fuzzy, no-wrap
msgid "cc $(.INCLUDES) -c xprogram.c"
msgstr "cc $ (. INCLUI) -c xprogram.c"

#. (itstool) path: entry/para
#: book.translate.xml:2500
#, fuzzy
msgid ""
"The sources for this target are taken to be suffixes that indicate a file "
"that can be included in a program source file. The suffix must have already "
"been declared with <literal>.SUFFIXES</literal> (see below). Any suffix so "
"marked will have the directories on its search path (see <_:buildtarget-1/>, "
"below) placed in the <varname>.INCLUDES</varname> variable, each preceded by "
"a <option>-I</option> flag. This variable can then be used as an argument "
"for the compiler in the normal fashion. The <filename>.h</filename> suffix "
"is already marked in this way in the system makefile. E.g. if you have <_:"
"programlisting-2/> <application>PMake</application> will place <literal>-I/"
"usr/local/X/lib/bitmaps</literal> in the <varname>.INCLUDES</varname> "
"variable and you can then say <_:programlisting-3/> (Note: the <varname>."
"INCLUDES</varname> variable is not actually filled in until the entire "
"makefile has been read.)"
msgstr ""
"As origens desse destino são consideradas sufixos que indicam um arquivo que "
"pode ser incluído em um arquivo de origem do programa. O sufixo deve ter já "
"foi declarado com <literal> .SUFFIXES </ literal> (veja abaixo). Qualquer "
"sufixo assim marcado terá os diretórios em seu caminho de busca (veja <_: "
"buildtarget-1 />, abaixo) colocados na variável <varname> .INCLUDES </ "
"varname>, cada um precedido por um sinalizador <option> -I </ option>. Esta "
"variável pode então ser usada como um argumento para o compilador da maneira "
"normal. O sufixo <filename> .h </ filename> já está marcado dessa maneira no "
"makefile do sistema. Por exemplo. se você tiver <_: programlisting-2 /> "
"<application> PMake </ application> colocará <literal> -I / usr / local / X /"
" lib / bitmaps </ literal> no <varname> .INCLUDES </ varname> variável e "
"você pode então dizer <_: programlisting-3 /> (Nota: o <varname>. INCLUDES </"
" varname> a variável não é preenchida até que toda a makefile foi lido.)"

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2531
#, fuzzy
msgid ".INTERRUPT"
msgstr ".INTERROMPER"

#. (itstool) path: row/entry
#: book.translate.xml:2533
#, fuzzy
msgid ""
"When <application>PMake</application> is interrupted, it will execute the "
"commands in the script for this target, if it exists."
msgstr ""
"Quando o <application> PMake </ application> é interrompido, ele executará o "
"comandos no script para este destino, se existir."

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2539 book.translate.xml:3009
#, fuzzy
msgid ".LIBS"
msgstr ".LIBS"

#. (itstool) path: row/entry
#: book.translate.xml:2541
#, fuzzy
msgid ""
"This does for libraries what <_:buildtarget-1/> does for include files, "
"except the flag used is <option>-L</option>, as required by those linkers "
"that allow you to tell them where to find libraries. The variable used is "
"<varname>.LIBS</varname>. Be forewarned that <application>PMake</"
"application> may not have been compiled to do this if the linker on your "
"system does not accept the <option>-L</option> flag, though the <varname>."
"LIBS</varname> variable will always be defined once the makefile has been "
"read."
msgstr ""
"Isso faz para as bibliotecas o que <_: buildtarget-1 /> faz para incluir "
"arquivos, exceto que o sinalizador usado é <option> -L </ option>, conforme "
"requerido por esses linkers que permitem que você diga onde encontrar "
"bibliotecas. A variável usada é <varname> .LIBS </ varname>. Esteja avisado "
"que o <application> PMake </ application> pode não ter sido compilado para "
"fazer isso se o linker em seu O sistema não aceita o sinalizador <option> -L "
"</ option>, embora o <varname>. Variável LIBS </ varname> será sempre "
"definida assim que o makefile tiver sido ler."

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2556 book.translate.xml:3178 book.translate.xml:3180
#: book.translate.xml:3774
#, fuzzy
msgid ".MAIN"
msgstr ".A PRINCIPAL"

#. (itstool) path: row/entry
#: book.translate.xml:2558
#, fuzzy
msgid ""
"If you did not give a target (or targets) to create when you invoked "
"<application>PMake</application>, it will take the sources of this target as "
"the targets to create."
msgstr ""
"Se você não deu um alvo (ou metas) para criar quando você invocou "
"<application> PMake </ application>, ele pegará as origens dessa meta como "
"os alvos para criar."

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2566 book.translate.xml:3656
#, fuzzy
msgid ".MAKEFLAGS"
msgstr ".MAKEFLAGS"

#. (itstool) path: row/entry
#: book.translate.xml:2568
#, fuzzy
msgid ""
"This target provides a way for you to always specify flags for "
"<application>PMake</application> when the makefile is used. The flags are "
"just as they would be typed to the shell (except you can not use shell "
"variables unless they are in the environment), though the <option>-f</"
"option> and <option>-r</option> flags have no effect."
msgstr ""
"Este alvo fornece uma maneira de você sempre especificar flags para "
"<application> PMake </ application> quando o makefile é usado. As bandeiras "
"são assim como eles seriam digitados no shell (exceto que você não pode usar "
"shell variáveis, a menos que estejam no ambiente), embora a <option> -f </ "
"opção> e <opção> -r </ option> sinalizadores não têm efeito."

#. (itstool) path: row/entry
#: book.translate.xml:2580
#, fuzzy
msgid ""
"This allows you to specify what suffix <application>PMake</application> "
"should pretend a file has if, in fact, it has no known suffix. Only one "
"suffix may be so designated. The last source on the dependency line is the "
"suffix that is used (you should, however, only give one suffix...)."
msgstr ""
"Isso permite que você especifique o sufixo <application> PMake </ "
"application> deve fingir que um arquivo tem, na verdade, não tem sufixo "
"conhecido. Apenas um O sufixo pode ser assim designado. A última fonte na "
"linha de dependência é a sufixo que é usado (você deve, no entanto, dar "
"apenas um sufixo ...)."

#. (itstool) path: row/entry
#: book.translate.xml:2591
#, fuzzy
msgid ""
"If you give sources for this target, <application>PMake</application> will "
"take them as directories in which to search for files it cannot find in the "
"current directory. If you give no sources, it will clear out any directories "
"added to the search path before. Since the effects of this all get very "
"complex, we will leave it till <xref linkend=\"gods\"/> to give you a "
"complete explanation."
msgstr ""
"Se você der fontes para este alvo, o <application> PMake </ application> "
"levá-los como diretórios em que procurar arquivos não pode encontrar no "
"diretório atual. Se você não fornecer fontes, isso limpará todos os "
"diretórios adicionado ao caminho de pesquisa antes. Já que os efeitos disso "
"tudo ficam muito complexo, vamos deixá-lo até <xref linkend = \\ \"gods \\\" "
"/> para dar-lhe um explicação completa."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2602 book.translate.xml:3203
#, fuzzy
msgid ".PATH<replaceable>suffix</replaceable>"
msgstr "Sufixo <caminho> substituível> </ replaceable>"

#. (itstool) path: row/entry
#: book.translate.xml:2604
#, fuzzy
msgid ""
"This does a similar thing to <_:buildtarget-1/>, but it does it only for "
"files with the given suffix. The suffix must have been defined already. Look "
"at Search Paths (<xref linkend=\"searchpaths\"/>) for more information."
msgstr ""
"Isso faz algo semelhante ao <_: buildtarget-1 />, mas só o faz por arquivos "
"com o sufixo fornecido. O sufixo deve ter sido definido já. Veja em Caminhos "
"de pesquisa (<xref linkend = \\ \"searchpaths \\\" />) para obter mais "
"informações."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2613
#, fuzzy
msgid ".PRECIOUS"
msgstr ".PRECIOSO"

#. (itstool) path: row/entry
#: book.translate.xml:2615
#, fuzzy
msgid ""
"Similar to <_:buildtarget-1/>, this gives the <literal>.PRECIOUS</literal> "
"attribute to each source on the dependency line, unless there are no "
"sources, in which case the <literal>.PRECIOUS</literal> attribute is given "
"to every target in the file."
msgstr ""
"Semelhante a <_: buildtarget-1 />, isso dá ao <literal> .PRECIOUS </ "
"literal> atributo para cada fonte na linha de dependência, a menos que não "
"fontes, caso em que o atributo <literal> .PRECIOUS </ literal> é dado para "
"cada alvo no arquivo."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2623
#, fuzzy
msgid ".RECURSIVE"
msgstr ".RECURSIVE"

#. (itstool) path: row/entry
#: book.translate.xml:2625
#, fuzzy
msgid ""
"This target applies the <literal>.MAKE</literal> attribute to all its "
"sources. It does nothing if you do not give it any sources."
msgstr ""
"Este alvo aplica o atributo <literal> .MAKE </ literal> a todos os seus "
"fontes. Não faz nada se você não der nenhuma fonte."

#. (itstool) path: entry/buildtarget
#. (itstool) path: para/buildtarget
#: book.translate.xml:2631 book.translate.xml:3348
#, fuzzy
msgid ".SHELL"
msgstr ".CONCHA"

#. (itstool) path: row/entry
#: book.translate.xml:2633
#, fuzzy
msgid ""
"<application>PMake</application> is not constrained to only using the Bourne "
"shell to execute the commands you put in the makefile. You can tell it some "
"other shell to use with this target. Check out <quote><xref linkend="
"\"ashell\" endterm=\"ashelltitle\"/></quote> (<xref linkend=\"ashell\"/>) "
"for more information."
msgstr ""
"<application> PMake </ application> não está restrito a usar apenas o Bourne "
"shell para executar os comandos que você coloca no makefile. Você pode dizer "
"isso outro shell para usar com este alvo. Confira abaixo <quote> <xref "
"linkend = \\ \"ashell \\ \"endterm = \\\" ashelltitle \\ \"/> </ quote> "
"(<xref linkend = \\\" ashell \\ \"/>) para mais em formação."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2642 book.translate.xml:2645
#, fuzzy
msgid ".SILENT"
msgstr ".SILENT"

#. (itstool) path: row/entry
#: book.translate.xml:2644
#, fuzzy
msgid ""
"When you use <_:buildtarget-1/> as a target, it applies the <literal>."
"SILENT</literal> attribute to each of its sources. If there are no sources "
"on the dependency line, then it is as if you gave <application>PMake</"
"application> the <option>-s</option> flag and no commands will be echoed."
msgstr ""
"Quando você usa <_: buildtarget-1 /> como um destino, ele aplica o <literal>."
" SILENT </ literal> para cada uma das suas fontes. Se não houver fontes na "
"linha de dependência, então é como se você desse <application> PMake </ "
"application> o sinalizador <option> -s </ option> e nenhum comando será "
"ecoado."

#. (itstool) path: entry/buildtarget
#: book.translate.xml:2655 book.translate.xml:2662
#, fuzzy
msgid ".SUFFIXES"
msgstr ".SUFFIXES"

#. (itstool) path: row/entry
#: book.translate.xml:2657
#, fuzzy
msgid ""
"This is used to give new file suffixes for <application>PMake</application> "
"to handle. Each source is a suffix <application>PMake</application> should "
"recognize. If you give a <_:buildtarget-1/> dependency line with no sources, "
"<application>PMake</application> will forget about all the suffixes it knew "
"(this also nukes the null suffix). For those targets that need to have "
"suffixes defined, this is how you do it."
msgstr ""
"Isso é usado para fornecer novos sufixos de arquivo para <application> PMake "
"</ application> lidar. Cada fonte é um sufixo <application> PMake </ "
"application> reconhecer. Se você der uma linha de dependência <_: "
"buildtarget-1 /> sem fontes, <application> PMake </ application> esquecerá "
"todos os sufixos que conheceu (isso também neutraliza o sufixo nulo). Para "
"os alvos que precisam ter Sufixos definidos, é assim que você faz."

#. (itstool) path: section/para
#: book.translate.xml:2673
#, fuzzy
msgid "In addition to these targets, a line of the form:"
msgstr "Além desses alvos, uma linha do formulário:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2675
#, fuzzy, no-wrap
msgid "attribute : sources"
msgstr "atributo: sources"

#. (itstool) path: section/para
#: book.translate.xml:2677
#, fuzzy
msgid "applies the attribute to all the targets listed as sources."
msgstr "aplica o atributo a todos os destinos listados como fontes."

#. (itstool) path: section/title
#: book.translate.xml:2681
#, fuzzy
msgid "Modifying Variable Expansion"
msgstr "Modificando a Expansão Variável"

#. (itstool) path: section/para
#: book.translate.xml:2683
#, fuzzy
msgid ""
"Variables need not always be expanded verbatim. <application>PMake</"
"application> defines several modifiers that may be applied to a variable's "
"value before it is expanded. You apply a modifier by placing it after the "
"variable name with a colon between the two, like so:"
msgstr ""
"As variáveis nem sempre precisam ser expandidas textualmente. <application> "
"PMake </ application> define vários modificadores que podem ser aplicados a "
"uma variável valor antes de ser expandido. Você aplica um modificador "
"colocando-o após o nome da variável com dois pontos entre os dois, assim:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2689
#, fuzzy, no-wrap
msgid "${VARIABLE:modifier}"
msgstr "$ {VARIÁVEL: editar}"

#. (itstool) path: section/para
#: book.translate.xml:2691
#, fuzzy
msgid ""
"Each modifier is a single character followed by something specific to the "
"modifier itself. You may apply as many modifiers as you want – each one is "
"applied to the result of the previous and is separated from the previous by "
"another colon."
msgstr ""
"Cada modificador é um único caractere seguido por algo específico para o "
"modificador em si. Você pode aplicar quantos modificadores quiser - cada um "
"é aplicado ao resultado do anterior e é separado do anterior por outro cólon."
""

#. (itstool) path: section/para
#: book.translate.xml:2697
#, fuzzy
msgid ""
"There are seven ways to modify a variable's expansion, most of which come "
"from the C shell variable modification characters:"
msgstr ""
"Existem sete maneiras de modificar a expansão de uma variável, a maioria das "
"quais vem dos caracteres de modificação da variável da shell C:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2703
#, fuzzy
msgid "<literal>Mpattern</literal>"
msgstr "<literal> Mpattern </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2706
#, fuzzy
msgid ""
"This is used to select only those words (a word is a series of characters "
"that are neither spaces nor tabs) that match the given pattern. The pattern "
"is a wildcard pattern like that used by the shell, where <literal>*</"
"literal> means <literal>0</literal> or more characters of any sort; "
"<literal>?</literal> is any single character; <literal>[abcd]</literal> "
"matches any single character that is either <literal>a</literal>, "
"<literal>b</literal>, <literal>c</literal> or <literal>d</literal> (there "
"may be any number of characters between the brackets); <literal>[0-9]</"
"literal> matches any single character that is between <literal>0</literal> "
"and <literal>9</literal> (i.e. any digit. This form may be freely mixed with "
"the other bracket form), and <literal>\\</literal> is used to escape any of "
"the characters <literal>*</literal>, <literal>?</literal>, <literal>[</"
"literal> or <literal>:</literal>, leaving them as regular characters to "
"match themselves in a word. For example, the system makefile "
"<filename>&lt;makedepend.mk&gt;</filename> uses <literal>$(CFLAGS:M-[ID]*)</"
"literal> to extract all the <option>-I</option> and <option>-D</option> "
"flags that would be passed to the C compiler. This allows it to properly "
"locate include files and generate the correct dependencies."
msgstr ""
"Isso é usado para selecionar apenas essas palavras (uma palavra é uma série "
"de caracteres que não são espaços nem tabulações) que correspondam ao padrão "
"fornecido. O padrão é um padrão curinga como aquele usado pelo shell, onde "
"<literal> * </ literal> significa <literal> 0 </ literal> ou mais caracteres "
"de qualquer tipo; <literal>? </ literal> é qualquer caractere único; "
"<literal> [abcd] </ literal> corresponde a qualquer caractere único que seja "
"<literal> a </ literal>, <literal> b </ literal>, <literal> c </ literal> ou "
"<literal> d </ literal> pode ser qualquer número de caracteres entre os "
"colchetes); <literal> [0-9] </ literal> corresponde a qualquer caractere "
"único que esteja entre <literal> 0 </ literal> e <literal> 9 </ literal> (ou "
"seja, qualquer dígito. Esta forma pode ser livremente misturada com a outra "
"forma de colchetes), e <literal> \\\\ </ literal> é usado para escapar de "
"qualquer os caracteres <literal> * </ literal>, <literal>? </ literal>, "
"<literal> [</ literal> ou <literal>: </ literal>, deixando-os como "
"caracteres regulares para combine-se em uma palavra. Por exemplo, o makefile "
"do sistema <filename> & lt; makedepend.mk & gt; </ filename> usa <literal> $ "
"(CFLAGS: M- [ID] *) </ literal> para extraia todos os sinalizadores <option> "
"-I </ option> e <option> -D </ option> que ser passado para o compilador C. "
"Isso permite localizar corretamente arquivos de inclusão e gerar as "
"dependências corretas."

#. (itstool) path: varlistentry/term
#: book.translate.xml:2736
#, fuzzy
msgid "<literal>Npattern</literal>"
msgstr "<literal> Npattern </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2739
#, fuzzy
msgid ""
"This is identical to <literal>:M</literal> except it substitutes all words "
"that do not match the given pattern."
msgstr ""
"Isto é idêntico ao <literal>: M </ literal> exceto que substitui todas as "
"palavras que não correspondem ao padrão dado."

#. (itstool) path: varlistentry/term
#: book.translate.xml:2746
#, fuzzy
msgid "<literal>S/search-string/replacement-string/[g]</literal>"
msgstr ""
"<literal> S / string de pesquisa / string de substituição / [g] </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2749
#, fuzzy
msgid ""
"Causes the first occurrence of search-string in the variable to be replaced "
"by replacement-string, unless the <option>g</option> flag is given at the "
"end, in which case all occurrences of the string are replaced. The "
"substitution is performed on each word in the variable in turn. If search-"
"string begins with a <literal>^</literal>, the string must match starting at "
"the beginning of the word. If search-string ends with a <literal>$</"
"literal>, the string must match to the end of the word (these two may be "
"combined to force an exact match). If a backslash precedes these two "
"characters, however, they lose their special meaning. Variable expansion "
"also occurs in the normal fashion inside both the search-string and the "
"replacement-string, except that a backslash is used to prevent the expansion "
"of a <literal>$</literal>, not another dollar sign, as is usual. Note that "
"search-string is just a string, not a pattern, so none of the usual "
"regularexpression/wildcard characters have any special meaning save "
"<literal>^</literal> and <literal>$</literal>. In the replacement string, "
"the <literal>&amp;</literal> character is replaced by the search-string "
"unless it is preceded by a backslash. You are allowed to use any character "
"except colon or exclamation point to separate the two strings. This so-"
"called delimiter character may be placed in either string by preceding it "
"with a backslash."
msgstr ""
"Faz com que a primeira ocorrência da string de pesquisa na variável seja "
"substituída por cadeia de substituição, a menos que o sinalizador <option> g "
"</ option> seja fornecido no end, em cujo caso todas as ocorrências da "
"string são substituídas. o substituição é realizada em cada palavra da "
"variável, por sua vez. Se procurar string começa com um <literal> ^ </ "
"literal>, a string deve corresponder a partir de o começo da palavra. Se "
"string de pesquisa terminar com um <literal> $ </ literal>, a cadeia deve "
"corresponder ao final da palavra (estes dois podem ser combinado para forçar "
"uma correspondência exata). Se uma barra invertida precede esses dois "
"personagens, no entanto, eles perdem o seu significado especial. Expansão "
"variável também ocorre da maneira normal dentro da cadeia de pesquisa e do "
"cadeia de substituição, exceto que uma barra invertida é usada para impedir "
"a expansão de um <literal> $ </ literal>, não outro sinal de dólar, como é "
"habitual. Observe que search-string é apenas uma string, não um padrão, "
"então nada do usual Os caracteres de expressão regular / curingas têm algum "
"significado especial para salvar <literal> ^ </ literal> e <literal> $ </ "
"literal>. Na cadeia de substituição, o caractere <literal> & amp; </ "
"literal> é substituído pela string de pesquisa a menos que seja precedido "
"por uma barra invertida. Você tem permissão para usar qualquer personagem "
"exceto dois-pontos ou ponto de exclamação para separar as duas sequências. "
"Este so- o caractere delimitador chamado pode ser colocado em qualquer uma "
"das linhas precedendo-o com uma barra invertida."

#. (itstool) path: varlistentry/term
#: book.translate.xml:2780
#, fuzzy
msgid "<literal>T</literal>"
msgstr "<literal> T </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2783
#, fuzzy
msgid ""
"Replaces each word in the variable expansion by its last component (its "
"<quote>tail</quote>). For example, given:"
msgstr ""
"Substitui cada palavra na expansão da variável pelo seu último componente "
"(seu <quote> final </ quote>). Por exemplo, dado:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:2787
#, fuzzy, no-wrap
msgid "OBJS = ../lib/a.o b /usr/lib/libm.a\n"
"TAILS = $(OBJS:T)"
msgstr "OBJS = ../lib/a.o b /usr/lib/libm.a\\n TAILS = $ (OBJS: T)"

#. (itstool) path: listitem/para
#: book.translate.xml:2790
#, fuzzy
msgid ""
"the variable <varname>TAILS</varname> would expand to <literal>a.o b libm.a."
"</literal>"
msgstr ""
"a variável <varname> TAILS </ varname> seria expandida para <literal> a.o b "
"libm.a. </ literal>"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2796
#, fuzzy
msgid "<literal>H</literal>"
msgstr "<literal> H </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2799
#, fuzzy
msgid ""
"This is similar to <literal>:T</literal>, except that every word is replaced "
"by everything but the tail (the <quote>head</quote>). Using the same "
"definition of <varname>OBJS</varname>, the string <literal>$(OBJS:H)</"
"literal> would expand to <literal>../lib /usr/lib.</literal> Note that the "
"final slash on the heads is removed and anything without a head is replaced "
"by the empty string."
msgstr ""
"Isso é semelhante a <literal>: T </ literal>, exceto que cada palavra é "
"substituída por tudo menos a cauda (o <quote> head </ quote>). Usando o "
"mesmo definição de <varname> OBJS </ varname>, a cadeia <literal> $ (OBJS: "
"H) </ literal> expandiria para <literal> ../ lib / usr / lib. </ literal> a "
"barra final nas cabeças é removida e qualquer coisa sem a cabeça é "
"substituída pela corda vazia."

#. (itstool) path: varlistentry/term
#: book.translate.xml:2811
#, fuzzy
msgid "<literal>E</literal>"
msgstr "<literal> E </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2814
#, fuzzy
msgid ""
"<literal>:E</literal> replaces each word by its suffix (<quote>extension</"
"quote>). So <literal>$(OBJS:E)</literal> would give you <literal>.o .a.</"
"literal>"
msgstr ""
"<literal>: E </ literal> substitui cada palavra pelo sufixo (<quote> "
"extensão </ citação>). Então <literal> $ (OBJS: E) </ literal> lhe daria "
"<literal> .o .a. </ literal>"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2822
#, fuzzy
msgid "<literal>R</literal>"
msgstr "<literal> R </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:2825
#, fuzzy
msgid ""
"This replaces each word by everything but the suffix (the <quote>root</"
"quote> of the word). <literal>$(OBJS:R)</literal> expands to <literal>../lib/"
"a b /usr/lib/libm</literal>."
msgstr ""
"Isso substitui cada palavra por tudo, menos o sufixo (a raiz <quote> </ "
"citação> da palavra). <literal> $ (OBJS: R) </ literal> expande para "
"<literal> ../ lib / um b / usr / lib / libm </ literal>."

#. (itstool) path: section/para
#: book.translate.xml:2833
#, fuzzy
msgid ""
"In addition, the System V style of substitution is also supported. This "
"looks like:"
msgstr ""
"Além disso, o estilo de substituição do System V também é suportado. este "
"parece:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2836
#, fuzzy, no-wrap
msgid "$(VARIABLE:search-string=replacement)"
msgstr "$ (VARIABLE: string de pesquisa = substituição)"

#. (itstool) path: section/para
#: book.translate.xml:2838
#, fuzzy
msgid ""
"It must be the last modifier in the chain. The search is anchored at the end "
"of each word, so only suffixes or whole words may be replaced."
msgstr ""
"Deve ser o último modificador da cadeia. A busca está ancorada no final de "
"cada palavra, apenas sufixos ou palavras inteiras podem ser substituídos."

#. (itstool) path: section/title
#: book.translate.xml:2844
#, fuzzy
msgid "More Exercises"
msgstr "Mais exercícios"

#. (itstool) path: section/bridgehead
#. (itstool) path: chapter/bridgehead
#: book.translate.xml:2846 book.translate.xml:3829
#, fuzzy
msgid "Exercise 3.1"
msgstr "Exercício 3.1"

#. (itstool) path: section/para
#: book.translate.xml:2848
#, fuzzy
msgid ""
"You have got a set programs, each of which is created from its own assembly-"
"language source file (suffix <filename>.asm</filename>). Each program can be "
"assembled into two versions, one with error-checking code assembled in and "
"one without. You could assemble them into files with different suffixes "
"(<filename>.eobj</filename> and <filename>.obj</filename>, for instance), "
"but your linker only understands files that end in <filename>.obj</filename>."
" To top it all off, the final executables must have the suffix <filename>."
"exe</filename>. How can you still use transformation rules to make your life "
"easier (Hint: assume the errorchecking versions have ec tacked onto their "
"prefix)?"
msgstr ""
"Você tem um conjunto de programas, cada um dos quais é criado a partir de "
"sua própria arquivo de origem da linguagem (sufixo <nome do arquivo> .asm </ "
"filename>). Cada programa pode ser montado em duas versões, uma com código "
"de verificação de erros montado em e um sem. Você poderia montá-los em "
"arquivos com sufixos diferentes (<nome do arquivo> .eobj </ filename> e "
"<nome do arquivo> .obj </ filename>, por exemplo), mas seu vinculador só "
"entende arquivos que terminam em <nome_do_arquivo> .obj </ nome do arquivo>. "
"Para completar, os executáveis finais devem ter o sufixo <filename> .exe </ "
"filename>. Como você ainda pode usar regras de transformação para facilite a "
"sua vida (Dica: suponha que as versões errorchecking tenham ec colado em seu "
"prefixo)?"

#. (itstool) path: section/bridgehead
#: book.translate.xml:2861
#, fuzzy
msgid "Exercise 3.2"
msgstr "Exercício 3.2"

#. (itstool) path: section/para
#: book.translate.xml:2863
#, fuzzy
msgid ""
"Assume, for a moment or two, you want to perform a sort of "
"<quote>indirection</quote> by placing the name of a variable into another "
"one, then you want to get the value of the first by expanding the second "
"somehow. Unfortunately, <application>PMake</application> does not allow "
"constructs like:"
msgstr ""
"Suponha, por um momento ou dois, que você queira realizar uma espécie de "
"<quote> indirection </ quote> colocando o nome de uma variável em outra um, "
"então você quer obter o valor do primeiro expandindo o segundo de alguma "
"forma. Infelizmente, <application> PMake </ application> não permite "
"construtos como:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2869
#, fuzzy, no-wrap
msgid "$($(FOO))"
msgstr "$ ($ (FOO))"

#. (itstool) path: section/para
#: book.translate.xml:2871
#, fuzzy
msgid ""
"What do you do? Hint: no further variable expansion is performed after "
"modifiers are applied, thus if you cause a <literal>$</literal> to occur in "
"the expansion, that is what will be in the result."
msgstr ""
"O que você faz? Dica: nenhuma outra expansão de variável é executada após "
"modificadores são aplicados, portanto, se você causar um <literal> $ </ "
"literal> para ocorrer em a expansão, é isso que estará no resultado."

#. (itstool) path: chapter/title
#: book.translate.xml:2883
#, fuzzy
msgid "PMake for Gods"
msgstr "PMake para os deuses"

#. (itstool) path: chapter/para
#: book.translate.xml:2885
#, fuzzy
msgid ""
"This chapter is devoted to those facilities in <application>PMake</"
"application> that allow you to do a great deal in a makefile with very "
"little work, as well as do some things you could not do in "
"<application>Make</application> without a great deal of work (and perhaps "
"the use of other programs). The problem with these features, is they must be "
"handled with care, or you will end up with a mess."
msgstr ""
"Este capítulo é dedicado às instalações em <application> PMake </ aplicação> "
"que permitem que você faça muito em um makefile com muito pouco trabalho, "
"bem como fazer algumas coisas que você não poderia fazer em <application> "
"Make </ application> sem muito trabalho (e talvez o uso de outros programas)."
" O problema com esses recursos, eles devem ser manuseado com cuidado, ou "
"você vai acabar com uma bagunça."

#. (itstool) path: chapter/para
#: book.translate.xml:2893
#, fuzzy
msgid ""
"Once more, I assume a greater familiarity with <trademark class="
"\"registered\">UNIX</trademark> or Sprite than I did in the previous two "
"chapters."
msgstr ""
"Mais uma vez, assumo uma maior familiaridade com <trademark class = \\ "
"\"registered \\ \"> UNIX </ trademark> ou Sprite do que eu fiz nos dois "
"capítulos anteriores."

#. (itstool) path: section/title
#: book.translate.xml:2897
#, fuzzy
msgid "Search Paths"
msgstr "Caminhos de pesquisa"

#. (itstool) path: section/para
#: book.translate.xml:2899
#, fuzzy
msgid ""
"<application>PMake</application> supports the dispersal of files into "
"multiple directories by allowing you to specify places to look for sources "
"with <_:buildtarget-1/> targets in the makefile. The directories you give as "
"sources for these targets make up a <quote>search path</quote>. Only those "
"files used exclusively as sources are actually sought on a search path, the "
"assumption being that anything listed as a target in the makefile can be "
"created by the makefile and thus should be in the current directory."
msgstr ""
"<application> PMake </ application> suporta a dispersão de arquivos em "
"vários diretórios, permitindo que você especifique locais para procurar "
"fontes com os destinos <_: buildtarget-1 /> no makefile. Os diretórios que "
"você dá como as fontes para esses destinos formam um caminho de pesquisa "
"<quote> </ quote>. Só aqueles arquivos usados exclusivamente como fontes são "
"procurados em um caminho de suposição sendo que qualquer coisa listada como "
"um alvo no makefile pode ser criado pelo makefile e, portanto, deve estar no "
"diretório atual."

#. (itstool) path: section/para
#: book.translate.xml:2909
#, fuzzy
msgid ""
"There are two types of search paths in <application>PMake</application>: one "
"is used for all types of files (including included makefiles) and is "
"specified with a plain <_:buildtarget-1/> target (e.g. <literal>.PATH : RCS</"
"literal>), while the other is specific to a certain type of file, as "
"indicated by the file's suffix. A specific search path is indicated by "
"immediately following the <_:buildtarget-2/> with the suffix of the file. "
"For instance:"
msgstr ""
"Existem dois tipos de caminhos de pesquisa no <application> PMake </ "
"application>: um é usado para todos os tipos de arquivos (incluindo "
"makefiles incluídos) e é especificado com um destino simples <_: buildtarget-"
"1 /> (por exemplo, <literal> .PATH: RCS </ literal>), enquanto o outro é "
"específico para um determinado tipo de arquivo, como indicado pelo sufixo do "
"arquivo. Um caminho de pesquisa específico é indicado por imediatamente após "
"o <_: buildtarget-2 /> com o sufixo do arquivo. Por exemplo:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2919
#, fuzzy, no-wrap
msgid ".PATH.h         : /sprite/lib/include /sprite/att/lib/include"
msgstr ".PATH.h: / sprite / lib / incluir / sprite / att / lib / include"

#. (itstool) path: section/para
#: book.translate.xml:2921
#, fuzzy
msgid ""
"would tell <application>PMake</application> to look in the directories "
"<filename>/sprite/lib/include</filename> and <filename>/sprite/att/lib/"
"include</filename> for any files whose suffix is <filename>.h</filename>."
msgstr ""
"diria <application> PMake </ application> para procurar nos diretórios <nome "
"do arquivo> / sprite / lib / include </ filename> e <nome do arquivo> / "
"sprite / att / lib / inclua </ filename> para quaisquer arquivos cujo sufixo "
"seja <filename> .h </ filename>."

#. (itstool) path: section/para
#: book.translate.xml:2926
#, fuzzy
msgid ""
"The current directory is always consulted first to see if a file exists. "
"Only if it cannot be found there are the directories in the specific search "
"path, followed by those in the general search path, consulted."
msgstr ""
"O diretório atual é sempre consultado primeiro para ver se existe um arquivo."
" Somente se não for encontrado, existem os diretórios na busca específica "
"caminho, seguido por aqueles no caminho de pesquisa geral, consultado."

#. (itstool) path: section/para
#: book.translate.xml:2931
#, fuzzy
msgid ""
"A search path is also used when expanding wildcard characters. If the "
"pattern has a recognizable suffix on it, the path for that suffix will be "
"used for the expansion. Otherwise the default search path is employed."
msgstr ""
"Um caminho de pesquisa também é usado ao expandir caracteres curinga. Se o "
"padrão tem um sufixo reconhecível, o caminho para esse sufixo será usado "
"para a expansão. Caso contrário, o caminho de pesquisa padrão é empregado."

#. (itstool) path: section/para
#: book.translate.xml:2936
#, fuzzy
msgid ""
"When a file is found in some directory other than the current one, all local "
"variables that would have contained the target's name (<varname>.ALLSRC</"
"varname>, and <varname>.IMPSRC</varname>) will instead contain the path to "
"the file, as found by <application>PMake</application>. Thus if you have a "
"file <filename>../lib/mumble.c</filename> and a makefile like this:"
msgstr ""
"Quando um arquivo é encontrado em algum diretório diferente do atual, todos "
"os variáveis que teriam contido o nome do alvo (<varname> .ALLSRC </ "
"varname> e <varname> .IMPSRC </ varname>) conterão o caminho para o arquivo, "
"conforme encontrado por <application> PMake </ application>. Assim, se você "
"tem um file <filename> ../ lib / mumble.c </ filename> e um makefile como "
"este:"

#. (itstool) path: section/programlisting
#: book.translate.xml:2945
#, fuzzy, no-wrap
msgid ""
".PATH.c         : ../lib\n"
"mumble          : mumble.c\n"
"\t$(CC) -o $(.TARGET) $(.ALLSRC)"
msgstr ""
".PATH.c: ../lib\\n resmungar: mumble.c \\ n \\ t $ (CC) -o $ (. TARGET) $ (. "
"ALLSRC)"

#. (itstool) path: section/para
#: book.translate.xml:2949
#, fuzzy
msgid ""
"the command executed to create mumble would be <command>cc -o mumble ../lib/"
"mumble.c.</command> (as an aside, the command in this case is not strictly "
"necessary, since it will be found using transformation rules if it is not "
"given. This is because <filename>.out</filename> is the null suffix by "
"default and a transformation exists from <filename>.c</filename> to "
"<filename>.out</filename>. Just thought I would throw that in). If a file "
"exists in two directories on the same search path, the file in the first "
"directory on the path will be the one <application>PMake</application> uses. "
"So if you have a large system spread over many directories, it would behoove "
"you to follow a naming convention that avoids such conflicts."
msgstr ""
"o comando executado para criar o murmúrio seria <command> cc -o mumble ../"
"lib/ mumble.c. </ command> (como um aparte, o comando neste caso não é "
"estritamente necessário, pois ele será encontrado usando regras de "
"transformação se não for dado. Isso ocorre porque <filename> .out </ "
"filename> é o sufixo null de padrão e existe uma transformação de <nome do "
"arquivo> .c </ filename> para <nome do arquivo> .out </ filename>. Apenas "
"pensei em jogar isso dentro). Se um arquivo existe em dois diretórios no "
"mesmo caminho de pesquisa, o arquivo no primeiro O diretório no caminho será "
"o usado pelo <application> PMake </ application>. Então, se você tem um "
"grande sistema espalhado por muitos diretórios, seria conveniente você siga "
"uma convenção de nomenclatura que evite tais conflitos."

#. (itstool) path: section/para
#: book.translate.xml:2964
#, fuzzy
msgid ""
"Something you should know about the way search paths are implemented is that "
"each directory is read, and its contents cached, exactly once – when it is "
"first encountered – so any changes to the directories while "
"<application>PMake</application> is running will not be noted when searching "
"for implicit sources, nor will they be found when <application>PMake</"
"application> attempts to discover when the file was last modified, unless "
"the file was created in the current directory. While people have suggested "
"that <application>PMake</application> should read the directories each time, "
"my experience suggests that the caching seldom causes problems. In addition, "
"not caching the directories slows things down enormously because of "
"<application>PMake</application>'s attempts to apply transformation rules "
"through non-existent files – the number of extra file-system searches is "
"truly staggering, especially if many files without suffixes are used and the "
"null suffix is not changed from <filename>.out</filename>."
msgstr ""
"Algo que você deve saber sobre a maneira como os caminhos de busca são "
"implementados é que cada diretório é lido e seu conteúdo armazenado em "
"cache, exatamente uma vez - quando é primeiro encontrado - por isso, "
"quaisquer alterações nos diretórios enquanto <application> PMake </ "
"application> está em execução não será observado ao pesquisar para fontes "
"implícitas, nem serão encontradas quando <application> PMake </ application> "
"tenta descobrir quando o arquivo foi modificado pela última vez, a menos que "
"o arquivo foi criado no diretório atual. Enquanto as pessoas sugeriram que "
"<application> PMake </ application> deve ler os diretórios a cada vez, minha "
"experiência sugere que o cache raramente causa problemas. Além do que, além "
"do mais, não armazenar em cache os diretórios diminui as coisas enormemente "
"por causa de <application> PMake </ application> tenta aplicar regras de "
"transformação através de arquivos inexistentes - o número de pesquisas "
"extras no sistema de arquivos é verdadeiramente desconcertante, "
"especialmente se muitos arquivos sem sufixos forem usados e O sufixo nulo "
"não é alterado de <nome do arquivo> .out </ filename>."

#. (itstool) path: section/title
#: book.translate.xml:2984
#, fuzzy
msgid "Archives and Libraries"
msgstr "Arquivos e Bibliotecas"

#. (itstool) path: section/para
#: book.translate.xml:2986
#, fuzzy
msgid ""
"<trademark class=\"registered\">UNIX</trademark> and Sprite allow you to "
"merge files into an archive using the <command>ar</command> command. "
"Further, if the files are relocatable object files, you can run "
"<application>ranlib</application> on the archive and get yourself a library "
"that you can link into any program you want. The main problem with archives "
"is they double the space you need to store the archived files, since there "
"is one copy in the archive and one copy out by itself. The problem with "
"libraries is you usually think of them as <option>-lm</option> rather than "
"<filename>/usr/lib/libm.a</filename> and the linker thinks they are out-of-"
"date if you so much as look at them."
msgstr ""
"<trademark class = \\ \"registered \\\"> UNIX </ trademark> e Sprite "
"permitem que você mesclar arquivos em um arquivo usando o comando <command> "
"ar </ command>. Além disso, se os arquivos forem arquivos de objetos "
"relocáveis, você poderá executar <application> ranlib </ application> no "
"arquivo e obtenha uma biblioteca que você pode ligar em qualquer programa "
"que você deseja. O principal problema com arquivos eles duplicam o espaço "
"necessário para armazenar os arquivos arquivados, pois é uma cópia no "
"arquivo e uma cópia por si só. O problema com bibliotecas é geralmente você "
"pensa nelas como <option> -lm </ option> em vez de <filename> /usr/lib/libm."
"a </ filename> e o linker acha que eles estão fora de Data, se você tanto "
"como olhar para eles."

#. (itstool) path: section/para
#: book.translate.xml:2998
#, fuzzy
msgid ""
"<application>PMake</application> solves the problem with archives by "
"allowing you to tell it to examine the files in the archives (so you can "
"remove the individual files without having to regenerate them later). To "
"handle the problem with libraries, <application>PMake</application> adds an "
"additional way of deciding if a library is out-of-date: if the table of "
"contents is older than the library, or is missing, the library is out-of-"
"date."
msgstr ""
"<application> PMake </ application> resolve o problema com arquivos por "
"permitindo que você diga para examinar os arquivos nos arquivos (assim você "
"pode remova os arquivos individuais sem precisar regenerá-los "
"posteriormente). Para lidar com o problema com bibliotecas, <application> "
"PMake </ application> adiciona um forma adicional de decidir se uma "
"biblioteca está desatualizada: se a tabela de conteúdo é mais antigo que a "
"biblioteca, ou está faltando, a biblioteca está fora de encontro."

#. (itstool) path: section/para
#: book.translate.xml:3007
#, fuzzy
msgid ""
"A library is any target that looks like <option>-lname</option> or that ends "
"in a suffix that was marked as a library using the <_:buildtarget-1/> target."
" <filename>.a</filename> is so marked in the system makefile. Members of an "
"archive are specified as <literal>archive(member[member...])</literal>. Thus "
"<literal>libdix.a(window.o)</literal> specifies the file <filename>window.o</"
"filename> in the archive <filename>libdix.a</filename>. You may also use "
"wildcards to specify the members of the archive. Just remember that most the "
"wildcard characters will only find existing files. A file that is a member "
"of an archive is treated specially. If the file does not exist, but it is in "
"the archive, the modification time recorded in the archive is used for the "
"file when determining if the file is out-of-date. When figuring out how to "
"make an archived member target (not the file itself, but the file in the "
"archive – the archive(member) target), special care is taken with the "
"transformation rules, as follows:"
msgstr ""
"Uma biblioteca é qualquer destino que se parece com <option> -lname </ "
"option> ou que termina em um sufixo que foi marcado como uma biblioteca "
"usando o <_: buildtarget-1 /> alvo. <nome_do_arquivo> .a </ filename> é tão "
"marcado no makefile do sistema. Membros de um arquivo são especificados como "
"<literal> archive (membro [membro ...]) </ literal>. Assim, <literal> libdix."
"a (window.o) </ literal> especifica o arquivo <filename> window.o </ "
"filename> no arquivo <filename> libdix.a </ filename>. Você também pode usar "
"curingas para especificar os membros do arquivo. Somente lembre-se de que a "
"maioria dos caracteres curinga encontrará apenas arquivos existentes. UMA "
"arquivo que é um membro de um arquivo é tratado especialmente. Se o arquivo "
"não não existe, mas está no arquivo, o tempo de modificação registrado no "
"archive é usado para o arquivo ao determinar se o arquivo está desatualizado."
" Ao descobrir como criar um destino de membro arquivado (não o arquivo em "
"si, mas o arquivo no arquivo - o destino do arquivo (membro)), especial "
"cuidado é tomado com as regras de transformação, como segue:"

#. (itstool) path: listitem/para
#: book.translate.xml:3028
#, fuzzy
msgid "archive(member) is made to depend on member."
msgstr "o arquivo (membro) é feito para depender do membro."

#. (itstool) path: listitem/para
#: book.translate.xml:3032
#, fuzzy
msgid ""
"The transformation from the member's suffix to the archive's suffix is "
"applied to the archive(member) target."
msgstr ""
"A transformação do sufixo do membro para o sufixo do arquivo é aplicado ao "
"destino de arquivamento (membro)."

#. (itstool) path: listitem/para
#: book.translate.xml:3037
#, fuzzy
msgid ""
"The archive(member)'s <varname>.TARGET</varname> variable is set to the name "
"of the member if member is actually a target, or the path to the member file "
"if member is only a source."
msgstr ""
"A variável <varname> .TARGET </ varname> do archive (membro) é configurada "
"para o nome do membro se membro for realmente um destino ou o caminho para o "
"arquivo de membro se membro é apenas uma fonte."

#. (itstool) path: listitem/para
#: book.translate.xml:3044
#, fuzzy
msgid ""
"The <varname>.ARCHIVE</varname> variable for the archive(member) target is "
"set to the name of the archive."
msgstr ""
"A variável <varname> .ARCHIVE </ varigra> para o destino arquivamento "
"(membro) é definido para o nome do arquivo."

#. (itstool) path: listitem/para
#: book.translate.xml:3050
#, fuzzy
msgid ""
"The <varname>.MEMBER</varname> variable is set to the actual string inside "
"the parentheses. In most cases, this will be the same as the <varname>."
"TARGET</varname> variable."
msgstr ""
"A variável <varname> .MEMBER </ varname> está definida para a cadeia real "
"dentro os parênteses. Na maioria dos casos, isso será o mesmo que o "
"<varname>. Variável TARGET </ varname>."

#. (itstool) path: listitem/para
#: book.translate.xml:3057
#, fuzzy
msgid ""
"The archive(member)'s place in the local variables of the targets that "
"depend on it is taken by the value of its <varname>.TARGET</varname> "
"variable."
msgstr ""
"O lugar do arquivo (membro) nas variáveis locais dos alvos que depende dele "
"é tomado pelo valor de seu <varname> .TARGET </ varname> variável."

#. (itstool) path: section/para
#: book.translate.xml:3063
#, fuzzy
msgid "Thus, a program library could be created with the following makefile:"
msgstr ""
"Assim, uma biblioteca de programas pode ser criada com o seguinte makefile:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3066
#, fuzzy, no-wrap
msgid ""
".o.a            :\n"
"\t...\n"
"\trm -f $(.TARGET:T)\n"
"OBJS            = obj1.o obj2.o obj3.o\n"
"libprog.a       : libprog.a($(OBJS))\n"
"\tar cru $(.TARGET) $(.OODATE)\n"
"\tranlib $(.TARGET)"
msgstr ""
".o.a: ... n rm -f $ (. TARGET: T) \\ t OBJS = obj1.o obj2.o obj3.o libprog.a:"
" libprog.a ($ (OBJS)) é cru $ (. TARGET) $ ( tranlib $ (. TARGET)"

#. (itstool) path: section/para
#: book.translate.xml:3074
#, fuzzy
msgid ""
"This will cause the three object files to be compiled (if the corresponding "
"source files were modified after the object file or, if that does not exist, "
"the archived object file), the out-of-date ones archived in "
"<filename>libprog.a</filename>, a table of contents placed in the archive "
"and the newly-archived object files to be removed."
msgstr ""
"Isso fará com que os três arquivos de objetos sejam compilados (se o "
"arquivos de origem foram modificados após o arquivo objeto ou, se isso não "
"existir, o arquivo de objeto arquivado), os arquivos desatualizados "
"arquivados em <filename> libprog.a </ filename>, um índice colocado no "
"arquivo e os arquivos de objeto recém-arquivados a serem removidos."

#. (itstool) path: section/para
#: book.translate.xml:3081
#, fuzzy
msgid ""
"All this is used in the <filename>makelib.mk</filename> system makefile to "
"create a single library with ease. This makefile looks like this:"
msgstr ""
"Tudo isso é usado no makefile do sistema <filename> makelib.mk </ filename> "
"para Crie uma única biblioteca com facilidade. Este makefile tem esta "
"aparência:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3085
#, fuzzy, no-wrap
msgid ""
"#\n"
"# Rules for making libraries. The object files that make up the library\n"
"# are removed once they are archived.\n"
"#\n"
"# To make several libraries in parallel, you should define the variable\n"
"# \"many_libraries\". This will serialize the invocations of ranlib.\n"
"#\n"
"# To use, do something like this:\n"
"#\n"
"# OBJECTS = &lt;files in the library&gt;\n"
"#\n"
"# fish.a: fish.a($(OBJECTS)) MAKELIB\n"
"#\n"
"#\n"
"\n"
"#ifndef _MAKELIB_MK\n"
"_MAKELIB_MK    =\n"
"\n"
"#include  &lt;po.mk&gt;\n"
"\n"
".po.a .o.a     :\n"
"\t...\n"
"\trm -f $(.MEMBER)\n"
"\n"
"ARFLAGS        ?= crl\n"
"\n"
"#\n"
"# Re-archive the out-of-date members and recreate the library's table of\n"
"# contents using ranlib. If many_libraries is defined, put the ranlib\n"
"# off til the end so many libraries can be made at once.\n"
"#\n"
"MAKELIB        : .USE .PRECIOUS\n"
"\tar $(ARFLAGS) $(.TARGET) $(.OODATE)\n"
"#ifndef no_ranlib\n"
"# ifdef many_libraries\n"
"\t...\n"
"# endif many_libraries\n"
"\tranlib $(.TARGET)\n"
"#endif no_ranlib\n"
"\n"
"#endif _MAKELIB_MK"
msgstr ""
"# \\ n # Regras para criar bibliotecas. Os arquivos de objeto que compõem a "
"biblioteca \\ n # são removidos assim que são arquivados. \\ n # \\ n # Para "
"criar várias bibliotecas em paralelo, você deve definir a variável \\ n # \\ "
"\"many_libraries \\\". Isso serializará as invocações do ranlib. \\ N # \\ n "
"# Para usar, faça algo assim: \\ n # \\ n # OBJECTS = & lt; arquivos na "
"biblioteca & gt; \\ n # \\ n # fish.a: fish.a ($ (OBJECTS)) MAKELIB \\ n # "
"\\ n # \\ n \\ n #ifndef _MAKELIB_MK \\ n _MAKELIB_MK = \\ n \\ n #include & "
"lt; po.mk & gt; \\ n \\ n .po.a .o.a: \\ n \\ t ... \\ n \\ trm -f $ (. "
"MEMBER) \\ n \\ n ARFLAGS? = Crl \\ n \\ n # \\ n # Re-arquive os membros "
"desatualizados e recrie a tabela da biblioteca de \\ n # conteúdos usando o "
"ranlib. Se many_libraries for definido, coloque o ranlib \\ n # off até o "
"final, muitas bibliotecas podem ser criadas de uma só vez. \\ n # \\ n "
"MAKELIB: .USE .PRECIOUS \\ n \\ tar $ (ARFLAGS) $ (. TARGET) $ (. OODATE) \\ "
"n #ifndef no_ranlib \\ n # ifdef many_libraries \\ n \\ t ... \\ n # endif "
"many_libraries \\ n \\ tranlib $ (. TARGET) \\ n #endif no_ranlib \\ n \\ n "
"#endif _MAKELIB_MK"

#. (itstool) path: section/title
#: book.translate.xml:3129
#, fuzzy
msgid "On the Condition..."
msgstr "Na condição..."

#. (itstool) path: section/para
#: book.translate.xml:3131
#, fuzzy
msgid ""
"Like the C compiler before it, <application>PMake</application> allows you "
"to configure the makefile, based on the current environment, using "
"conditional statements. A conditional looks like this:"
msgstr ""
"Como o compilador C antes dele, o <application> PMake </ application> "
"permite para configurar o makefile, baseado no ambiente atual, usando "
"declarações condicionais. Uma condicional parece com isso:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3136
#, fuzzy, no-wrap
msgid ""
"#if boolean expression\n"
"lines\n"
"#elif another boolean expression\n"
"more lines\n"
"#else\n"
"still more lines\n"
"#endif"
msgstr ""
"#if expressão booleana \\ n linhas \\ n #elif outra expressão booleana \\ n "
"mais linhas \\ n #else \\ n ainda mais linhas \\ n #fim se"

#. (itstool) path: section/para
#: book.translate.xml:3144
#, fuzzy
msgid ""
"They may be nested to a maximum depth of 30 and may occur anywhere (except "
"in a comment, of course). The <literal>#</literal> must the very first "
"character on the line."
msgstr ""
"Eles podem ser aninhados a uma profundidade máxima de 30 e podem ocorrer em "
"qualquer em um comentário, é claro). O <literal> # </ literal> deve o "
"primeiro personagem na linha."

#. (itstool) path: section/para
#: book.translate.xml:3149
#, fuzzy
msgid ""
"Each boolean expression is made up of terms that look like function calls, "
"the standard C boolean operators <literal>&amp;&amp;</literal>, <literal>||</"
"literal>, and <literal>!</literal>, and the standard relational operators "
"<literal>==</literal>, <literal>!=</literal>, <literal>&gt;</literal>, "
"<literal>&gt;=</literal>, <literal>&lt;</literal>, and <literal>&lt;=</"
"literal>, with <literal>==</literal> and <literal>!=</literal> being "
"overloaded to allow string comparisons as well. <literal>&amp;&amp;</"
"literal> represents logical AND; <literal>||</literal> is logical OR and "
"<literal>!</literal> is logical NOT. The arithmetic and string operators "
"take precedence over all three of these operators, while NOT takes "
"precedence over AND, which takes precedence over OR. This precedence may be "
"overridden with parentheses, and an expression may be parenthesized to your "
"heart's content. Each term looks like a call on one of four functions:"
msgstr ""
"Cada expressão booleana é composta de termos que se parecem com chamadas de "
"função, os operadores booleanos padrão C <literal> & amp; & </ literal>, "
"<literal> || </ literal>, e <literal>! </ literal>, e os operadores "
"relacionais padrão <literal> == </ literal>, <literal>! = </ literal>, "
"<literal> & gt; </ literal>, <literal> & gt; = </ literal>, <literal> & lt; "
"</ literal> e <literal> & lt; = </ literal>, com <literal> == </ literal> e "
"<literal>! = </ literal> sendo sobrecarregado para permitir comparações de "
"strings também. <literal> & amp; & amp; </ literal> representa o AND lógico; "
"<literal> || </ literal> é lógico OR e <literal>! </ literal> é lógico NÃO. "
"Os operadores aritméticos e de string ter precedência sobre todos esses três "
"operadores, enquanto NÃO precedência sobre AND, que tem precedência sobre OR."
" Essa precedência pode ser sobrescritos com parênteses, e uma expressão pode "
"ser parêntese para o seu Conteúdo do coração. Cada termo parece uma chamada "
"em uma das quatro funções:"

#. (itstool) path: row/entry
#: book.translate.xml:3173 book.translate.xml:3282
#, fuzzy
msgid "<literal>make</literal>"
msgstr "<literal> make </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3175
#, fuzzy
msgid ""
"The syntax is make(target) where target is a target in the makefile. This is "
"true if the given target was specified on the command line, or as the source "
"for a <_:buildtarget-1/> target (note that the sources for <_:buildtarget-2/"
"> are only used if no targets were given on the command line)."
msgstr ""
"A sintaxe é make (target), em que target é um destino no makefile. Isto é "
"true se o destino especificado foi especificado na linha de comando ou como "
"a origem para um destino <_: buildtarget-1 /> (observe que as fontes para <_:"
" buildtarget-2 / > são usados somente se nenhum alvo foi dado na linha de "
"comando)."

#. (itstool) path: row/entry
#: book.translate.xml:3186 book.translate.xml:3270
#, fuzzy
msgid "<literal>defined</literal>"
msgstr "<literal> definido </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3188
#, fuzzy
msgid ""
"The syntax is <literal>defined(variable)</literal> and is true if variable "
"is defined. Certain variables are defined in the system makefile that "
"identify the system on which <application>PMake</application> is being run."
msgstr ""
"A sintaxe é <literal> definida (variável) </ literal> e é verdadeira se "
"variável é definido. Certas variáveis são definidas no makefile do sistema "
"que Identifique o sistema no qual o <application> PMake </ application> está "
"sendo executado."

#. (itstool) path: row/entry
#: book.translate.xml:3197
#, fuzzy
msgid "<literal>exists</literal>"
msgstr "<literal> existe </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3199
#, fuzzy
msgid ""
"The syntax is <literal>exists(file)</literal> and is true if the file can be "
"found on the global search path (i.e. that defined by <varname>.PATH</"
"varname> targets, not by <_:buildtarget-1/> targets)."
msgstr ""
"A sintaxe é <literal> exists (arquivo) </ literal> e é verdadeira se o "
"arquivo puder ser encontrado no caminho de pesquisa global (isto é, definido "
"por <varname> .PATH </ varname> targets, não por <_: buildtarget-1 /> "
"targets)."

#. (itstool) path: row/entry
#: book.translate.xml:3208
#, fuzzy
msgid "<literal>empty</literal>"
msgstr "<literal> vazio </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3210
#, fuzzy
msgid ""
"This syntax is much like the others, except the string inside the "
"parentheses is of the same form as you would put between parentheses when "
"expanding a variable, complete with modifiers and everything. The function "
"returns true if the resulting string is empty. An undefined variable in this "
"context will cause at the very least a warning message about a malformed "
"conditional, and at the worst will cause the process to stop once it has "
"read the makefile. If you want to check for a variable being defined or "
"empty, use the expression: <literal>!defined(var) || empty(var)</literal> as "
"the definition of <literal>||</literal> will prevent the <literal>empty()</"
"literal> from being evaluated and causing an error, if the variable is "
"undefined. This can be used to see if a variable contains a given word, for "
"example: <literal>#if !empty(var:Mword)</literal>"
msgstr ""
"Esta sintaxe é muito parecida com as outras, exceto a string dentro da "
"parênteses é da mesma forma que você colocaria entre parênteses quando "
"expandindo uma variável, completa com modificadores e tudo. A função retorna "
"true se a string resultante estiver vazia. Uma variável indefinida neste "
"contexto causará pelo menos uma mensagem de aviso sobre um mal formado "
"condicional e, na pior das hipóteses, fará com que o processo pare quando "
"leia o makefile. Se você quiser verificar se uma variável está sendo "
"definida ou vazio, use a expressão: <literal>! defined (var) || vazio (var) "
"</ literal> como a definição de <literal> || </ literal> irá impedir que o "
"<literal> empty () </ literal> de ser avaliado e causando um erro, se a "
"variável é Indefinido. Isso pode ser usado para ver se uma variável contém "
"uma determinada palavra, exemplo: <literal> #if! empty (var: Mword) </ "
"literal>"

#. (itstool) path: section/para
#: book.translate.xml:3234
#, fuzzy
msgid ""
"The arithmetic and string operators may only be used to test the value of a "
"variable. The lefthand side must contain the variable expansion, while the "
"righthand side contains either a string, enclosed in double-quotes, or a "
"number. The standard C numeric conventions (except for specifying an octal "
"number) apply to both sides. E.g.:"
msgstr ""
"Os operadores aritméticos e de string só podem ser usados para testar o "
"valor de um variável. O lado esquerdo deve conter a expansão variável, "
"enquanto o lado direito contém uma string, entre aspas duplas ou um número. "
"As convenções numéricas padrão C (exceto para especificar um octal número) "
"aplicam-se a ambos os lados. Por exemplo.:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3241
#, fuzzy, no-wrap
msgid ""
"#if $(OS) == 4.3\n"
"\n"
"#if $(MACHINE) == \"sun3\"\n"
"\n"
"#if $(LOAD_ADDR) &gt; 0xc000"
msgstr ""
"#if $ (OS) == 4.3 \\ n \\ n #if $ (MACHINE) == \\ \"sun3 \\\" \\ n \\ n #if "
"$ (LOAD_ADDR) & gt; 0xc000"

#. (itstool) path: section/para
#: book.translate.xml:3247
#, fuzzy
msgid ""
"are all valid conditionals. In addition, the numeric value of a variable can "
"be tested as a boolean as follows:"
msgstr ""
"são todos condicionais válidos. Além disso, o valor numérico de uma variável "
"pode ser testado como um booleano como segue:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3250
#, fuzzy, no-wrap
msgid "#if $(LOAD)"
msgstr "#if $ (LOAD)"

#. (itstool) path: section/para
#: book.translate.xml:3252
#, fuzzy
msgid "would see if <literal>LOAD</literal> contains a non-zero value and:"
msgstr ""
"veria se <literal> LOAD </ literal> contém um valor diferente de zero e:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3255
#, fuzzy, no-wrap
msgid "#if !$(LOAD)"
msgstr "#if! $ (LOAD)"

#. (itstool) path: section/para
#: book.translate.xml:3257
#, fuzzy
msgid "would test if <literal>LOAD</literal> contains a zero value."
msgstr "testaria se <literal> LOAD </ literal> contiver um valor zero."

#. (itstool) path: section/para
#: book.translate.xml:3260
#, fuzzy
msgid ""
"In addition to the bare <literal>#if</literal>, there are other forms that "
"apply one of the first two functions to each term. They are as follows:"
msgstr ""
"Além do nu <literal> #if </ literal>, existem outras formas que aplique uma "
"das duas primeiras funções a cada termo. Eles são os seguintes:"

#. (itstool) path: row/entry
#: book.translate.xml:3268
#, fuzzy
msgid "<literal>ifdef</literal>"
msgstr "<literal> ifdef </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3274
#, fuzzy
msgid "<literal>ifndef</literal>"
msgstr "<literal> ifndef </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3276
#, fuzzy
msgid "<literal>!defined</literal>"
msgstr "<literal>! definido </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3280
#, fuzzy
msgid "<literal>ifmake</literal>"
msgstr "<literal> ifmake </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3286
#, fuzzy
msgid "<literal>ifnmake</literal>"
msgstr "<literal> ifnmake </ literal>"

#. (itstool) path: row/entry
#: book.translate.xml:3288
#, fuzzy
msgid "<literal>!make</literal>"
msgstr "<literal>! make </ literal>"

#. (itstool) path: section/para
#: book.translate.xml:3294
#, fuzzy
msgid ""
"There are also the <quote><literal>else if</literal></quote> forms: "
"<literal>elif</literal>, <literal>elifdef</literal>, <literal>elifndef</"
"literal>, <literal>elifmake</literal>, and <literal>elifnmake</literal>."
msgstr ""
"Existem também os formulários <quote> <literal> else if </ literal> </ "
"quote>: <literal> elif </ literal>, <literal> elifdef </ literal>, <literal> "
"elifndef </ literal>, <literal> elifmake </ literal> e <literal> elifnmake </"
" literal>."

#. (itstool) path: section/para
#: book.translate.xml:3299
#, fuzzy
msgid ""
"For instance, if you wish to create two versions of a program, one of which "
"is optimized (the production version) and the other of which is for "
"debugging (has symbols for dbx), you have two choices: you can create two "
"makefiles, one of which uses the <option>-g</option> flag for the "
"compilation, while the other uses the <option>-O</option> flag, or you can "
"use another target (call it debug) to create the debug version. The "
"construct below will take care of this for you. I have also made it so "
"defining the variable <envar>DEBUG</envar> (say with <command>pmake -D "
"DEBUG</command>) will also cause the debug version to be made."
msgstr ""
"Por exemplo, se você deseja criar duas versões de um programa, uma das quais "
"é otimizado (a versão de produção) e o outro é para depuração (tem símbolos "
"para dbx), você tem duas opções: você pode criar dois makefiles, um dos "
"quais usa o sinalizador <option> -g </ option> para o compilação, enquanto a "
"outra usa o sinalizador <option> -O </ option>, ou você pode use outro "
"destino (chame-o de depuração) para criar a versão de depuração. o construir "
"abaixo vai cuidar disso para você. Eu também fiz isso definindo a variável "
"<envar> DEBUG </ envar> (digamos com <command> pmake -D DEBUG </ command>) "
"também fará com que a versão de depuração seja feita."

#. (itstool) path: section/programlisting
#: book.translate.xml:3311
#, fuzzy, no-wrap
msgid ""
"#if defined(DEBUG) || make(debug)\n"
"CFLAGS         += -g\n"
"#else\n"
"CFLAGS         += -O\n"
"#endif"
msgstr ""
"#if definido (DEBUG) || make (debug) \\ n CFLAGS + = -g \\ n #else \\ n "
"CFLAGS + = -O \\ n #fim se"

#. (itstool) path: section/para
#: book.translate.xml:3317
#, fuzzy
msgid ""
"There are, of course, problems with this approach. The most glaring "
"annoyance is that if you want to go from making a debug version to making a "
"production version, you have to remove all the object files, or you will get "
"some optimized and some debug versions in the same program. Another "
"annoyance is you have to be careful not to make two targets that "
"<quote>conflict</quote> because of some conditionals in the makefile. For "
"instance:"
msgstr ""
"Existem, é claro, problemas com essa abordagem. O mais gritante "
"aborrecimento é que se você quiser ir de fazer uma versão de depuração para "
"fazer um versão de produção, você tem que remover todos os arquivos objeto, "
"ou você vai ter algumas versões otimizadas e algumas de depuração no mesmo "
"programa. Outro aborrecimento é que você tem que ter cuidado para não fazer "
"dois alvos que <quote> conflict </ quote> por causa de algumas condicionais "
"no makefile. Para instância:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3326
#, fuzzy, no-wrap
msgid ""
"#if make(print)\n"
"FORMATTER = ditroff -Plaser_printer\n"
"#endif\n"
"#if make(draft)\n"
"FORMATTER = nroff -Pdot_matrix_printer\n"
"#endif"
msgstr ""
"#if make (print) \\ n FORMATTER = ditroff -Plaser_printer \\ n #endif \\ n "
"#if make (rascunho) \\ n FORMATTER = nroff -Pdot_matrix_printer \\ n #fim se"

#. (itstool) path: section/para
#: book.translate.xml:3333
#, fuzzy
msgid ""
"would wreak havoc if you tried <command>pmake draft print</command> since "
"you would use the same formatter for each target. As I said, this all gets "
"somewhat complicated."
msgstr ""
"iria causar estragos se você tentasse <command> pmake draft print </ "
"command> desde você usaria o mesmo formatador para cada destino. Como eu "
"disse, tudo isso fica um pouco complicado."

#. (itstool) path: section/title
#. (itstool) id: book.translate.xml#ashelltitle
#: book.translate.xml:3339
#, fuzzy
msgid "A Shell is a Shell is a Shell"
msgstr "Uma Shell é uma Shell é uma Shell"

#. (itstool) path: section/para
#: book.translate.xml:3341
#, fuzzy
msgid ""
"In normal operation, the Bourne Shell (better known as <application>sh</"
"application>) is used to execute the commands to re-create targets. "
"<application>PMake</application> also allows you to specify a different "
"shell for it to use when executing these commands. There are several things "
"<application>PMake</application> must know about the shell you wish to use. "
"These things are specified as the sources for the <_:buildtarget-1/> target "
"by keyword, as follows:"
msgstr ""
"Em operação normal, o Bourne Shell (mais conhecido como <application> sh </ "
"application>) é usado para executar os comandos para recriar alvos. "
"<application> PMake </ application> também permite especificar um diferente "
"shell para ele usar ao executar esses comandos. Existem várias coisas O "
"<application> PMake </ application> deve conhecer o shell que você deseja "
"usar. Essas coisas são especificadas como as origens para o destino <_: "
"buildtarget-1 /> por palavra-chave, da seguinte maneira:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:3353
#, fuzzy
msgid "<literal>path=path</literal>"
msgstr "<literal> caminho = caminho </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3356
#, fuzzy
msgid ""
"<application>PMake</application> needs to know where the shell actually "
"resides, so it can execute it. If you specify this and nothing else, "
"<application>PMake</application> will use the last component of the path and "
"look in its table of the shells it knows and use the specification it finds, "
"if any. Use this if you just want to use a different version of the "
"<application>Bourne</application> or <application>C Shell</application> "
"(yes, <application>PMake</application> knows how to use the <application>C "
"Shell</application> too)."
msgstr ""
"<application> PMake </ application> precisa saber onde o shell realmente "
"reside, para que possa executá-lo. Se você especificar isso e nada mais, "
"<application> PMake </ application> usará o último componente do caminho e "
"olha na sua mesa das conchas que conhece e usa a especificação que encontra, "
"caso existam. Use isto se você quiser apenas usar uma versão diferente do "
"<aplicativo> Bourne </ application> ou <aplicativo> C Shell </ application> "
"(sim, <application> PMake </ application> sabe como usar o <application> C "
"Shell </ application> também)."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3371
#, fuzzy
msgid "<literal>name=name</literal>"
msgstr "<literal> nome = nome </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3374
#, fuzzy
msgid ""
"This is the name by which the shell is to be known. It is a single word and, "
"if no other keywords are specified (other than path), it is the name by "
"which <application>PMake</application> attempts to find a specification for "
"it (as mentioned above). You can use this if you would just rather use the C "
"Shell than the <application>Bourne Shell</application> (<literal>.SHELL: "
"name=csh</literal> will do it)."
msgstr ""
"Este é o nome pelo qual o shell deve ser conhecido. É uma única palavra e, "
"se nenhuma outra palavra-chave for especificada (diferente de caminho), é o "
"nome qual <application> PMake </ application> tenta encontrar uma "
"especificação para (como mencionado acima). Você pode usar isso se preferir "
"usar o C Shell do que o <application> Bourne Shell </ application> "
"(<literal> .SHELL: name = csh </ literal> irá fazer isso)."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3386
#, fuzzy
msgid "<literal>quiet=echo-off</literal> command"
msgstr "Comando <literal> quiet = echo-off </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3389
#, fuzzy
msgid ""
"As mentioned before, <application>PMake</application> actually controls "
"whether commands are printed by introducing commands into the shell's input "
"stream. This keyword, and the next two, control what those commands are. The "
"<literal>quiet</literal> keyword is the command used to turn echoing off. "
"Once it is turned off, echoing is expected to remain off until the "
"<literal>echo-on</literal> command is given."
msgstr ""
"Como mencionado anteriormente, <application> PMake </ application> na "
"verdade controla se os comandos são impressos introduzindo comandos na "
"entrada do shell corrente. Esta palavra-chave e as próximas duas controlam "
"quais são esses comandos. o A palavra-chave <literal> quiet </ literal> é o "
"comando usado para desativar o eco. Uma vez desligado, espera-se que o eco "
"permaneça desligado até O comando <literal> echo-on </ literal> é dado."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3401
#, fuzzy
msgid "<literal>echo=echo-on</literal> command"
msgstr "Comando <literal> echo = echo-on </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3404
#, fuzzy
msgid ""
"The command <application>PMake</application> should give to turn echoing "
"back on again."
msgstr ""
"O comando <application> PMake </ application> deve dar para ativar o eco de "
"volta novamente."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3410
#, fuzzy
msgid "<literal>filter=printed echo-off</literal> command"
msgstr "Comando <literal> filter = printed echo-off </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3413
#, fuzzy
msgid ""
"Many shells will echo the <literal>echo-off</literal> command when it is "
"given. This keyword tells <application>PMake</application> in what format "
"the shell actually prints the <literal>echo-off</literal> command. Wherever "
"<application>PMake</application> sees this string in the shell's output, it "
"will delete it and any following whitespace, up to and including the next "
"newline. See the example at the end of this section for more details."
msgstr ""
"Muitas shells irão ecoar o comando <literal> echo-off </ literal> quando "
"dado. Esta palavra-chave informa ao <application> PMake </ application> em "
"qual formato o shell na verdade imprime o comando <literal> echo-off </ "
"literal>. Onde quer que seja <application> PMake </ application> vê essa "
"string na saída do shell, irá apagá-lo e qualquer espaço em branco a seguir, "
"até e incluindo o próximo nova linha. Veja o exemplo no final desta seção "
"para mais detalhes."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3426
#, fuzzy
msgid "<literal>echoFlag=flag</literal> to turn echoing on"
msgstr "<literal> echoFlag = flag </ literal> para ativar o eco"

#. (itstool) path: listitem/para
#: book.translate.xml:3429
#, fuzzy
msgid ""
"Unless a target has been marked <literal>.SILENT</literal>, "
"<application>PMake</application> wants to start the shell running with "
"echoing on. To do this, it passes this flag to the shell as one of its "
"arguments. If either this or the next flag begins with a <literal>-</"
"literal>, the flags will be passed to the shell as separate arguments. "
"Otherwise, the two will be concatenated (if they are used at the same time, "
"of course)."
msgstr ""
"A menos que um alvo tenha sido marcado <literal> .SILENT </ literal>, "
"<application> PMake </ application> deseja iniciar o shell executando com "
"ecoando em. Para fazer isso, ele passa esse sinalizador para o shell como um "
"de seus argumentos. Se este ou o próximo sinalizador começar com um "
"<literal> - </ literal>, os sinalizadores serão passados para o shell como "
"argumentos separados. Caso contrário, os dois serão concatenados (se forem "
"usados ao mesmo tempo, claro)."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3442
#, fuzzy
msgid "<literal>errFlag=flag</literal> to turn error checking on"
msgstr ""
"<literal> errFlag = flag </ literal> para ativar a verificação de erros"

#. (itstool) path: listitem/para
#: book.translate.xml:3445
#, fuzzy
msgid ""
"Likewise, unless a target is marked <literal>.IGNORE</literal>, "
"<application>PMake</application> wishes error-checking to be on from the "
"very start. To this end, it will pass this flag to the shell as an argument. "
"The same rules for an initial <literal>-</literal> apply as for the "
"<literal>echoFlag</literal>."
msgstr ""
"Da mesma forma, a menos que um alvo esteja marcado como <literal> .IGNORE </ "
"literal>, O <application> PMake </ application> deseja que a verificação de "
"erros seja ativada a partir do muito começo. Para este fim, ele passará este "
"sinalizador para o shell como um argumento. As mesmas regras para uma "
"inicial <literal> - </ literal> aplicam-se <literal> echoFlag </ literal>."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3456
#, fuzzy
msgid "<literal>check=command</literal> to turn error checking on"
msgstr ""
"<literal> check = command </ literal> para ativar a verificação de erros"

#. (itstool) path: listitem/para
#: book.translate.xml:3459
#, fuzzy
msgid ""
"Just as for echo-control, error-control is achieved by inserting commands "
"into the shell's input stream. This is the command to make the shell check "
"for errors. It also serves another purpose if the shell does not have error-"
"control as commands, but I will get into that in a minute. Again, once error "
"checking has been turned on, it is expected to remain on until it is turned "
"off again."
msgstr ""
"Assim como para o controle de eco, o controle de erros é obtido inserindo "
"comandos no fluxo de entrada do shell. Este é o comando para fazer a "
"verificação do shell por erros. Ele também serve a outro propósito se o "
"shell não tiver erros controle como comandos, mas vou entrar nisso em um "
"minuto. Mais uma vez, uma vez erro a verificação foi ativada, espera-se que "
"permaneça ligada até que seja desligado de novo."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3471
#, fuzzy
msgid "<literal>ignore=command</literal>to turn error checking off"
msgstr ""
"<literal> ignore = command </ literal> para desativar a verificação de erros"

#. (itstool) path: listitem/para
#: book.translate.xml:3474
#, fuzzy
msgid ""
"This is the command <application>PMake</application> uses to turn error "
"checking off. It has another use if the shell does not do errorcontrol, but "
"I will tell you about that...now."
msgstr ""
"Este é o comando <application> PMake </ application> usado para ativar o "
"erro checando. Ele tem outro uso se o shell não fizer errorcontrol, mas Eu "
"vou falar sobre isso ... agora."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3482
#, fuzzy
msgid "<literal>hasErrCtl=yes</literal> or <literal>no</literal>"
msgstr "<literal> hasErrCtl = yes </ literal> ou <literal> não </ literal>"

#. (itstool) path: listitem/para
#: book.translate.xml:3485
#, fuzzy
msgid ""
"This takes a value that is either <literal>yes</literal> or <literal>no</"
"literal>. Now you might think that the existence of the check and ignore "
"keywords would be enough to tell <application>PMake</application> if the "
"shell can do error-control, but you would be wrong. If <literal>hasErrCtl</"
"literal> is <literal>yes</literal>, <application>PMake</application> uses "
"the check and ignore commands in a straight-forward manner. If this is no, "
"however, their use is rather different. In this case, the check command is "
"used as a template, in which the string <literal>%s</literal> is replaced by "
"the command that is about to be executed, to produce a command for the shell "
"that will echo the command to be executed. The ignore command is also used "
"as a template, again with <literal>%s</literal> replaced by the command to "
"be executed, to produce a command that will execute the command to be "
"executed and ignore any error it returns. When these strings are used as "
"templates, you must provide newline(s) (<literal>\\n</literal>) in the "
"appropriate place(s)."
msgstr ""
"Isso recebe um valor que é <literal> yes </ literal> ou <literal> no </ "
"literal>. Agora você pode pensar que a existência do cheque e ignorar "
"palavras-chave seriam suficientes para informar <application> PMake </ "
"application> se o shell pode fazer o controle de erros, mas você estaria "
"errado. Se <literal> hasErrCtl </ literal> é <literal> yes </ literal>, "
"<application> PMake </ application> usa os comandos check e ignore de "
"maneira direta. Se isso é não, no entanto, seu uso é bastante diferente. "
"Neste caso, o comando de verificação é usado como um modelo, no qual a "
"string <literal>% s </ literal> é substituída por o comando que está prestes "
"a ser executado, para produzir um comando para o shell que ecoará o comando "
"a ser executado. O comando ignorar também é usado como um modelo, novamente "
"com <literal>% s </ literal> substituído pelo comando para ser executado, "
"para produzir um comando que irá executar o comando a ser executado e "
"ignorar qualquer erro retornado. Quando essas seqüências são usadas como "
"modelos, você deve fornecer nova linha (s) (<literal> \\\\ n </ literal>) no "
"local (ais) apropriado (s)."

#. (itstool) path: section/para
#: book.translate.xml:3510
#, fuzzy
msgid ""
"The strings that follow these keywords may be enclosed in single or double "
"quotes (the quotes will be stripped off) and may contain the usual C "
"backslash-characters (<literal>\\n</literal> is newline, <literal>\\r</"
"literal> is return, <literal>\\b</literal> is backspace, <literal>\\'</"
"literal> escapes a single-quote inside single-quotes, <literal>\\\"</"
"literal> escapes a double-quote inside double-quotes). Now for an example."
msgstr ""
"As sequências que seguem essas palavras-chave podem ser colocadas em uma ou "
"duas aspas (as aspas serão retiradas) e podem conter o valor usual de C "
"caracteres invertidos (<literal> \\\\ n </ literal> é nova linha, <literal> "
"\\\\ r </ literal> é retornar, <literal> \\\\ b </ literal> é backspace, "
"<literal> \\\\ '</ literal> escapa uma aspa simples dentro de aspas simples, "
"<literal> \\\\\\ \"</ literal> escapa uma aspa dupla entre aspas duplas). "
"Agora, por exemplo."

#. (itstool) path: section/para
#: book.translate.xml:3519
#, fuzzy
msgid ""
"This is actually the contents of the &lt;shx.mk&gt; system makefile, and "
"causes <application>PMake</application> to use the <application>Bourne "
"Shell</application> in such a way that each command is printed as it is "
"executed. That is, if more than one command is given on a line, each will be "
"printed separately. Similarly, each time the body of a loop is executed, the "
"commands within that loop will be printed, etc. The specification runs like "
"this:"
msgstr ""
"Este é realmente o conteúdo do & lt; shx.mk & gt; makefile do sistema e faz "
"com que <application> PMake </ application> use o <application> Bourne Shell "
"</ application> de tal maneira que cada comando é impresso como é executado. "
"Isto é, se mais de um comando for dado em uma linha, cada um será impresso "
"separadamente. Da mesma forma, cada vez que o corpo de um loop é executado, "
"o comandos dentro desse loop serão impressos, etc. A especificação é "
"executada como isto:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3528
#, fuzzy, no-wrap
msgid ""
"#\n"
"# This is a shell specification to have the Bourne shell echo\n"
"# the commands just before executing them, rather than when it reads\n"
"# them. Useful if you want to see how variables are being expanded, etc.\n"
"#\n"
".SHELL    : path=/bin/sh \\\n"
"     quiet=\"set -\" \\\n"
"     echo=\"set -x\" \\\n"
"     filter=\"+ set - \" \\\n"
"     echoFlag=x \\\n"
"     errFlag=e \\\n"
"     hasErrCtl=yes \\\n"
"     check=\"set -e\" \\\n"
"     ignore=\"set +e\""
msgstr ""
"# \\ n # Esta é uma especificação de shell para ter o eco do shell Bourne \\ "
"n # os comandos antes de executá-los, em vez de quando ele é lido \\ n # "
"eles. Útil se você quiser ver como as variáveis estão sendo expandidas, etc. "
"\\ n # \\ n .SHELL: caminho = / bin / sh \\\\ n      quiet = \\ \"set - \\\" "
"\\\\\\ n      echo = \\ \"set -x \\\" \\\\\\ n      filter = \\ \"+ set - "
"\\\" \\\\\\ n      echoFlag = x \\\\\\ n      errFlag = e \\\\\\ n "
"     hasErrCtl = yes \\\\\\ n      check = \\ \"set -e \\\" \\\\\\ n "
"     ignore = \\ \"set + e \\\""

#. (itstool) path: section/para
#: book.translate.xml:3543
#, fuzzy
msgid "It tells <application>PMake</application> the following:"
msgstr "Ele informa ao <application> PMake </ application> o seguinte:"

#. (itstool) path: listitem/para
#: book.translate.xml:3547
#, fuzzy
msgid ""
"The shell is located in the file <filename>/bin/sh</filename>. It need not "
"tell <application>PMake</application> that the name of the shell is sh as "
"<application>PMake</application> can figure that out for itself (it is the "
"last component of the path)."
msgstr ""
"O shell está localizado no arquivo <filename> / bin / sh </ filename>. Não "
"precisa diga ao <application> PMake </ application> que o nome do shell é sh "
"como <application> PMake </ application> pode descobrir isso por si mesmo (é "
"o último componente do caminho)."

#. (itstool) path: listitem/para
#: book.translate.xml:3556
#, fuzzy
msgid "The command to stop echoing is set <literal>-</literal>."
msgstr "O comando para parar o eco é definido como <literal> - </ literal>."

#. (itstool) path: listitem/para
#: book.translate.xml:3560
#, fuzzy
msgid "The command to start echoing is set <option>-x</option>."
msgstr "O comando para iniciar o eco é definido como <option> -x </ option>."

#. (itstool) path: listitem/para
#: book.translate.xml:3564
#, fuzzy
msgid ""
"When the echo off command is executed, the shell will print <literal>+</"
"literal> set <literal>-</literal> (The <literal>+</literal> comes from using "
"the <option>-x</option> flag (rather than the <option>-v</option> flag "
"<application>PMake</application> usually uses)). <application>PMake</"
"application> will remove all occurrences of this string from the output, so "
"you do not notice extra commands you did not put there."
msgstr ""
"Quando o comando echo off é executado, o shell irá imprimir <literal> + </ "
"literal> set <literal> - </ literal> (O <literal> + </ literal> vem de usar "
"o sinalizador <option> -x </ option> (em vez do sinalizador <option> -v </ "
"option> <application> PMake </ application> geralmente usa)). <application> "
"PMake </ application> removerá todas as ocorrências desta string da saída, "
"portanto você não percebe comandos extras que você não colocou lá."

#. (itstool) path: listitem/para
#: book.translate.xml:3576
#, fuzzy
msgid ""
"The flag the <application>Bourne Shell</application> will take to start "
"echoing in this way is the <option>-x</option> flag. The <application>Bourne "
"Shell</application> will only take its flag arguments concatenated as its "
"first argument, so neither this nor the errFlag specification begins with a "
"<literal>-</literal>."
msgstr ""
"O sinalizador que o <application> Bourne Shell </ application> levará para "
"iniciar ecoar desta forma é o sinalizador <option> -x </ option>. O "
"<aplicativo> Bourne Shell </ application> só terá seus argumentos de "
"bandeira concatenados como primeiro argumento, então nem isso nem a "
"especificação errFlag começa com um <literal> - </ literal>."

#. (itstool) path: listitem/para
#: book.translate.xml:3586
#, fuzzy
msgid ""
"The flag to use to turn error-checking on from the start is <option>-e</"
"option>."
msgstr ""
"O sinalizador a ser usado para ativar a verificação de erros desde o início "
"é <option> -e </ opção>."

#. (itstool) path: listitem/para
#: book.translate.xml:3591
#, fuzzy
msgid ""
"The shell can turn error-checking on and off, and the commands to do so are "
"<literal>set +e</literal> and <literal>set -e</literal>, respectively."
msgstr ""
"O shell pode ativar e desativar a verificação de erros, e os comandos para "
"isso são <literal> set + e </ literal> e <literal> set -e </ literal>, "
"respectivamente."

#. (itstool) path: section/para
#: book.translate.xml:3597
#, fuzzy
msgid ""
"I should note that this specification is for <application>Bourne Shells</"
"application> that are not part of Berkeley <trademark class="
"\"registered\">UNIX</trademark>, as shells from Berkeley do not do error "
"control. You can get a similar effect, however, by changing the last three "
"lines to be:"
msgstr ""
"Devo observar que essa especificação é para <application> Bourne Shells </ "
"aplicação> que não fazem parte de Berkeley <trademark class = \\ "
"\"registered \\ \"> UNIX </ trademark>, pois shells de Berkeley não fazem "
"controle de erros. pode ter um efeito semelhante, no entanto, alterando as "
"três últimas linhas a serem:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3603
#, fuzzy, no-wrap
msgid ""
"hasErrCtl=no \\\n"
"check=\"echo \\\"+ %s\\\"\\n\" \\\n"
"ignore=\"sh -c '%s || exit 0\\n\""
msgstr ""
"hasErrCtl = não \\\\\\ n check = \\ \"echo \\\\\\\" +% s \\\\\\ \"\\\\ n "
"\\\" \\\\\\ n ignore = \\ \"sh -c '% s || exit 0 \\\\ n \\\""

#. (itstool) path: section/para
#: book.translate.xml:3607
#, fuzzy
msgid ""
"This will cause <application>PMake</application> to execute the two commands:"
""
msgstr ""
"Isso fará com que o <application> PMake </ application> execute os dois "
"comandos:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3610
#, fuzzy, no-wrap
msgid "echo \"+ cmd\"\n"
"sh -c 'cmd || true'"
msgstr "echo \\ \"+ cmd \\\" \\ n sh -c 'cmd || verdade'"

#. (itstool) path: section/para
#: book.translate.xml:3613
#, fuzzy
msgid ""
"for each command for which errors are to be ignored. (In case you are "
"wondering, the thing for ignore tells the shell to execute another shell "
"without error checking on and always exit 0, since the ||<literal/> causes "
"the exit 0 to be executed only if the first command exited non-zero, and if "
"the first command exited zero, the shell will also exit zero, since that is "
"the last command it executed)."
msgstr ""
"para cada comando para o qual os erros devem ser ignorados. (Caso você "
"esteja imaginando, a coisa por ignore diz ao shell para executar outro shell "
"sem verificar o erro e sempre sair 0, pois o || <literal /> causa a saída 0 "
"será executada somente se o primeiro comando sair diferente de zero, e se o "
"primeiro comando saiu zero, o shell também sairá de zero, já que é o último "
"comando executado)."

#. (itstool) path: section/title
#: book.translate.xml:3624
#, fuzzy
msgid "Compatibility"
msgstr "Compatibilidade"

#. (itstool) path: section/para
#: book.translate.xml:3626
#, fuzzy
msgid ""
"There are three (well, 3 1/2) levels of backwards-compatibility built into "
"<application>PMake</application>. Most makefiles will need none at all. Some "
"may need a little bit of work to operate correctly when run in parallel. "
"Each level encompasses the previous levels (e.g. <option>-B</option> (one "
"shell per command) implies <option>-V</option>). The three levels are "
"described in the following three sections."
msgstr ""
"Existem três níveis (bem, 3 1/2) de compatibilidade com versões anteriores "
"<application> PMake </ application>. A maioria dos makefiles não precisará "
"de nenhum. Alguns pode precisar de um pouco de trabalho para funcionar "
"corretamente quando executado em paralelo. Cada nível engloba os níveis "
"anteriores (por exemplo, <option> -B </ option>) shell por comando) implica "
"<option> -V </ option>). Os três níveis são descrito nas três seções a "
"seguir."

#. (itstool) path: section/title
#: book.translate.xml:3637
#, fuzzy
msgid "DEFCON 3 – Variable Expansion"
msgstr "DEFCON 3 - Expansão Variável"

#. (itstool) path: section/para
#: book.translate.xml:3639
#, fuzzy
msgid ""
"As noted before, <application>PMake</application> will not expand a variable "
"unless it knows of a value for it. This can cause problems for makefiles "
"that expect to leave variables undefined except in special circumstances (e."
"g. if more flags need to be passed to the C compiler or the output from a "
"text processor should be sent to a different printer). If the variables are "
"enclosed in curly braces (<literal>${PRINTER}</literal>), the shell will let "
"them pass. If they are enclosed in parentheses, however, the shell will "
"declare a syntax error and the make will come to a grinding halt."
msgstr ""
"Como observado anteriormente, <application> PMake </ application> não "
"expandirá uma variável a menos que saiba de um valor para isso. Isso pode "
"causar problemas para makefiles que esperam deixar variáveis indefinidas, "
"exceto em circunstâncias especiais (e. g. se mais bandeiras precisam ser "
"passadas para o compilador C ou a saída de um processador de texto deve ser "
"enviado para uma impressora diferente). Se as variáveis são entre chaves "
"(<literal> $ {PRINTER} </ literal>), o shell permitirá eles passam. Se eles "
"estiverem entre parênteses, no entanto, o shell declarar um erro de sintaxe "
"e a marca será interrompida."

#. (itstool) path: section/para
#: book.translate.xml:3651
#, fuzzy
msgid ""
"You have two choices: change the makefile to define the variables (their "
"values can be overridden on the command line, since that is where they would "
"have been set if you used <application>Make</application>, anyway) or always "
"give the <option>-V</option> flag (this can be done with the <_:buildtarget-"
"1/> target, if you want)."
msgstr ""
"Você tem duas opções: alterar o makefile para definir as variáveis (suas "
"valores podem ser substituídos na linha de comando, pois é nesse ponto que "
"eles foram definidos se você usou <application> Make </ application>, de "
"qualquer forma) ou sempre dê o sinalizador <option> -V </ option> (isso pode "
"ser feito com o <_: buildtarget-1 /> alvo, se você quiser)."

#. (itstool) path: section/title
#: book.translate.xml:3660
#, fuzzy
msgid "DEFCON 2 – The Number of the Beast"
msgstr "DEFCON 2 - O Número da Besta"

#. (itstool) path: section/para
#: book.translate.xml:3662
#, fuzzy
msgid ""
"Then there are the makefiles that expect certain commands, such as changing "
"to a different directory, to not affect other commands in a target's "
"creation script. You can solve this is either by going back to executing one "
"shell per command (which is what the <option>-B</option> flag forces "
"<application>PMake</application> to do), which slows the process down a good "
"bit and requires you to use semicolons and escaped newlines for shell "
"constructs, or by changing the makefile to execute the offending command(s) "
"in a subshell (by placing the line inside parentheses), like so:"
msgstr ""
"Depois, há os makefiles que esperam certos comandos, como alterar para um "
"diretório diferente, para não afetar outros comandos em um alvo script de "
"criação. Você pode resolver isso é voltar a executar um shell por comando "
"(que é o que o <option> -B </ option> sinaliza as forças <application> PMake "
"</ application> para fazer), o que retarda o processo para baixo um bom bit "
"e requer que você use ponto e vírgula e escapou newlines para shell "
"construções, ou alterando o makefile para executar o (s) comando (s) "
"ofensivo (s) em um subshell (colocando a linha entre parênteses), assim:"

#. (itstool) path: section/programlisting
#: book.translate.xml:3674
#, fuzzy, no-wrap
msgid ""
"install :: .MAKE\n"
"      (cd src; $(.PMAKE) install)\n"
"      (cd lib; $(.PMAKE) install)\n"
"      (cd man; $(.PMAKE) install)"
msgstr ""
"instalar :: .MAKE \\ n       (cd src; $ (. PMAKE) instalar) \\ n       (cd "
"lib; $ (. PMAKE) instala) \\ n       (cd man; $ (. PMAKE) instalar)"

#. (itstool) path: section/para
#: book.translate.xml:3679
#, fuzzy
msgid ""
"This will always execute the three makes (even if the <option>-n</option> "
"flag was given) because of the combination of the <literal>::</literal> "
"operator and the <literal>.MAKE</literal> attribute. Each command will "
"change to the proper directory to perform the install, leaving the main "
"shell in the directory in which it started."
msgstr ""
"Isso sempre executará as três marcas (mesmo que a <option> -n </ option> "
"flag foi dado) por causa da combinação do <literal> :: </ literal> operador "
"e o atributo <literal> .MAKE </ literal>. Cada comando mudar para o "
"diretório apropriado para executar a instalação, deixando o principal shell "
"no diretório em que ele foi iniciado."

#. (itstool) path: section/title
#: book.translate.xml:3690
#, fuzzy
msgid "DEFCON 1 – Imitation is the Not the Highest Form of Flattery"
msgstr "DEFCON 1 - Imitação não é a mais alta forma de lisonja"

#. (itstool) path: section/para
#: book.translate.xml:3693
#, fuzzy
msgid ""
"The final category of makefile is the one where every command requires "
"input, the dependencies are incompletely specified, or you simply cannot "
"create more than one target at a time, as mentioned earlier. In addition, "
"you may not have the time or desire to upgrade the makefile to run smoothly "
"with <application>PMake</application>. If you are the conservative sort, "
"this is the compatibility mode for you. It is entered either by giving "
"<application>PMake</application> the <option>-M</option> flag (for "
"<application>Make</application>), or by executing <application>PMake</"
"application> as <command>make.</command> In either case, <application>PMake</"
"application> performs things exactly like <application>Make</application> "
"(while still supporting most of the nice new features <application>PMake</"
"application> provides). This includes:"
msgstr ""
"A categoria final do makefile é aquela em que todo comando requer entrada, "
"as dependências são incompletamente especificadas, ou você simplesmente não "
"pode crie mais de um alvo de cada vez, como mencionado anteriormente. Além "
"do que, além do mais, você pode não ter tempo ou desejo de atualizar o "
"makefile para funcionar sem problemas com <application> PMake </ "
"application>. Se você é do tipo conservador, este é o modo de "
"compatibilidade para você. É inserido ou dando <application> PMake </ "
"application> o sinalizador <option> -M </ option> (para <application> Make </"
" application>) ou executando <application> PMake </ application> como "
"<command> make. </ command> Em ambos os casos, <application> PMake </ "
"application> executa as coisas exatamente como <application> Make </ "
"application> (enquanto ainda suporta a maioria dos novos recursos "
"interessantes <application> PMake </ aplicação> fornece). Isso inclui:"

#. (itstool) path: listitem/para
#: book.translate.xml:3711
#, fuzzy
msgid "No parallel execution."
msgstr "Nenhuma execução paralela."

#. (itstool) path: listitem/para
#: book.translate.xml:3715
#, fuzzy
msgid ""
"Targets are made in the exact order specified by the makefile. The sources "
"for each target are made in strict left-to-right order, etc."
msgstr ""
"Os destinos são feitos na ordem exata especificada pelo makefile. As fontes "
"para cada alvo são feitas na ordem estrita da esquerda para a direita, etc."

#. (itstool) path: listitem/para
#: book.translate.xml:3721
#, fuzzy
msgid ""
"A single Bourne shell is used to execute each command, thus the shell's "
"<varname>$$</varname> variable is useless, changing directories does not "
"work across command lines, etc."
msgstr ""
"Um único shell Bourne é usado para executar cada comando, assim, o shell "
"Variável <varname> $$ </ varname> é inútil, alterar diretórios não trabalhe "
"através das linhas de comando, etc."

#. (itstool) path: listitem/para
#: book.translate.xml:3728
#, fuzzy
msgid ""
"If no special characters exist in a command line, <application>PMake</"
"application> will break the command into words itself and execute the "
"command directly, without executing a shell first. The characters that cause "
"<application>PMake</application> to execute a shell are: <literal>#</"
"literal>, <literal>=</literal>, <literal>|</literal>, <literal>^</literal>, "
"<literal>(</literal>, <literal>)</literal>, <literal>{</literal>, "
"<literal>}</literal>, <literal>;</literal>, <literal>&amp;</literal>, "
"<literal>&gt;</literal>, <literal>&lt;</literal>, <literal>*</literal>, "
"<literal>?</literal>, <literal>[</literal>, <literal>]</literal>, <literal>:"
"</literal>, <literal>$</literal>, <literal>`</literal>, and <literal>\\</"
"literal>. You should notice that these are all the characters that are given "
"special meaning by the shell (except <literal>'</literal> and <literal>,</"
"literal> which <application>PMake</application> deals with all by its "
"lonesome)."
msgstr ""
"Se não houver caracteres especiais em uma linha de comando, <application> "
"PMake </ application> quebrará o comando em palavras e executará o comando "
"comando diretamente, sem executar primeiro um shell. Os personagens que "
"causam <application> PMake </ application> para executar um shell são: "
"<literal> # </ literal>, <literal> = </ literal>, <literal> | </ literal>, "
"<literal> ^ </ literal>, <literal> (</ literal>, <literal>) </ literal>, "
"<literal> {</ literal>, <literal>} </ literal>, <literal>; </ literal>, "
"<literal> & amp; </ literal>, <literal> & gt; </ literal>, <literal> & lt; </"
" literal>, <literal> * </ literal>, <literal>? </ literal>, <literal> [</ "
"literal>, <literal>] </ literal>, <literal>: </ literal>, <literal> $ </ "
"literal>, <literal> `</ literal> e <literal> \\\\ </ literal>. Você deve "
"notar que estes são todos os personagens que recebem especial significado "
"pelo shell (exceto <literal> '</ literal> e <literal>, </ literal> qual "
"<application> PMake </ application> lida com todos por sua solidão)."

#. (itstool) path: listitem/para
#: book.translate.xml:3751
#, fuzzy
msgid "The use of the null suffix is turned off."
msgstr "O uso do sufixo nulo está desativado."

#. (itstool) path: section/title
#: book.translate.xml:3757
#, fuzzy
msgid "The Way Things Work"
msgstr "A maneira como as coisas funcionam"

#. (itstool) path: section/para
#: book.translate.xml:3759
#, fuzzy
msgid ""
"When <application>PMake</application> reads the makefile, it parses sources "
"and targets into nodes in a graph. The graph is directed only in the sense "
"that <application>PMake</application> knows which way is up. Each node "
"contains not only links to all its parents and children (the nodes that "
"depend on it and those on which it depends, respectively), but also a count "
"of the number of its children that have already been processed."
msgstr ""
"Quando <application> PMake </ application> lê o makefile, ele analisa fontes "
"e metas em nós em um gráfico. O gráfico é direcionado apenas no sentido que "
"o <application> PMake </ application> sabe qual é o caminho. Cada nó contém "
"não apenas links para todos os pais e filhos (os nós que dependem disso e "
"daquelas de que depende, respectivamente), mas também uma contagem do número "
"de seus filhos que já foram processados."

#. (itstool) path: section/para
#: book.translate.xml:3767
#, fuzzy
msgid ""
"The most important thing to know about how <application>PMake</application> "
"uses this graph is that the traversal is breadth-first and occurs in two "
"passes."
msgstr ""
"A coisa mais importante a saber sobre como <application> PMake </ "
"application> usa este gráfico é que o percurso é em largura e ocorre em dois "
"passa."

#. (itstool) path: para/buildtarget
#: book.translate.xml:3782 book.translate.xml:3786 book.translate.xml:3788
#: book.translate.xml:3789
#, fuzzy
msgid ".USE"
msgstr ".USAR"

#. (itstool) path: section/para
#: book.translate.xml:3771
#, fuzzy
msgid ""
"After <application>PMake</application> has parsed the makefile, it begins "
"with the nodes the user has told it to make (either on the command line, or "
"via a <_:buildtarget-1/> target, or by the target being the first in the "
"file not labeled with the <literal>.NOTMAIN</literal> attribute) placed in a "
"queue. It continues to take the node off the front of the queue, mark it as "
"something that needs to be made, pass the node to <literal>Suff_FindDeps</"
"literal> (mentioned earlier) to find any implicit sources for the node, and "
"place all the node's children that have yet to be marked at the end of the "
"queue. If any of the children is a <_:buildtarget-2/> rule, its attributes "
"are applied to the parent, then its commands are appended to the parent's "
"list of commands and its children are linked to its parent. The parent's "
"unmade children counter is then decremented (since the <_:buildtarget-3/> "
"node has been processed). You will note that this allows a <_:buildtarget-4/"
"> node to have children that are <_:buildtarget-5/> nodes and the rules will "
"be applied in sequence. If the node has no children, it is placed at the end "
"of another queue to be examined in the second pass. This process continues "
"until the first queue is empty."
msgstr ""
"Após <application> PMake </ application> ter analisado o makefile, ele "
"começa com os nós que o usuário disse para fazer (na linha de comando ou via "
"um alvo <_: buildtarget-1 />, ou pelo alvo sendo o primeiro no arquivo não "
"rotulado com o atributo <literal> .NOTMAIN </ literal>) colocado em um "
"arquivo fila. Continua a tirar o nó da frente da fila, marcá-lo como algo "
"que precisa ser feito, passe o nó para <literal> Suff_FindDeps </ literal> "
"(mencionado anteriormente) para encontrar fontes implícitas para o nó, e "
"colocar todos os filhos do nó que ainda não foram marcados no final do fila. "
"Se algum dos filhos é uma regra <_: buildtarget-2 />, seus atributos são "
"aplicadas ao pai, então seus comandos são anexados ao pai lista de comandos "
"e seus filhos estão ligados ao seu pai. Os pais contador de filhos desfeita "
"é então decrementado (uma vez que o <_: buildtarget-3 /> nó foi processado). "
"Você notará que isso permite um <_: buildtarget-4 / > nó para ter filhos que "
"são <_: buildtarget-5 /> nós e as regras serão ser aplicado em seqüência. Se "
"o nó não tiver filhos, ele será colocado no final de outra fila a ser "
"examinada no segundo passe. Este processo continua até que a primeira fila "
"esteja vazia."

#. (itstool) path: section/para
#: book.translate.xml:3794
#, fuzzy
msgid ""
"At this point, all the leaves of the graph are in the examination queue. "
"<application>PMake</application> removes the node at the head of the queue "
"and sees if it is out-of-date. If it is, it is passed to a function that "
"will execute the commands for the node asynchronously. When the commands "
"have completed, all the node's parents have their unmade children counter "
"decremented and, if the counter is then 0, they are placed on the "
"examination queue. Likewise, if the node is up-to-date. Only those parents "
"that were marked on the downward pass are processed in this way. Thus "
"<application>PMake</application> traverses the graph back up to the nodes "
"the user instructed it to create. When the examination queue is empty and no "
"shells are running to create a target, <application>PMake</application> is "
"finished."
msgstr ""
"Neste ponto, todas as folhas do gráfico estão na fila de exames. "
"<application> PMake </ application> remove o nó na cabeça da fila e vê se "
"está desatualizado. Se for, é passado para uma função que irá executar os "
"comandos para o nó de forma assíncrona. Quando os comandos ter concluído, "
"todos os pais do nó têm o seu contador de filhos decrementado e, se o "
"contador é então 0, eles são colocados no fila de exames. Da mesma forma, se "
"o nó estiver atualizado. Apenas aqueles pais que foram marcados no passe "
"descendente são processados dessa maneira. portanto <application> PMake </ "
"application> atravessa o gráfico de volta para os nós o usuário instruiu "
"para criar. Quando a fila de exames está vazia e não shells estão em "
"execução para criar um destino, <application> PMake </ application> é "
"acabado."

#. (itstool) path: section/para
#: book.translate.xml:3809
#, fuzzy
msgid ""
"Once all targets have been processed, <application>PMake</application> "
"executes the commands attached to the <_:buildtarget-1/> target, either "
"explicitly or through the use of an ellipsis in a shell script. If there "
"were no errors during the entire process but there are still some targets "
"unmade (<application>PMake</application> keeps a running count of how many "
"targets are left to be made), there is a cycle in the graph. "
"<application>PMake</application> does a depth-first traversal of the graph "
"to find all the targets that were not made and prints them out one by one."
msgstr ""
"Depois que todos os destinos tiverem sido processados, <application> PMake </"
" application> executa os comandos anexados ao destino <_: buildtarget-1 />, "
"seja explicitamente ou através do uso de reticências em um shell script. Se "
"lá não houve erros durante todo o processo, mas ainda existem alguns alvos "
"unmade (<application> PMake </ application> mantém uma contagem de quantos "
"metas são deixadas para serem feitas), há um ciclo no gráfico. <application> "
"PMake </ application> faz uma travessia em profundidade do gráfico para "
"encontrar todos os alvos que não foram feitos e imprimi-los um por um."

#. (itstool) path: chapter/title
#: book.translate.xml:3827
#, fuzzy
msgid "Answers to Exercises"
msgstr "Respostas aos Exercícios"

#. (itstool) path: chapter/para
#: book.translate.xml:3831
#, fuzzy
msgid ""
"This is something of a trick question, for which I apologize. The trick "
"comes from the <trademark class=\"registered\">UNIX</trademark> definition "
"of a suffix, which <application>PMake</application> does not necessarily "
"share. You will have noticed that all the suffixes used in this tutorial "
"(and in <trademark class=\"registered\">UNIX</trademark> in general) begin "
"with a period (<filename>.ms</filename>, <filename>.c</filename>, etc.). "
"Now, <application>PMake</application>'s idea of a suffix is more like "
"English's: it is the characters at the end of a word. With this in mind, one "
"possible solution to this problem goes as follows:"
msgstr ""
"Isso é uma questão complicada, pela qual peço desculpas. O truque vem da "
"definição <trademark class = \\ \"registered \\\"> UNIX </ trademark> de um "
"sufixo, que <application> PMake </ application> não necessariamente "
"compartilhar. Você deve ter notado que todos os sufixos usados neste "
"tutorial (e em <trademark class = \\ \"registered \\\"> UNIX </ trademark> "
"em geral) começam com um período (<nome_do_arquivo> .ms </ filename>, "
"<nome_do_arquivo> .c </ filename>, etc.). Agora, a idéia de um sufixo de "
"<application> PMake </ application> é mais como Inglês: são os personagens "
"no final de uma palavra. Com isso em mente, um possível solução para este "
"problema é a seguinte:"

#. (itstool) path: chapter/programlisting
#: book.translate.xml:3842
#, fuzzy, no-wrap
msgid ""
".SUFFIXES       : ec.exe .exe ec.obj .obj .asm\n"
"ec.objec.exe .obj.exe :\n"
"\tlink -o $(.TARGET) $(.IMPSRC)\n"
".asmec.obj      :\n"
"\tasm -o $(.TARGET) -DDO_ERROR_CHECKING $(.IMPSRC)\n"
".asm.obj        :\n"
"\tasm -o $(.TARGET) $(.IMPSRC)"
msgstr ""
".SUFFIXES: ec.exe .exe ec.obj .obj .asm \\ n ecobjec.exe .obj.exe: \\ n \\ "
"tlink -o $ (. TARGET) $ (. IMPSRC) \\ n .asmec.obj: \\ n \\ tasm -o $ (. "
"TARGET) -DDO_ERROR_CHECKING $ (. IMPSRC) \\ n .asm.obj: \\ n \\ tasm -o $ (. "
"TARGET) $ (. IMPSRC)"

#. (itstool) path: chapter/bridgehead
#: book.translate.xml:3850
#, fuzzy
msgid "Excercise 3.2"
msgstr "Exercício 3.2"

#. (itstool) path: chapter/para
#: book.translate.xml:3852
#, fuzzy
msgid ""
"The trick to this one lies in the <literal>:=</literal> variable-assignment "
"operator and the <literal>:S</literal> variable-expansion modifier. "
"Basically what you want is to take the pointer variable, so to speak, and "
"transform it into an invocation of the variable at which it points. You "
"might try something like:"
msgstr ""
"O truque para este aqui está na atribuição de variáveis <literal>: = </ "
"literal> operador e o modificador de expansão de variável <literal>: S </ "
"literal>. Basicamente, o que você quer é pegar a variável ponteiro, por "
"assim dizer, e transformá-lo em uma invocação da variável na qual ele aponta."
" Você pode tentar algo como:"

#. (itstool) path: chapter/programlisting
#: book.translate.xml:3859
#, fuzzy, no-wrap
msgid "$(PTR:S/^/\\$(/:S/$/))"
msgstr "$ (PTR: S / ^ / \\\\ $ (/: S / $ /))"

#. (itstool) path: chapter/para
#: book.translate.xml:3861
#, fuzzy
msgid ""
"which places <literal>$(</literal> at the front of the variable name and "
"<literal>)</literal> at the end, thus transforming <literal>VAR,</literal> "
"for example, into <literal>$(VAR)</literal>, which is just what we want. "
"Unfortunately (as you know if you have tried it), since, as it says in the "
"hint, <application>PMake</application> does no further substitution on the "
"result of a modified expansion, that is all you get. The solution is to make "
"use of <literal>:=</literal> to place that string into yet another variable, "
"then invoke the other variable directly:"
msgstr ""
"que coloca <literal> $ (</ literal> na frente do nome da variável e "
"<literal>) </ literal> no final, transformando <literal> VAR, </ literal> "
"por exemplo, em <literal> $ (VAR) </ literal>, que é exatamente o que "
"queremos. Infelizmente (como você sabe se já tentou), já que, como diz no "
"dica, <application> PMake </ application> não faz nenhuma substituição "
"adicional no resultado de uma expansão modificada, isso é tudo que você "
"ganha. A solução é fazer uso de <literal>: = </ literal> para colocar essa "
"cadeia em outra variável, então invoque a outra variável diretamente:"

#. (itstool) path: chapter/programlisting
#: book.translate.xml:3872
#, fuzzy, no-wrap
msgid "*PTR            := $(PTR:S/^/\\$(/:S/$/)/)"
msgstr "* PTR: = $ (PTR: S / ^ / \\\\ $ (/: S / $ /) /)"

#. (itstool) path: chapter/para
#: book.translate.xml:3874
#, fuzzy
msgid "You can then use <literal>$(*PTR)</literal> to your heart's content."
msgstr ""
"Você pode usar <literal> $ (* PTR) </ literal> para o conteúdo do seu "
"coração."

#. (itstool) path: glossary/title
#: book.translate.xml:3884
#, fuzzy
msgid "Glossary of Jargon"
msgstr "Glossário do jargão"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3887
#, fuzzy
msgid "attribute"
msgstr "atributo"

#. (itstool) path: glossdef/para
#: book.translate.xml:3890
#, fuzzy
msgid ""
"A property given to a target that causes <application>PMake</application> to "
"treat it differently."
msgstr ""
"Uma propriedade dada a um destino que faz com que <application> PMake </ "
"application> seja trate isso de maneira diferente."

#. (itstool) path: glossentry/glossterm
#. (itstool) id: book.translate.xml#cmdscript
#: book.translate.xml:3896
#, fuzzy
msgid "command script"
msgstr "script de comando"

#. (itstool) path: glossdef/para
#: book.translate.xml:3899
#, fuzzy
msgid ""
"The lines immediately following a dependency line that specify commands to "
"execute to create each of the targets on the dependency line. Each line in "
"the command script must begin with a tab."
msgstr ""
"As linhas imediatamente após uma linha de dependência que especificam "
"comandos para execute para criar cada um dos alvos na linha de dependência. "
"Cada linha em o script de comando deve começar com uma guia."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3906
#, fuzzy
msgid "command-line variable"
msgstr "variável de linha de comando"

#. (itstool) path: glossdef/para
#: book.translate.xml:3909
#, fuzzy
msgid ""
"A variable defined in an argument when <application>PMake</application> is "
"first executed. Overrides all assignments to the same variable name in the "
"makefile."
msgstr ""
"Uma variável definida em um argumento quando <application> PMake </ "
"application> é executado pela primeira vez. Substitui todas as atribuições "
"para o mesmo nome de variável no makefile."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3917
#, fuzzy
msgid "conditional"
msgstr "condicional"

#. (itstool) path: glossdef/para
#: book.translate.xml:3920
#, fuzzy
msgid ""
"A construct much like that used in C that allows a makefile to be configured "
"on the fly based on the local environment, or on what is being made by that "
"invocation of <application>PMake</application>."
msgstr ""
"Uma construção muito parecida com aquela usada em C que permite que um "
"makefile seja configurado na mosca com base no ambiente local, ou no que "
"está sendo feito por esse invocação de <application> PMake </ application>."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3927
#, fuzzy
msgid "creation script"
msgstr "script de criação"

#. (itstool) path: glossdef/para
#: book.translate.xml:3930
#, fuzzy
msgid "Commands used to create a target."
msgstr "Comandos usados para criar um alvo."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3935
#, fuzzy
msgid "dependency"
msgstr "dependência"

#. (itstool) path: glossdef/para
#: book.translate.xml:3938
#, fuzzy
msgid ""
"The relationship between a source and a target. This comes in three flavors, "
"as indicated by the operator between the target and the source. <literal>:</"
"literal> gives a straight time-wise dependency (if the target is older than "
"the source, the target is out-of-date), while <literal>!</literal> provides "
"simply an ordering and always considers the target out-of-date. <literal>::</"
"literal> is much like <literal>:</literal>, save it creates multiple "
"instances of a target each of which depends on its own list of sources."
msgstr ""
"O relacionamento entre uma origem e um destino. Isso vem em três sabores, "
"conforme indicado pelo operador entre o alvo e a fonte. <literal>: </ "
"literal> fornece uma dependência correta em tempo real (se o destino for "
"mais antigo que a fonte, o destino está desatualizado), enquanto <literal>! "
"</ literal> fornece simplesmente uma ordenação e sempre considera a meta "
"desatualizada. <literal> :: </ literal> é muito parecido com <literal>: </ "
"literal>, salve-o cria múltiplos instâncias de um alvo, cada qual depende de "
"sua própria lista de fontes."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3950
#, fuzzy
msgid "dynamic source"
msgstr "fonte dinâmica"

#. (itstool) path: glossdef/para
#: book.translate.xml:3953
#, fuzzy
msgid ""
"This refers to a source that has a local variable invocation in it. It "
"allows a single dependency line to specify a different source for each "
"target on the line."
msgstr ""
"Isso se refere a uma fonte que possui uma invocação de variável local. isto "
"permite que uma única linha de dependência especifique uma fonte diferente "
"para cada alvo na linha."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3960
#, fuzzy
msgid "global variable"
msgstr "variável global"

#. (itstool) path: glossdef/para
#: book.translate.xml:3963
#, fuzzy
msgid ""
"Any variable defined in a makefile. Takes precedence over variables defined "
"in the environment, but not over command-line or local variables."
msgstr ""
"Qualquer variável definida em um makefile. Tem precedência sobre as "
"variáveis definidas no ambiente, mas não sobre as variáveis de linha de "
"comando ou locais."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3970
#, fuzzy
msgid "input graph"
msgstr "gráfico de entrada"

#. (itstool) path: glossdef/para
#: book.translate.xml:3973
#, fuzzy
msgid ""
"What <application>PMake</application> constructs from a makefile. Consists "
"of nodes made of the targets in the makefile, and the links between them "
"(the dependencies). The links are directed (from source to target) and there "
"may not be any cycles (loops) in the graph."
msgstr ""
"O que <application> PMake </ application> constrói de um makefile. Consiste "
"de nós feitos dos alvos no makefile e os links entre eles (as dependências). "
"Os links são direcionados (da origem ao destino) e lá pode não haver ciclos "
"(loops) no gráfico."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3981
#, fuzzy
msgid "local variable"
msgstr "variável local"

#. (itstool) path: glossdef/para
#: book.translate.xml:3984
#, fuzzy
msgid ""
"A variable defined by <application>PMake</application> visible only in a "
"target's shell script. There are seven local variables, not all of which are "
"defined for every target: <varname>.TARGET</varname>, <varname>.ALLSRC</"
"varname>, <varname>.OODATE</varname>, <varname>.PREFIX</varname>, <varname>."
"IMPSRC</varname>, <varname>.ARCHIVE</varname>, and <varname>.MEMBER</"
"varname>. <varname>.TARGET</varname>, <varname>.PREFIX</varname>, <varname>."
"ARCHIVE</varname>, and <varname>.MEMBER</varname> may be used on dependency "
"lines to create <quote>dynamic sources</quote>."
msgstr ""
"Uma variável definida por <application> PMake </ application> visível apenas "
"em um script shell do alvo. Existem sete variáveis locais, nem todas são "
"definido para cada destino: <varname> .TARGET </ varname>, <varname> .ALLSRC "
"</ varname>, <varname> .OODATE </ varname>, <varname> .PREFIX </ varname>, "
"<varname>. IMPSRC </ varname>, <varname> .ARCHIVE </ varname> e <varname> ."
"MEMBER </ varname>. <varname> .TARGET </ varname>, <varname> .PREFIX </ "
"varname>, <varname>. ARCHIVE </ varname> e <varname> .MEMBER </ varname> "
"podem ser usados na dependência linhas para criar <quote> fontes dinâmicas </"
" quote>."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:3999
#, fuzzy
msgid "makefile"
msgstr "makefile"

#. (itstool) path: glossdef/para
#: book.translate.xml:4002
#, fuzzy
msgid ""
"A file that describes how a system is built. If you do not know what it is "
"after reading this tutorial…"
msgstr ""
"Um arquivo que descreve como um sistema é construído. Se você não sabe o que "
"é depois de ler este tutorial ..."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4008
#, fuzzy
msgid "modifier"
msgstr "mudança"

#. (itstool) path: glossdef/para
#: book.translate.xml:4011
#, fuzzy
msgid ""
"A letter, following a colon, used to alter how a variable is expanded. It "
"has no effect on the variable itself."
msgstr ""
"Uma letra, após dois pontos, usada para alterar como uma variável é "
"expandida. isto não tem efeito sobre a variável em si."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4017
#, fuzzy
msgid "operator"
msgstr "operador"

#. (itstool) path: glossdef/para
#: book.translate.xml:4020
#, fuzzy
msgid ""
"What separates a source from a target (on a dependency line) and specifies "
"the relationship between the two. There are three: <literal>:</literal>, "
"<literal>::</literal>, and <literal>!</literal>."
msgstr ""
"O que separa uma fonte de um destino (em uma linha de dependência) e "
"especifica a relação entre os dois. Existem três: <literal>: </ literal>, "
"<literal> :: </ literal> e <literal>! </ literal>."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4028
#, fuzzy
msgid "search path"
msgstr "caminho de pesquisa"

#. (itstool) path: glossdef/para
#: book.translate.xml:4031
#, fuzzy
msgid ""
"A list of directories in which a file should be sought. <application>PMake</"
"application>'s view of the contents of directories in a search path does not "
"change once the makefile has been read. A file is sought on a search path "
"only if it is exclusively a source."
msgstr ""
"Uma lista de diretórios em que um arquivo deve ser procurado. <application> "
"PMake </ A visão do application> do conteúdo dos diretórios em um caminho de "
"busca não mudar uma vez que o makefile foi lido. Um arquivo é procurado em "
"um caminho de pesquisa somente se for exclusivamente uma fonte."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4040
#, fuzzy
msgid "shell"
msgstr "Concha"

#. (itstool) path: glossdef/para
#: book.translate.xml:4043
#, fuzzy
msgid "A program to which commands are passed in order to create targets."
msgstr "Um programa para o qual os comandos são passados para criar destinos."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4049
#, fuzzy
msgid "source"
msgstr "fonte"

#. (itstool) path: glossdef/para
#: book.translate.xml:4052
#, fuzzy
msgid ""
"Anything to the right of an operator on a dependency line. Targets on the "
"dependency line are usually created from the sources."
msgstr ""
"Qualquer coisa à direita de um operador em uma linha de dependência. Alvos "
"no linha de dependência são geralmente criadas a partir das fontes."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4059
#, fuzzy
msgid "special target"
msgstr "alvo especial"

#. (itstool) path: glossdef/para
#: book.translate.xml:4062
#, fuzzy
msgid ""
"A target that causes <application>PMake</application> to do special things "
"when it is encountered."
msgstr ""
"Um destino que faz com que <application> PMake </ application> faça coisas "
"especiais quando é encontrado."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4068
#, fuzzy
msgid "suffix"
msgstr "sufixo"

#. (itstool) path: glossdef/para
#: book.translate.xml:4071
#, fuzzy
msgid ""
"The tail end of a file name. Usually begins with a period, like <filename>."
"c</filename> or <filename>.ms</filename>."
msgstr ""
"O final de um nome de arquivo. Geralmente começa com um ponto, como "
"<filename>. c </ filename> ou <nome do arquivo> .ms </ filename>."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4077
#, fuzzy
msgid "target"
msgstr "alvo"

#. (itstool) path: glossdef/para
#: book.translate.xml:4080
#, fuzzy
msgid ""
"A word to the left of the operator on a dependency line. More generally, any "
"file that <application>PMake</application> might create. A file may be (and "
"often is) both a target and a source (what it is depends on how "
"<application>PMake</application> is looking at it at the time – sort of like "
"the wave/particle duality of light, you know)."
msgstr ""
"Uma palavra à esquerda do operador em uma linha de dependência. Mais "
"geralmente, qualquer arquivo que <application> PMake </ application> pode "
"criar. Um arquivo pode ser (e muitas vezes é) tanto um alvo quanto uma fonte "
"(o que é depende de como <application> PMake </ application> está olhando "
"para ele no momento - mais ou menos como a dualidade onda / partícula da "
"luz, você sabe)."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4090
#, fuzzy
msgid "transformation rule"
msgstr "regra de transformação"

#. (itstool) path: glossdef/para
#: book.translate.xml:4093
#, fuzzy
msgid ""
"A special construct in a makefile that specifies how to create a file of one "
"type from a file of another, as indicated by their suffixes."
msgstr ""
"Uma construção especial em um makefile que especifica como criar um arquivo "
"de um tipo de um arquivo de outro, conforme indicado por seus sufixos."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4100
#, fuzzy
msgid "variable expansion"
msgstr "expansão variável"

#. (itstool) path: glossdef/para
#: book.translate.xml:4103
#, fuzzy
msgid ""
"The process of substituting the value of a variable for a reference to it. "
"Expansion may be altered by means of modifiers."
msgstr ""
"O processo de substituir o valor de uma variável por uma referência a ela. "
"Expansão pode ser alterada por meio de modificadores."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:4109
#, fuzzy
msgid "variable"
msgstr "variável"

#. (itstool) path: glossdef/para
#: book.translate.xml:4112
#, fuzzy
msgid ""
"A place in which to store text that may be retrieved later. Also used to "
"define the local environment. Conditionals exist that test whether a "
"variable is defined or not."
msgstr ""
"Um local no qual armazenar texto que pode ser recuperado posteriormente. "
"Também usado para definir o ambiente local. Existem condicionais que testam "
"se um variável é definida ou não."
